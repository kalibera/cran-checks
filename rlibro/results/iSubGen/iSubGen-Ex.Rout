
R Under development (unstable) (2021-04-15 r80171) -- "Unsuffered Consequences"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "iSubGen"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('iSubGen')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("apply.scaling")
> ### * apply.scaling
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: apply.scaling
> ### Title: Apply scaling factors
> ### Aliases: apply.scaling
> 
> ### ** Examples
> 
> 
> # Load molecular profiles for three data types and calculate scaling for each
> example.molecular.data.dir <- paste0(path.package('iSubGen'),'/exdata/');
> molecular.data <- list();
> scaling.factors <- list();
> for(i in c('cna','snv','methy')) {
+   # Load molecular profiles from example files saved 
+   # in the package as <data type>_profiles.txt
+   molecular.data[[i]] <- load.molecular.aberration.data(
+     paste0(example.molecular.data.dir,i,'_profiles.txt'),
+     patients = c(paste0('EP00',1:9), paste0('EP0',10:30))
+     );
+ 
+   scaling.factors[[i]] <- list();
+ 
+   scaling.factors[[i]]$center <- apply(molecular.data[[i]], 1, mean);
+   scaling.factors[[i]]$scale <- apply(molecular.data[[i]], 1, sd);
+   }
> 
> # Example 1: Transform the molecular profiles by the scaling factors
> scaled.molecular.data <- apply.scaling(molecular.data, scaling.factors);
> 
> # Example 2: Transform one of the data types based on the scaling factors
> scaled.molecular.data2 <- apply.scaling(
+   molecular.data[[1]],
+   scaling.factors[[1]]
+   );
> 
> 
> 
> cleanEx()
> nameEx("calculate.cis.matrix")
> ### * calculate.cis.matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: calculate.cis.matrix
> ### Title: Calculate consensus integrative correlation matrix
> ### Aliases: calculate.cis.matrix
> 
> ### ** Examples
> 
> 
> # Load molecular profiles for three data types from example files saved 
> # in the package as <data type>_profiles.txt
> example.molecular.data.dir <- paste0(path.package('iSubGen'),'/exdata/');
> molecular.data <- list();
> for(i in c('cna','snv','methy')) {
+   molecular.data[[i]] <- load.molecular.aberration.data(
+     paste0(example.molecular.data.dir,i,'_profiles.txt'),
+     patients = c(paste0('EP00',1:9), paste0('EP0',10:30))
+     );
+   }
> 
> # Example 1: calculate the consensus integrative similarity (CIS) matrix
> corr.matrix <- calculate.cis.matrix(
+   data.types = names(molecular.data),
+   data.matrices = molecular.data,
+   dist.metrics = list(
+     cna = 'euclidean',
+     snv = 'euclidean',
+     methy = 'euclidean'
+     ),
+   print.intermediary.similarity.matrices.to.file = FALSE
+   );
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
> 
> # Example 2: calculate the CIS matrix for patients EP001 through EP009 in relation 
> # to patients EP010 through EP030 meaning the profile of EP001 is correlated to 
> # the profiles of EP010 through EP030 so when assessing new patients, they can be 
> # compared to the training profiles
> corr.matrix2 <- calculate.cis.matrix(
+   data.types = names(molecular.data),
+   data.matrices = molecular.data,
+   dist.metrics = list(
+     cna = 'euclidean',
+     snv = 'euclidean',
+     methy = 'euclidean'
+     ),
+   patients.to.return = paste0('EP00',1:9),
+   patients.for.correlations = paste0('EP0',10:30),
+   print.intermediary.similarity.matrices.to.file = FALSE
+   );
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
> 
> # Example 3: Adjusting the proportion of the features that will be used to correlate 
> # the patient profiles
> corr.matrix3 <- calculate.cis.matrix(
+   data.types = names(molecular.data),
+   data.matrices = molecular.data,
+   dist.metrics = list(
+     cna = 'euclidean',
+     snv = 'euclidean',
+     methy = 'euclidean'
+     ),
+   patients.to.return = paste0('EP00',1:9),
+   patients.for.correlations = paste0('EP0',10:30),
+   feature.proportion = 0.6,
+   print.intermediary.similarity.matrices.to.file = FALSE
+   );
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
Metric: 'euclidean'; comparing: 26 vectors.
> 
> 
> 
> 
> cleanEx()
> nameEx("calculate.integrative.similarity.matrix")
> ### * calculate.integrative.similarity.matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: calculate.integrative.similarity.matrix
> ### Title: Calculate integrative similarity matrix
> ### Aliases: calculate.integrative.similarity.matrix
> 
> ### ** Examples
> 
> 
> # Load molecular profiles for three data types from example files saved 
> # in the package as <data type>_profiles.txt
> example.molecular.data.dir <- paste0(path.package('iSubGen'),'/exdata/');
> molecular.data <- list();
> for(i in c('cna','snv','methy')) {
+   molecular.data[[i]] <- load.molecular.aberration.data(
+     paste0(example.molecular.data.dir,i,'_profiles.txt'),
+     patients = c(paste0('EP00',1:9), paste0('EP0',10:30))
+     );
+   }
> 
> # Example 1: calculate integrative similarity between pairs of CNA, coding SNVs, methylation data
> corr.matrix <- calculate.integrative.similarity.matrix(
+   data.types = names(molecular.data),
+   data.matrices = molecular.data,
+   dist.metrics = list(
+     cna = 'euclidean',
+     snv = 'euclidean',
+     methy = 'euclidean'
+     )
+   );
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
> 
> # Example 2: calculate the integrative similarity for patients EP001 through EP009 
> # in relation to patients EP010 through EP030 meaning the profile of EP001 is 
> # correlated to the profiles of EP010 through EP030 so when assessing new patients,
> # they can be compared to the training profiles
> corr.matrix2 <- calculate.integrative.similarity.matrix(
+   data.types = names(molecular.data),
+   data.matrices = molecular.data,
+   dist.metrics = list(
+     cna = 'euclidean',
+     snv = 'euclidean',
+     methy = 'euclidean'
+     ),
+   patients.to.return = paste0('EP00',1:9),
+   patients.for.correlations = paste0('EP0',10:30)
+   );
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
> 
> # Example 3: Calculate integrative similarity between CNA and methylation data
> corr.matrix3 <- calculate.integrative.similarity.matrix(
+   data.types=names(molecular.data)[c(1,3)],
+   data.matrices=molecular.data[c(1,3)],
+   dist.metrics=list(
+     cna='euclidean',
+     snv='euclidean',
+     methy='euclidean'
+     )[c(1,3)],
+   patients.to.return=paste0('EP00',1:9),
+   patients.for.correlations=paste0('EP0',10:30)
+   );
Metric: 'euclidean'; comparing: 30 vectors.
Metric: 'euclidean'; comparing: 30 vectors.
> 
> 
> 
> cleanEx()
> nameEx("calculate.scaling")
> ### * calculate.scaling
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: calculate.scaling
> ### Title: Calculate scaling factors
> ### Aliases: calculate.scaling
> 
> ### ** Examples
> 
> 
> # Load molecular profiles for three data types from example files saved 
> # in the package as <data type>_profiles.txt
> example.molecular.data.dir <- paste0(path.package('iSubGen'),'/exdata/');
> molecular.data <- list();
> for(i in c('cna','snv','methy')) {
+   molecular.data[[i]] <- load.molecular.aberration.data(
+     paste0(example.molecular.data.dir,i,'_profiles.txt'),
+     patients = c(paste0('EP00',1:9), paste0('EP0',10:30))
+     );
+   }
> 
> # Example 1: Calculate scaling factors for all three data types
> scaling.factors <- calculate.scaling(molecular.data);
> 
> # Example 2: Calculate scaling factors for only the methylation data
> scaling.factors2 <- calculate.scaling(molecular.data[['methy']]);
> 
> 
> 
> cleanEx()
> nameEx("cluster.patients")
> ### * cluster.patients
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cluster.patients
> ### Title: Clustering to find patient subtypes
> ### Aliases: cluster.patients
> 
> ### ** Examples
> 
> ## Not run: 
> ##D 
> ##D # For this example instead of clustering CIS and IRF matrices,
> ##D # create a data matrix to see how the function works without
> ##D # running through the whole iSubGen process.
> ##D # This example is created with to have 4 distinct clusters
> ##D set.seed(5);
> ##D ex.matrix <- matrix(
> ##D   c(
> ##D     sample(c(0,1), 30, replace = TRUE), rep(1,75), rep(0,25),
> ##D     sample(c(0,1), 30, replace = TRUE), rep(1,75), rep(0,25),
> ##D     sample(c(0,1), 30, replace = TRUE), rep(1,75), rep(0,25),
> ##D     sample(c(0,1), 30, replace = TRUE), rep(1,100),
> ##D     sample(c(0,1), 30, replace = TRUE), rep(1,100),
> ##D     sample(c(0,1), 30, replace = TRUE), rep(1,100),
> ##D     sample(c(0,1), 30, replace = TRUE), rep(0,100),
> ##D     sample(c(0,1), 30, replace = TRUE), rep(0,100),
> ##D     sample(c(0,1), 30, replace = TRUE), rep(0,100),
> ##D     sample(c(0,1), 30, replace = TRUE), rep(0,75), rep(1,25),
> ##D     sample(c(0,1), 30, replace = TRUE), rep(0,75), rep(1,25),
> ##D     sample(c(0,1), 30, replace = TRUE), rep(0,75), rep(1,25)
> ##D     ),
> ##D   nrow=130);
> ##D rownames(ex.matrix) <- paste0('gene',1:130);
> ##D colnames(ex.matrix) <- paste0('patient',LETTERS[1:12]); 
> ##D 
> ##D # Use Consensus clustering to subtype the patient profiles
> ##D subtyping.results <- cluster.patients(
> ##D   data.matrix = ex.matrix,
> ##D   distance.metric = 'euclidean',
> ##D   parent.output.dir = './',
> ##D   new.result.dir = 'example_subtyping',
> ##D   max.num.subtypes = 6,
> ##D   clustering.reps = 50,
> ##D   consensus.cluster.write.table = FALSE
> ##D   );	
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("combine.integrative.features")
> ### * combine.integrative.features
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: combine.integrative.features
> ### Title: Combine iSubGen integrative features
> ### Aliases: combine.integrative.features
> 
> ### ** Examples
> 
> 
> # Create matrices for combining
> irf.matrix <- matrix(runif(25*4), ncol = 4);
> rownames(irf.matrix) <- c(paste0('EP00',1:9), paste0('EP0',10:25));
> cis.matrix <- matrix(runif(25*6), ncol=6);
> rownames(cis.matrix) <- c(paste0('EP00',1:9), paste0('EP0',10:25));
> 
> # Example 1: Join the matrices without any weighting adjustments
> isubgen.feature.matrix <- combine.integrative.features(
+   irf.matrix,
+   cis.matrix
+   )$integrative.feature.matrix;
> 
> # Example 2: Combine matrices after scaling each column by subtracting the mean
> # and dividing by the standard devation of the column
> isubgen.feature.matrix.rescaled.result <- combine.integrative.features(
+   irf.matrix,
+   cis.matrix,
+   irf.rescale.recenter = 'mean',
+   cis.rescale.recenter = 'mean',
+   irf.rescale.denominator = 'sd',
+   cis.rescale.denominator = 'sd'
+   );
> isubgen.feature.matrix.2 <- isubgen.feature.matrix.rescaled.result$integrative.feature.matrix;
> 
> # Example 3: Combine matrices 
> isubgen.feature.matrix.reweighted.result <- combine.integrative.features(
+   irf.matrix,
+   cis.matrix,
+   irf.weights = 1/4,
+   cis.weights = 1/6
+   );
> isubgen.feature.matrix.3 <- isubgen.feature.matrix.reweighted.result$integrative.feature.matrix;
> 
> 
> 
> cleanEx()
> nameEx("create.autoencoder")
> ### * create.autoencoder
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: create.autoencoder
> ### Title: Create an autoencoder for dimensionality reduction
> ### Aliases: create.autoencoder
> 
> ### ** Examples
> 
> ## Not run: 
> ##D 
> ##D example.molecular.data.dir <- paste0(path.package('iSubGen'),'/exdata/');
> ##D 
> ##D ae.result <- create.autoencoder(
> ##D   data.type = 'cna',
> ##D   data.matrix = load.molecular.aberration.data(
> ##D     paste0(example.molecular.data.dir,'cna_profiles.txt'),
> ##D     patients = c(paste0('EP00',1:9), paste0('EP0',10:30))
> ##D     ),
> ##D   encoder.layers.node.nums = c(15,5,2)
> ##D   );
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("create.autoencoder.irf.matrix")
> ### * create.autoencoder.irf.matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: create.autoencoder.irf.matrix
> ### Title: Create matrix of independent reduced features
> ### Aliases: create.autoencoder.irf.matrix
> 
> ### ** Examples
> 
> ## Not run: 
> ##D 
> ##D # Load three data types and create an autoencder for each
> ##D example.molecular.data.dir <- paste0(path.package('iSubGen'),'/exdata/');
> ##D molecular.data <- list();
> ##D ae.result <- list();
> ##D for(i in c('cna','snv','methy')) {
> ##D   molecular.data[[i]] <- load.molecular.aberration.data(
> ##D     paste0(example.molecular.data.dir,i,'_profiles.txt'),
> ##D     patients = c(paste0('EP00',1:9), paste0('EP0',10:30))
> ##D     );
> ##D   ae.result[[i]] <- create.autoencoder(
> ##D     data.type = i,
> ##D     data.matrix = molecular.data[[i]],
> ##D     encoder.layers.node.nums = c(10,2)
> ##D     )$autoencoder;
> ##D   }
> ##D 
> ##D # Create a matrix of the bottleneck layers 
> ##D irf.matrix <- create.autoencoder.irf.matrix(
> ##D   data.types = names(molecular.data),
> ##D   data.matrices = molecular.data,
> ##D   autoencoders = ae.result
> ##D   );
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("load.molecular.aberration.data")
> ### * load.molecular.aberration.data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: load.molecular.aberration.data
> ### Title: Load molecular aberration data
> ### Aliases: load.molecular.aberration.data
> 
> ### ** Examples
> 
> 
> example.aberration.data <- paste0(
+   path.package('iSubGen'),
+   '/exdata/cna_profiles.txt'
+   );
> 
> # Load the CNA profiles for patients EP001 through EP030
> cna.profiles <- load.molecular.aberration.data(
+   example.aberration.data,
+   patients = c(paste0('EP00',1:9), paste0('EP0',10:30))
+   );
> 
> # Load feature annotation for the CNA data
> cna.annotation <- load.molecular.aberration.data(
+   example.aberration.data,
+   annotation.fields = c('gene','start','end')
+   );
> 
> 
> 
> cleanEx()
> nameEx("read.scaling.factors")
> ### * read.scaling.factors
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read.scaling.factors
> ### Title: Read scaling factors from file
> ### Aliases: read.scaling.factors
> 
> ### ** Examples
> 
> 
> # Get the path for the scaling provided in this R package
> example.molecular.data.dir <- paste0(path.package('iSubGen'),'/exdata/');
> 
> # Example #1: reading scaling factors for a single data type
> scaling.factors <- read.scaling.factors(example.molecular.data.dir, 'cna');
Warning in read.scaling.factors(example.molecular.data.dir, "cna") :
  cannot open file '/var/scratch2ro/tomas/cran/rlibro/lib/iSubGen/exdata/cna_gene_recenter.txt': No such file or directory
Warning in read.scaling.factors(example.molecular.data.dir, "cna") :
  cannot open file '/var/scratch2ro/tomas/cran/rlibro/lib/iSubGen/exdata/cna_gene_rescale.txt': No such file or directory
> 
> # Example #2: reading scaling factors for multiple data types
> scaling.factors <- read.scaling.factors(example.molecular.data.dir, c('cna','snv','methy'));
Warning in read.scaling.factors(example.molecular.data.dir, c("cna", "snv",  :
  cannot open file '/var/scratch2ro/tomas/cran/rlibro/lib/iSubGen/exdata/cna_gene_recenter.txt': No such file or directory
Warning in read.scaling.factors(example.molecular.data.dir, c("cna", "snv",  :
  cannot open file '/var/scratch2ro/tomas/cran/rlibro/lib/iSubGen/exdata/cna_gene_rescale.txt': No such file or directory
Warning in read.scaling.factors(example.molecular.data.dir, c("cna", "snv",  :
  cannot open file '/var/scratch2ro/tomas/cran/rlibro/lib/iSubGen/exdata/snv_gene_recenter.txt': No such file or directory
Warning in read.scaling.factors(example.molecular.data.dir, c("cna", "snv",  :
  cannot open file '/var/scratch2ro/tomas/cran/rlibro/lib/iSubGen/exdata/snv_gene_rescale.txt': No such file or directory
Warning in read.scaling.factors(example.molecular.data.dir, c("cna", "snv",  :
  cannot open file '/var/scratch2ro/tomas/cran/rlibro/lib/iSubGen/exdata/methy_gene_recenter.txt': No such file or directory
Warning in read.scaling.factors(example.molecular.data.dir, c("cna", "snv",  :
  cannot open file '/var/scratch2ro/tomas/cran/rlibro/lib/iSubGen/exdata/methy_gene_rescale.txt': No such file or directory
> 
> 
> 
> cleanEx()
> nameEx("write.scaling.factors")
> ### * write.scaling.factors
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: write.scaling.factors
> ### Title: Write scaling factors to file
> ### Aliases: write.scaling.factors
> 
> ### ** Examples
> 
> 
> # load the aberration profiles for three data types 
> example.molecular.data.dir <- paste0(path.package('iSubGen'),'/exdata/');
> molecular.data <- list();
> for(i in c('cna','snv','methy')) {
+   molecular.data[[i]] <- load.molecular.aberration.data(
+     paste0(example.molecular.data.dir,i,'_profiles.txt'),
+     patients = c(paste0('EP00',1:9), paste0('EP0',10:30))
+     );
+   }
> 
> # calculate scaling factors for all three data types
> scaling.factors <- calculate.scaling(molecular.data);
> 
> # save the scaling factors to file
> write.scaling.factors(scaling.factors, example.molecular.data.dir);
Warning in file(file, ifelse(append, "a", "w")) :
  cannot open file '/var/scratch2ro/tomas/cran/rlibro/lib/iSubGen/exdata/cna_gene_recenter.txt': Read-only file system
Error in file(file, ifelse(append, "a", "w")) : 
  cannot open the connection
Calls: write.scaling.factors -> write.table -> file
Execution halted
