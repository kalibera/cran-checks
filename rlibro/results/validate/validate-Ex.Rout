
R Under development (unstable) (2025-11-30 r89080) -- "Unsuffered Consequences"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "validate"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('validate')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("add_indicators")
> ### * add_indicators
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: add_indicators
> ### Title: Add indicator values as columns to a data frame
> ### Aliases: add_indicators
> 
> ### ** Examples
> 
> ii <- indicator(
+  hihi = 2*sqrt(height)
+  , haha = log10(weight)
+  , lulz = mean(height)
+  , wo0t = median(weight)
+ )
> 
> # note: mean and median are repeated
> add_indicators(women, ii)
   height weight     hihi     haha lulz wo0t
1      58    115 15.23155 2.060698   65  135
2      59    117 15.36229 2.068186   65  135
3      60    120 15.49193 2.079181   65  135
4      61    123 15.62050 2.089905   65  135
5      62    126 15.74802 2.100371   65  135
6      63    129 15.87451 2.110590   65  135
7      64    132 16.00000 2.120574   65  135
8      65    135 16.12452 2.130334   65  135
9      66    139 16.24808 2.143015   65  135
10     67    142 16.37071 2.152288   65  135
11     68    146 16.49242 2.164353   65  135
12     69    150 16.61325 2.176091   65  135
13     70    154 16.73320 2.187521   65  135
14     71    159 16.85230 2.201397   65  135
15     72    164 16.97056 2.214844   65  135
> 
> # compute indicators first, then add
> out <- confront(women, ii)
> add_indicators(women, out)
   height weight     hihi     haha lulz wo0t
1      58    115 15.23155 2.060698   65  135
2      59    117 15.36229 2.068186   65  135
3      60    120 15.49193 2.079181   65  135
4      61    123 15.62050 2.089905   65  135
5      62    126 15.74802 2.100371   65  135
6      63    129 15.87451 2.110590   65  135
7      64    132 16.00000 2.120574   65  135
8      65    135 16.12452 2.130334   65  135
9      66    139 16.24808 2.143015   65  135
10     67    142 16.37071 2.152288   65  135
11     68    146 16.49242 2.164353   65  135
12     69    150 16.61325 2.176091   65  135
13     70    154 16.73320 2.187521   65  135
14     71    159 16.85230 2.201397   65  135
15     72    164 16.97056 2.214844   65  135
> 
> 
> 
> 
> cleanEx()
> nameEx("aggregate-validation-method")
> ### * aggregate-validation-method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aggregate,validation-method
> ### Title: Aggregate validation results
> ### Aliases: aggregate,validation-method
> 
> ### ** Examples
> 
> 
> data(retailers)
> retailers$id <- paste0("ret",1:nrow(retailers))
> v <- validator(
+     staff.costs/staff < 25
+   , turnover + other.rev==total.rev)
> 
> cf <- confront(retailers,v,key="id")
> a <- aggregate(cf,by='record')
> head(a)
    id npass nfail nNA rel.pass rel.fail rel.NA
1 ret1     0     0   2      0.0      0.0    1.0
2 ret2     1     0   1      0.5      0.0    0.5
3 ret3     0     1   1      0.0      0.5    0.5
4 ret4     1     0   1      0.5      0.0    0.5
5 ret5     0     0   2      0.0      0.0    1.0
6 ret6     0     0   2      0.0      0.0    1.0
> 
> # or, get a sorted result:
> s <- sort(cf, by='record')
> head(s)
      id npass nfail nNA rel.pass rel.fail rel.NA
1   ret1     0     0   2        0      0.0    1.0
3   ret3     0     1   1        0      0.5    0.5
5   ret5     0     0   2        0      0.0    1.0
6   ret6     0     0   2        0      0.0    1.0
7   ret7     0     1   1        0      0.5    0.5
10 ret10     0     0   2        0      0.0    1.0
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("all-validation-method")
> ### * all-validation-method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: all,validation-method
> ### Title: Test if all validations resulted in TRUE
> ### Aliases: all,validation-method
> 
> ### ** Examples
> 
> val <- check_that(women, height>60, weight>0)
> all(val)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("any-validation-method")
> ### * any-validation-method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: any,validation-method
> ### Title: Test if any validation resulted in TRUE
> ### Aliases: any,validation-method
> 
> ### ** Examples
> 
> val <- check_that(women, height>60, weight>0)
> any(val)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("as.data.frame-cellComparison-method")
> ### * as.data.frame-cellComparison-method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.data.frame,cellComparison-method
> ### Title: Translate cellComparison objects to data frame
> ### Aliases: as.data.frame,cellComparison-method
> 
> ### ** Examples
> 
> data(retailers)
> 
> # start with raw data
> step0 <- retailers
> 
> # impute turnovers
> step1 <- step0
> step1$turnover[is.na(step1$turnover)] <- mean(step1$turnover,na.rm=TRUE)
> 
> # flip sign of negative revenues
> step2 <- step1
> step2$other.rev <- abs(step2$other.rev)
>   
> 
> # create an overview of differences, comparing to the previous step
> cells(raw = step0, imputed = step1, flipped = step2, compare="sequential")
Object of class cellComparison:

   cells(raw = step0, imputed = step1, flipped = step2, compare = "sequential")

                raw imputed flipped
cells           600     600     600
available       520     524     524
still_available 520     520     524
unadapted       520     520     523
adapted           0       0       1
imputed           0       4       0
missing          80      76      76
still_missing    80      76      76
removed           0       0       0
> 
> # create an overview of differences compared to raw data
> out <- cells(raw = step0, imputed = step1, flipped = step2)
> out
Object of class cellComparison:

   cells(raw = step0, imputed = step1, flipped = step2)

                raw imputed flipped
cells           600     600     600
available       520     524     524
still_available 520     520     520
unadapted       520     520     519
adapted           0       0       1
imputed           0       4       4
missing          80      76      76
still_missing    80      76      76
removed           0       0       0
> 
> # Graphical overview of the changes
> plot(out)
> barplot(out)
> 
> # transform data to data.frame (easy for use with ggplot)
> as.data.frame(out)
            status version count
1            cells     raw   600
2        available     raw   520
3  still_available     raw   520
4        unadapted     raw   520
5          adapted     raw     0
6          imputed     raw     0
7          missing     raw    80
8    still_missing     raw    80
9          removed     raw     0
10           cells imputed   600
11       available imputed   524
12 still_available imputed   520
13       unadapted imputed   520
14         adapted imputed     0
15         imputed imputed     4
16         missing imputed    76
17   still_missing imputed    76
18         removed imputed     0
19           cells flipped   600
20       available flipped   524
21 still_available flipped   520
22       unadapted flipped   519
23         adapted flipped     1
24         imputed flipped     4
25         missing flipped    76
26   still_missing flipped    76
27         removed flipped     0
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("as.data.frame-confrontation-method")
> ### * as.data.frame-confrontation-method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.data.frame,confrontation-method
> ### Title: Coerce a confrontation object to data frame
> ### Aliases: as.data.frame,confrontation-method
> 
> ### ** Examples
> 
> cf <- check_that(women, height > 0, sd(weight) > 0)
> as.data.frame(cf)
   name value     expression
1    V1  TRUE     height > 0
2    V1  TRUE     height > 0
3    V1  TRUE     height > 0
4    V1  TRUE     height > 0
5    V1  TRUE     height > 0
6    V1  TRUE     height > 0
7    V1  TRUE     height > 0
8    V1  TRUE     height > 0
9    V1  TRUE     height > 0
10   V1  TRUE     height > 0
11   V1  TRUE     height > 0
12   V1  TRUE     height > 0
13   V1  TRUE     height > 0
14   V1  TRUE     height > 0
15   V1  TRUE     height > 0
16   V2  TRUE sd(weight) > 0
> 
> # add id-column
> women$id <- letters[1:15]
> i <- indicator(mw = mean(weight), ratio = weight/height)
> as.data.frame(confront(women, i, key="id"))
     id  name      value    expression
1  <NA>    mw 136.733333  mean(weight)
2     a ratio   1.982759 weight/height
3     b ratio   1.983051 weight/height
4     c ratio   2.000000 weight/height
5     d ratio   2.016393 weight/height
6     e ratio   2.032258 weight/height
7     f ratio   2.047619 weight/height
8     g ratio   2.062500 weight/height
9     h ratio   2.076923 weight/height
10    i ratio   2.106061 weight/height
11    j ratio   2.119403 weight/height
12    k ratio   2.147059 weight/height
13    l ratio   2.173913 weight/height
14    m ratio   2.200000 weight/height
15    n ratio   2.239437 weight/height
16    o ratio   2.277778 weight/height
> 
> 
> 
> 
> cleanEx()
> nameEx("as.data.frame-validatorComparison-method")
> ### * as.data.frame-validatorComparison-method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.data.frame,validatorComparison-method
> ### Title: Translate a validatorComparison object to data frame
> ### Aliases: as.data.frame,validatorComparison-method
> 
> ### ** Examples
> 
> data(retailers)
> 
> rules <- validator(turnover >=0, staff>=0, other.rev>=0)
> 
> # start with raw data
> step0 <- retailers
> 
> # impute turnovers
> step1 <- step0
> step1$turnover[is.na(step1$turnover)] <- mean(step1$turnover,na.rm=TRUE)
> 
> # flip sign of negative revenues
> step2 <- step1
> step2$other.rev <- abs(step2$other.rev)
>   
> # create an overview of differences, comparing to the previous step
> compare(rules, raw = step0, imputed = step1, flipped = step2, how="sequential")
Object of class validatorComparison:

   compare(x = rules, raw = step0, imputed = step1, flipped = step2, how = "sequential")

                    Version
Status               raw imputed flipped
  validations        180     180     180
  verifiable         134     138     138
  unverifiable        46      42      42
  still_unverifiable  46      42      42
  new_unverifiable     0       0       0
  satisfied          133     137     138
  still_satisfied    133     133     137
  new_satisfied        0       4       1
  violated             1       1       0
  still_violated       1       1       0
  new_violated         0       0       0
> 
> # create an overview of differences compared to raw data
> out <- compare(rules, raw = step0, imputed = step1, flipped = step2)
> out
Object of class validatorComparison:

   compare(x = rules, raw = step0, imputed = step1, flipped = step2)

                    Version
Status               raw imputed flipped
  validations        180     180     180
  verifiable         134     138     138
  unverifiable        46      42      42
  still_unverifiable  46      42      42
  new_unverifiable     0       0       0
  satisfied          133     137     138
  still_satisfied    133     133     133
  new_satisfied        0       4       5
  violated             1       1       0
  still_violated       1       1       0
  new_violated         0       0       0
> 
> # graphical overview
> plot(out)
> barplot(out)
> 
> # transform data to data.frame (easy for use with ggplot)
> as.data.frame(out)
               status version count
1         validations     raw   180
2          verifiable     raw   134
3        unverifiable     raw    46
4  still_unverifiable     raw    46
5    new_unverifiable     raw     0
6           satisfied     raw   133
7     still_satisfied     raw   133
8       new_satisfied     raw     0
9            violated     raw     1
10     still_violated     raw     1
11       new_violated     raw     0
12        validations imputed   180
13         verifiable imputed   138
14       unverifiable imputed    42
15 still_unverifiable imputed    42
16   new_unverifiable imputed     0
17          satisfied imputed   137
18    still_satisfied imputed   133
19      new_satisfied imputed     4
20           violated imputed     1
21     still_violated imputed     1
22       new_violated imputed     0
23        validations flipped   180
24         verifiable flipped   138
25       unverifiable flipped    42
26 still_unverifiable flipped    42
27   new_unverifiable flipped     0
28          satisfied flipped   138
29    still_satisfied flipped   133
30      new_satisfied flipped     5
31           violated flipped     0
32     still_violated flipped     0
33       new_violated flipped     0
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("barplot-validation-method")
> ### * barplot-validation-method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: barplot,validation-method
> ### Title: Plot number of violations
> ### Aliases: barplot,validation-method
> 
> ### ** Examples
> 
> data(retailers)
> cf <- check_that(retailers
+     , staff.costs < total.costs
+     , turnover + other.rev == total.rev
+     , other.rev > 0
+     , total.rev > 0)
> barplot(cf)
Warning: The 'barplot' method for confrontation objects is deprecated. Use 'plot' instead
> 
> 
> 
> 
> cleanEx()
> nameEx("barplot-validatorComparison-method")
> ### * barplot-validatorComparison-method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: barplot,validatorComparison-method
> ### Title: Barplot of validatorComparison object
> ### Aliases: barplot,validatorComparison-method
> 
> ### ** Examples
> 
> data(retailers)
> 
> rules <- validator(turnover >=0, staff>=0, other.rev>=0)
> 
> # start with raw data
> step0 <- retailers
> 
> # impute turnovers
> step1 <- step0
> step1$turnover[is.na(step1$turnover)] <- mean(step1$turnover,na.rm=TRUE)
> 
> # flip sign of negative revenues
> step2 <- step1
> step2$other.rev <- abs(step2$other.rev)
>   
> # create an overview of differences, comparing to the previous step
> compare(rules, raw = step0, imputed = step1, flipped = step2, how="sequential")
Object of class validatorComparison:

   compare(x = rules, raw = step0, imputed = step1, flipped = step2, how = "sequential")

                    Version
Status               raw imputed flipped
  validations        180     180     180
  verifiable         134     138     138
  unverifiable        46      42      42
  still_unverifiable  46      42      42
  new_unverifiable     0       0       0
  satisfied          133     137     138
  still_satisfied    133     133     137
  new_satisfied        0       4       1
  violated             1       1       0
  still_violated       1       1       0
  new_violated         0       0       0
> 
> # create an overview of differences compared to raw data
> out <- compare(rules, raw = step0, imputed = step1, flipped = step2)
> out
Object of class validatorComparison:

   compare(x = rules, raw = step0, imputed = step1, flipped = step2)

                    Version
Status               raw imputed flipped
  validations        180     180     180
  verifiable         134     138     138
  unverifiable        46      42      42
  still_unverifiable  46      42      42
  new_unverifiable     0       0       0
  satisfied          133     137     138
  still_satisfied    133     133     133
  new_satisfied        0       4       5
  violated             1       1       0
  still_violated       1       1       0
  new_violated         0       0       0
> 
> # graphical overview
> plot(out)
> barplot(out)
> 
> # transform data to data.frame (easy for use with ggplot)
> as.data.frame(out)
               status version count
1         validations     raw   180
2          verifiable     raw   134
3        unverifiable     raw    46
4  still_unverifiable     raw    46
5    new_unverifiable     raw     0
6           satisfied     raw   133
7     still_satisfied     raw   133
8       new_satisfied     raw     0
9            violated     raw     1
10     still_violated     raw     1
11       new_violated     raw     0
12        validations imputed   180
13         verifiable imputed   138
14       unverifiable imputed    42
15 still_unverifiable imputed    42
16   new_unverifiable imputed     0
17          satisfied imputed   137
18    still_satisfied imputed   133
19      new_satisfied imputed     4
20           violated imputed     1
21     still_violated imputed     1
22       new_violated imputed     0
23        validations flipped   180
24         verifiable flipped   138
25       unverifiable flipped    42
26 still_unverifiable flipped    42
27   new_unverifiable flipped     0
28          satisfied flipped   138
29    still_satisfied flipped   133
30      new_satisfied flipped     5
31           violated flipped     0
32     still_violated flipped     0
33       new_violated flipped     0
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("cells")
> ### * cells
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cells
> ### Title: Cell counts and differences for a series of datasets
> ### Aliases: cells
> 
> ### ** Examples
> 
> data(retailers)
> 
> # start with raw data
> step0 <- retailers
> 
> # impute turnovers
> step1 <- step0
> step1$turnover[is.na(step1$turnover)] <- mean(step1$turnover,na.rm=TRUE)
> 
> # flip sign of negative revenues
> step2 <- step1
> step2$other.rev <- abs(step2$other.rev)
>   
> 
> # create an overview of differences, comparing to the previous step
> cells(raw = step0, imputed = step1, flipped = step2, compare="sequential")
Object of class cellComparison:

   cells(raw = step0, imputed = step1, flipped = step2, compare = "sequential")

                raw imputed flipped
cells           600     600     600
available       520     524     524
still_available 520     520     524
unadapted       520     520     523
adapted           0       0       1
imputed           0       4       0
missing          80      76      76
still_missing    80      76      76
removed           0       0       0
> 
> # create an overview of differences compared to raw data
> out <- cells(raw = step0, imputed = step1, flipped = step2)
> out
Object of class cellComparison:

   cells(raw = step0, imputed = step1, flipped = step2)

                raw imputed flipped
cells           600     600     600
available       520     524     524
still_available 520     520     520
unadapted       520     520     519
adapted           0       0       1
imputed           0       4       4
missing          80      76      76
still_missing    80      76      76
removed           0       0       0
> 
> # Graphical overview of the changes
> plot(out)
> barplot(out)
> 
> # transform data to data.frame (easy for use with ggplot)
> as.data.frame(out)
            status version count
1            cells     raw   600
2        available     raw   520
3  still_available     raw   520
4        unadapted     raw   520
5          adapted     raw     0
6          imputed     raw     0
7          missing     raw    80
8    still_missing     raw    80
9          removed     raw     0
10           cells imputed   600
11       available imputed   524
12 still_available imputed   520
13       unadapted imputed   520
14         adapted imputed     0
15         imputed imputed     4
16         missing imputed    76
17   still_missing imputed    76
18         removed imputed     0
19           cells flipped   600
20       available flipped   524
21 still_available flipped   520
22       unadapted flipped   519
23         adapted flipped     1
24         imputed flipped     4
25         missing flipped    76
26   still_missing flipped    76
27         removed flipped     0
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("check_that")
> ### * check_that
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: check_that
> ### Title: Simple data validation interface
> ### Aliases: check_that
> 
> ### ** Examples
> 
> 
> cf <- check_that(women, height>0, height/weight < 0.5)
> cf
Object of class 'validation'
Call:
    check_that(women, height > 0, height/weight < 0.5)

Rules confronted: 2
   With fails   : 1
   With missings: 0
   Threw warning: 0
   Threw error  : 0
> summary(cf)
  name items passes fails nNA error warning          expression
1   V1    15     15     0   0 FALSE   FALSE          height > 0
2   V2    15     12     3   0 FALSE   FALSE height/weight < 0.5
> barplot(cf)
Warning: The 'barplot' method for confrontation objects is deprecated. Use 'plot' instead
> 
> 
> ## Not run: 
> ##D # this works only after loading the 'magrittr' package
> ##D women %>% 
> ##D   check_that(height>0, height/weight < 0.5) %>%
> ##D   summary()
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("compare")
> ### * compare
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compare
> ### Title: Compare similar data sets
> ### Aliases: compare compare,validator-method compare,indicator-method
> 
> ### ** Examples
> 
> data(retailers)
> 
> rules <- validator(turnover >=0, staff>=0, other.rev>=0)
> 
> # start with raw data
> step0 <- retailers
> 
> # impute turnovers
> step1 <- step0
> step1$turnover[is.na(step1$turnover)] <- mean(step1$turnover,na.rm=TRUE)
> 
> # flip sign of negative revenues
> step2 <- step1
> step2$other.rev <- abs(step2$other.rev)
>   
> # create an overview of differences, comparing to the previous step
> compare(rules, raw = step0, imputed = step1, flipped = step2, how="sequential")
Object of class validatorComparison:

   compare(x = rules, raw = step0, imputed = step1, flipped = step2, how = "sequential")

                    Version
Status               raw imputed flipped
  validations        180     180     180
  verifiable         134     138     138
  unverifiable        46      42      42
  still_unverifiable  46      42      42
  new_unverifiable     0       0       0
  satisfied          133     137     138
  still_satisfied    133     133     137
  new_satisfied        0       4       1
  violated             1       1       0
  still_violated       1       1       0
  new_violated         0       0       0
> 
> # create an overview of differences compared to raw data
> out <- compare(rules, raw = step0, imputed = step1, flipped = step2)
> out
Object of class validatorComparison:

   compare(x = rules, raw = step0, imputed = step1, flipped = step2)

                    Version
Status               raw imputed flipped
  validations        180     180     180
  verifiable         134     138     138
  unverifiable        46      42      42
  still_unverifiable  46      42      42
  new_unverifiable     0       0       0
  satisfied          133     137     138
  still_satisfied    133     133     133
  new_satisfied        0       4       5
  violated             1       1       0
  still_violated       1       1       0
  new_violated         0       0       0
> 
> # graphical overview
> plot(out)
> barplot(out)
> 
> # transform data to data.frame (easy for use with ggplot)
> as.data.frame(out)
               status version count
1         validations     raw   180
2          verifiable     raw   134
3        unverifiable     raw    46
4  still_unverifiable     raw    46
5    new_unverifiable     raw     0
6           satisfied     raw   133
7     still_satisfied     raw   133
8       new_satisfied     raw     0
9            violated     raw     1
10     still_violated     raw     1
11       new_violated     raw     0
12        validations imputed   180
13         verifiable imputed   138
14       unverifiable imputed    42
15 still_unverifiable imputed    42
16   new_unverifiable imputed     0
17          satisfied imputed   137
18    still_satisfied imputed   133
19      new_satisfied imputed     4
20           violated imputed     1
21     still_violated imputed     1
22       new_violated imputed     0
23        validations flipped   180
24         verifiable flipped   138
25       unverifiable flipped    42
26 still_unverifiable flipped    42
27   new_unverifiable flipped     0
28          satisfied flipped   138
29    still_satisfied flipped   133
30      new_satisfied flipped     5
31           violated flipped     0
32     still_violated flipped     0
33       new_violated flipped     0
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("confront")
> ### * confront
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: confront
> ### Title: Confront data with a (set of) expressionset(s)
> ### Aliases: confront confront,data.frame,indicator,ANY-method
> ###   confront,data.frame,indicator,environment-method
> ###   confront,data.frame,indicator,data.frame-method
> ###   confront,data.frame,indicator,list-method
> ###   confront,data.frame,validator,ANY-method
> ###   confront,data.frame,validator,environment-method
> ###   confront,data.frame,validator,data.frame-method
> ###   confront,data.frame,validator,list-method
> 
> ### ** Examples
> 
> 
> # a basic validation example
> v <- validator(height/weight < 0.5, mean(height) >= 0)
> cf <- confront(women, v)
> summary(cf)
  name items passes fails nNA error warning          expression
1   V1    15     12     3   0 FALSE   FALSE height/weight < 0.5
2   V2     1      1     0   0 FALSE   FALSE   mean(height) >= 0
> plot(cf)
> as.data.frame(cf)
   name value          expression
1    V1 FALSE height/weight < 0.5
2    V1 FALSE height/weight < 0.5
3    V1 FALSE height/weight < 0.5
4    V1  TRUE height/weight < 0.5
5    V1  TRUE height/weight < 0.5
6    V1  TRUE height/weight < 0.5
7    V1  TRUE height/weight < 0.5
8    V1  TRUE height/weight < 0.5
9    V1  TRUE height/weight < 0.5
10   V1  TRUE height/weight < 0.5
11   V1  TRUE height/weight < 0.5
12   V1  TRUE height/weight < 0.5
13   V1  TRUE height/weight < 0.5
14   V1  TRUE height/weight < 0.5
15   V1  TRUE height/weight < 0.5
16   V2  TRUE   mean(height) >= 0
> 
> # an example checking metadata
> v <- validator(nrow(.) == 15, ncol(.) > 2)
> summary(confront(women, v))
  name items passes fails nNA error warning    expression
1   V1     1      1     0   0 FALSE   FALSE nrow(.) == 15
2   V2     1      0     1   0 FALSE   FALSE   ncol(.) > 2
> 
> # An example using reference data
> v <- validator(weight == ref$weight)
> summary(confront(women, v, women))
  name items passes fails nNA error warning                expression
1   V1    15     15     0   0 FALSE   FALSE weight == ref[["weight"]]
> 
> # Usging custom names for reference data
> v <- validator(weight == test$weight)
> summary( confront(women,v, list(test=women)) )
  name items passes fails nNA error warning                 expression
1   V1    15     15     0   0 FALSE   FALSE weight == test[["weight"]]
> 
> # Reference data in an environment
> e <- new.env()
> e$test <- women
> v <- validator(weight == test$weight)
> summary( confront(women, v, e) )
  name items passes fails nNA error warning                 expression
1   V1    15     15     0   0 FALSE   FALSE weight == test[["weight"]]
> 
> # the effect of using a key
> w <- women
> w$id <- letters[1:nrow(w)]
> v <- validator(weight == ref$weight)
> 
> # with complete data; already matching
> values( confront(w, v, w, key='id'))
        V1
 [1,] TRUE
 [2,] TRUE
 [3,] TRUE
 [4,] TRUE
 [5,] TRUE
 [6,] TRUE
 [7,] TRUE
 [8,] TRUE
 [9,] TRUE
[10,] TRUE
[11,] TRUE
[12,] TRUE
[13,] TRUE
[14,] TRUE
[15,] TRUE
> 
> # with scrambled rows in reference data (reference gets sorted according to dat)
> i <- sample(nrow(w))
> values(confront(w, v, w[i,],key='id'))
         V1
 [1,] FALSE
 [2,] FALSE
 [3,] FALSE
 [4,] FALSE
 [5,] FALSE
 [6,] FALSE
 [7,] FALSE
 [8,] FALSE
 [9,] FALSE
[10,] FALSE
[11,] FALSE
[12,] FALSE
[13,] FALSE
[14,] FALSE
[15,] FALSE
> 
> # with incomplete reference data
> values(confront(w, v, w[1:10,],key='id'))
         V1
 [1,]  TRUE
 [2,]  TRUE
 [3,]  TRUE
 [4,]  TRUE
 [5,]  TRUE
 [6,]  TRUE
 [7,]  TRUE
 [8,]  TRUE
 [9,]  TRUE
[10,]  TRUE
[11,] FALSE
[12,] FALSE
[13,] FALSE
[14,] FALSE
[15,] FALSE
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("contains_exactly")
> ### * contains_exactly
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: contains_exactly
> ### Title: Check records using a predifined table of (im)possible values
> ### Aliases: contains_exactly contains_at_least contains_at_most
> ###   does_not_contain
> 
> ### ** Examples
> 
> 
> ## Check that data is present for all quarters in 2018-2019
> dat <- data.frame(
+     year    = rep(c("2018","2019"),each=4)
+   , quarter = rep(sprintf("Q%d",1:4), 2)
+   , value   = sample(20:50,8)
+ )
> 
> # Method 1: creating a data frame in-place (only for simple cases)
> rule <- validator(contains_exactly(
+            expand.grid(year=c("2018","2019"), quarter=c("Q1","Q2","Q3","Q4"))
+           )
+         )
> out <- confront(dat, rule)
> values(out)
       V1
[1,] TRUE
[2,] TRUE
[3,] TRUE
[4,] TRUE
[5,] TRUE
[6,] TRUE
[7,] TRUE
[8,] TRUE
> 
> # Method 2: pass the keyset to 'confront', and reference it in the rule.
> # this scales to larger key sets but it needs a 'contract' between the
> # rule definition and how 'confront' is called.
> 
> keyset <- expand.grid(year=c("2018","2019"), quarter=c("Q1","Q2","Q3","Q4"))
> rule <- validator(contains_exactly(all_keys))
> out <- confront(dat, rule, ref=list(all_keys = keyset))
> values(out)
       V1
[1,] TRUE
[2,] TRUE
[3,] TRUE
[4,] TRUE
[5,] TRUE
[6,] TRUE
[7,] TRUE
[8,] TRUE
> 
> ## Globbing (use * as a wildcard)
> 
> # transaction data 
> transactions <- data.frame(
+     sender   = c("S21", "X34", "S45","Z22")
+   , receiver = c("FG0", "FG2", "DF1","KK2")
+   , value    = sample(70:100,4)
+ )
> 
> # forbidden combinations: if the sender starts with "S", 
> # the receiver can not start "FG"
> forbidden <- data.frame(sender="S*",receiver = "FG*")
> 
> rule <- validator(does_not_contain(glob(forbidden_keys)))
> out <- confront(transactions, rule, ref=list(forbidden_keys=forbidden))
> values(out)
        V1
[1,] FALSE
[2,]  TRUE
[3,]  TRUE
[4,]  TRUE
> 
> 
> ## Quick interactive testing
> # use 'with':
> with(transactions, does_not_contain(forbidden)) 
[1] TRUE TRUE TRUE TRUE
> 
> 
> 
> ## Grouping 
> 
> # data in 'long' format
> dat <- expand.grid(
+   year = c("2018","2019")
+   , quarter = c("Q1","Q2","Q3","Q4")
+   , variable = c("import","export")
+ )
> dat$value <- sample(50:100,nrow(dat))
> 
> 
> periods <- expand.grid(
+   year = c("2018","2019")
+   , quarter = c("Q1","Q2","Q3","Q4")
+ )
> 
> rule <- validator(contains_exactly(all_periods, by=variable))
> 
> out <- confront(dat, rule, ref=list(all_periods=periods))
> values(out)
        V1
 [1,] TRUE
 [2,] TRUE
 [3,] TRUE
 [4,] TRUE
 [5,] TRUE
 [6,] TRUE
 [7,] TRUE
 [8,] TRUE
 [9,] TRUE
[10,] TRUE
[11,] TRUE
[12,] TRUE
[13,] TRUE
[14,] TRUE
[15,] TRUE
[16,] TRUE
> 
> # remove one  export record
> 
> dat1 <- dat[-15,]
> out1 <- confront(dat1, rule, ref=list(all_periods=periods))
> values(out1)
         V1
 [1,]  TRUE
 [2,]  TRUE
 [3,]  TRUE
 [4,]  TRUE
 [5,]  TRUE
 [6,]  TRUE
 [7,]  TRUE
 [8,]  TRUE
 [9,] FALSE
[10,] FALSE
[11,] FALSE
[12,] FALSE
[13,] FALSE
[14,] FALSE
[15,] FALSE
> values(out1)
         V1
 [1,]  TRUE
 [2,]  TRUE
 [3,]  TRUE
 [4,]  TRUE
 [5,]  TRUE
 [6,]  TRUE
 [7,]  TRUE
 [8,]  TRUE
 [9,] FALSE
[10,] FALSE
[11,] FALSE
[12,] FALSE
[13,] FALSE
[14,] FALSE
[15,] FALSE
> 
> 
> 
> 
> cleanEx()
> nameEx("created")
> ### * created
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: created
> ### Title: Creation timestamp
> ### Aliases: created created<- created,rule-method
> ###   created<-,rule,POSIXct-method created,expressionset-method
> ###   created<-,expressionset,POSIXct-method
> 
> ### ** Examples
> 
> 
> # retrieve properties
> v <- validator(turnover > 0, staff.costs>0)
> 
> # number of rules in v:
> length(v)
[1] 2
> 
> # per-rule
> created(v)
[1] "2025-12-01 03:28:10 CST" "2025-12-01 03:28:10 CST"
> origin(v)
            V1             V2 
"command-line" "command-line" 
> names(v)
[1] "V1" "V2"
> 
> # set properties
> names(v)[1] <- "p1"
> 
> label(v)[1] <- "turnover positive"
> description(v)[1] <- "
+ According to the official definition,
+ only positive values can be considered
+ valid turnovers.
+ "
> 
> # short description is also printed:
> v
Object of class 'validator' with 2 elements:
 p1 [turnover positive]: turnover > 0
 V2                    : staff.costs > 0
> 
> # print all info for first rule
> v[[1]]

Object of class rule.
 expr       : turnover > 0 
 name       : p1 
 label      : turnover positive 
 description: 
According to the official definition,
only positive values can be considered
valid turnovers.
 
 origin     : command-line 
 created    : 2025-12-01 03:28:10
 meta       : language<chr>, severity<chr>> 
> 
> 
> # retrieve properties
> v <- validator(turnover > 0, staff.costs>0)
> 
> # number of rules in v:
> length(v)
[1] 2
> 
> # per-rule
> created(v)
[1] "2025-12-01 03:28:10 CST" "2025-12-01 03:28:10 CST"
> origin(v)
            V1             V2 
"command-line" "command-line" 
> names(v)
[1] "V1" "V2"
> 
> # set properties
> names(v)[1] <- "p1"
> 
> label(v)[1] <- "turnover positive"
> description(v)[1] <- "
+ According to the official definition,
+ only positive values can be considered
+ valid turnovers.
+ "
> 
> # short description is also printed:
> v
Object of class 'validator' with 2 elements:
 p1 [turnover positive]: turnover > 0
 V2                    : staff.costs > 0
> 
> # print all info for first rule
> v[[1]]

Object of class rule.
 expr       : turnover > 0 
 name       : p1 
 label      : turnover positive 
 description: 
According to the official definition,
only positive values can be considered
valid turnovers.
 
 origin     : command-line 
 created    : 2025-12-01 03:28:10
 meta       : language<chr>, severity<chr>> 
> 
> 
> 
> 
> cleanEx()
> nameEx("description")
> ### * description
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: description
> ### Title: Rule description
> ### Aliases: description description<- description,rule-method
> ###   description<-,rule,character-method description,expressionset-method
> ###   description<-,expressionset,character-method
> 
> ### ** Examples
> 
> 
> # retrieve properties
> v <- validator(turnover > 0, staff.costs>0)
> 
> # number of rules in v:
> length(v)
[1] 2
> 
> # per-rule
> created(v)
[1] "2025-12-01 03:28:10 CST" "2025-12-01 03:28:10 CST"
> origin(v)
            V1             V2 
"command-line" "command-line" 
> names(v)
[1] "V1" "V2"
> 
> # set properties
> names(v)[1] <- "p1"
> 
> label(v)[1] <- "turnover positive"
> description(v)[1] <- "
+ According to the official definition,
+ only positive values can be considered
+ valid turnovers.
+ "
> 
> # short description is also printed:
> v
Object of class 'validator' with 2 elements:
 p1 [turnover positive]: turnover > 0
 V2                    : staff.costs > 0
> 
> # print all info for first rule
> v[[1]]

Object of class rule.
 expr       : turnover > 0 
 name       : p1 
 label      : turnover positive 
 description: 
According to the official definition,
only positive values can be considered
valid turnovers.
 
 origin     : command-line 
 created    : 2025-12-01 03:28:10
 meta       : language<chr>, severity<chr>> 
> 
> 
> # retrieve properties
> v <- validator(turnover > 0, staff.costs>0)
> 
> # number of rules in v:
> length(v)
[1] 2
> 
> # per-rule
> created(v)
[1] "2025-12-01 03:28:10 CST" "2025-12-01 03:28:10 CST"
> origin(v)
            V1             V2 
"command-line" "command-line" 
> names(v)
[1] "V1" "V2"
> 
> # set properties
> names(v)[1] <- "p1"
> 
> label(v)[1] <- "turnover positive"
> description(v)[1] <- "
+ According to the official definition,
+ only positive values can be considered
+ valid turnovers.
+ "
> 
> # short description is also printed:
> v
Object of class 'validator' with 2 elements:
 p1 [turnover positive]: turnover > 0
 V2                    : staff.costs > 0
> 
> # print all info for first rule
> v[[1]]

Object of class rule.
 expr       : turnover > 0 
 name       : p1 
 label      : turnover positive 
 description: 
According to the official definition,
only positive values can be considered
valid turnovers.
 
 origin     : command-line 
 created    : 2025-12-01 03:28:10
 meta       : language<chr>, severity<chr>> 
> 
> 
> 
> 
> cleanEx()
> nameEx("do_by")
> ### * do_by
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: do_by
> ### Title: split-apply-combine for vectors, with equal-length outptu
> ### Aliases: do_by sum_by mean_by min_by max_by
> 
> ### ** Examples
> 
> x <- 1:10
> y <- rep(letters[1:2], 5)
> do_by(x, by=y, fun=max)
 [1]  9 10  9 10  9 10  9 10  9 10
> do_by(x, by=y, fun=sum)
 [1] 25 30 25 30 25 30 25 30 25 30
> 
> 
> 
> 
> cleanEx()
> nameEx("errors")
> ### * errors
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: errors
> ### Title: Get messages from a confrontation object
> ### Aliases: errors errors,confrontation-method
> ###   warnings,confrontation-method
> 
> ### ** Examples
> 
> 
> # create an error, by using a non-existent variable name
> cf <- check_that(women, hite > 0, weight > 0)
> # retrieve error messages
> errors(cf)
$V1
[1] "object 'hite' not found"

> 
> 
> 
> 
> 
> cleanEx()
> nameEx("event")
> ### * event
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: event
> ### Title: Get or set event information metadata from a 'confrontation'
> ###   object.
> ### Aliases: event event<- event,confrontation-method
> ###   event<-,confrontation-method
> 
> ### ** Examples
> 
> data(retailers)
> rules <- validator(turnover >= 0, staff >=0)
> cf <- confront(retailers, rules)
> event(cf)
                                           agent 
"x86_64-pc-linux-gnu > R 4.6.0 > validate 1.1.6" 
                                            time 
                          "20251201T032810-0600" 
                                           actor 
                                     "tkalibera" 
                                         trigger 
                                              NA 
> 
> # adapt event information
> u <- event(cf)
> u["trigger"] <- "spontaneous validation"
> event(cf) <- u
> event(cf)
                                           agent 
"x86_64-pc-linux-gnu > R 4.6.0 > validate 1.1.6" 
                                            time 
                          "20251201T032810-0600" 
                                           actor 
                                     "tkalibera" 
                                         trigger 
                        "spontaneous validation" 
> 
> 
> 
> 
> cleanEx()
> nameEx("exists_any")
> ### * exists_any
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: exists_any
> ### Title: Test for (unique) existence
> ### Aliases: exists_any exists_one
> 
> ### ** Examples
> 
> # Test whether each household has exactly one 'head of household'
> 
> dd <- data.frame(
+    hhid   = c(1,  1,  2,  1,  2,  2,  3 )
+  , person = c(1,  2,  3,  4,  5,  6,  7 )
+  , hhrole = c("h","h","m","m","h","m","m")
+ )
> v <- validator(exists_one(hhrole=="h", hhid))
> values(confront(dd, v))
        V1
[1,] FALSE
[2,] FALSE
[3,]  TRUE
[4,] FALSE
[5,]  TRUE
[6,]  TRUE
[7,] FALSE
> 
> # same, but now with missing value in the data
> dd <- data.frame(
+     hhid   = c(1,  1,  2,  1,  2,  2,  3 )
+   , person = c(1,  2,  3,  4,  5,  6,  7 )
+   , hhrole = c("h",NA,"m","m","h","m","h")
+ )
> values(confront(dd, v))
       V1
[1,]   NA
[2,]   NA
[3,] TRUE
[4,]   NA
[5,] TRUE
[6,] TRUE
[7,] TRUE
> 
> # same, but now we ignore the missing values
> v <- validator(exists_one(hhrole=="h", hhid, na.rm=TRUE))
> values(confront(dd, v))
       V1
[1,] TRUE
[2,] TRUE
[3,] TRUE
[4,] TRUE
[5,] TRUE
[6,] TRUE
[7,] TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("export_yaml")
> ### * export_yaml
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: export_yaml
> ### Title: Export to yaml file
> ### Aliases: export_yaml as_yaml export_yaml,expressionset-method
> ###   as_yaml,expressionset-method
> 
> ### ** Examples
> 
> 
> v <- validator(x > 0, y > 0, x + y == z)
> txt <- as_yaml(v)
> cat(txt)
rules:
- expr: x > 0
  name: V1
  label: ''
  description: ''
  created: 2025-12-01 03:28:10.84189
  origin: command-line
  meta:
    language: validate 1.1.6
    severity: error
- expr: y > 0
  name: V2
  label: ''
  description: ''
  created: 2025-12-01 03:28:10.84189
  origin: command-line
  meta:
    language: validate 1.1.6
    severity: error
- expr: x + y == z
  name: V3
  label: ''
  description: ''
  created: 2025-12-01 03:28:10.84189
  origin: command-line
  meta:
    language: validate 1.1.6
    severity: error
> 
> 
> # NOTE: you can safely run the code below. It is enclosed in 'not run'
> # statements to prevent the code from being run at test-time on CRAN
> ## Not run: 
> ##D export_yaml(v, file="my_rules.txt")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("field_length")
> ### * field_length
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: field_length
> ### Title: Check number of code points
> ### Aliases: field_length
> 
> ### ** Examples
> 
> 
> df <- data.frame(id = 11001:11003, year = c("2018","2019","2020"), value = 1:3)
> rule <- validator(field_length(year, 4), field_length(id, 5))
> out <- confront(df, rule) 
> as.data.frame(out)
  name value            expression
1   V1  TRUE field_length(year, 4)
2   V1  TRUE field_length(year, 4)
3   V1  TRUE field_length(year, 4)
4   V2  TRUE   field_length(id, 5)
5   V2  TRUE   field_length(id, 5)
6   V2  TRUE   field_length(id, 5)
> 
> 
> 
> 
> cleanEx()
> nameEx("hb")
> ### * hb
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hb
> ### Title: Hiridoglu-Berthelot function
> ### Aliases: hb
> 
> ### ** Examples
> 
> x <- seq(1,20,by=0.1)
> plot(x,hb(x), 'l')
> 
> 
> 
> 
> cleanEx()
> nameEx("hierarchy")
> ### * hierarchy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hierarchy
> ### Title: Check aggregates defined by a hierarchical code list
> ### Aliases: hierarchy
> 
> ### ** Examples
> 
> # We check some data against the built-in NACE revision 2 classification.
> data(nace_rev2)
> head(nace_rev2[1:4]) # columns 3 and 4 contain the child-parent relations.
   Order Level  Code Parent
1 398481     1     A       
2 398482     2    01      A
3 398483     3  01.1     01
4 398484     4 01.11   01.1
5 398485     4 01.12   01.1
6 398486     4 01.13   01.1
> 
> d <- data.frame(
+      nace   = c("01","01.1","01.11","01.12", "01.2")
+    , volume = c(100 ,70    , 30    ,40     , 25    )
+ )
> # It is possible to perform checks interactively
> d$nacecheck <- hierarchy(d$volume, labels = d$nace, hierarchy=nace_rev2[3:4])
> # we have that "01.1" == "01.11" + "01.12", but not "01" == "01.1" +  "01.2"
> print(d)
   nace volume nacecheck
1    01    100     FALSE
2  01.1     70     FALSE
3 01.11     30      TRUE
4 01.12     40      TRUE
5  01.2     25     FALSE
> 
> # Usage as a valiation rule is as follows
> rules <- validator(hierarchy(volume, labels = nace, hierarchy=validate::nace_rev_2[3:4]))
> confront(d, rules)
Object of class 'validation'
Call:
    confront(dat = d, x = rules)

Rules confronted: 1
   With fails   : 0
   With missings: 0
   Threw warning: 0
   Threw error  : 1
> 
> # you can also pass a hierarchy as a reference, for example.
> 
> rules <- validator(hierarchy(volume, labels = nace, hierarchy=ref$nacecodes))
> out <- confront(d, rules, ref=list(nacecodes=nace_rev2[3:4]))
> summary(out)
  name items passes fails nNA error warning
1   V1     5      2     3   0 FALSE   FALSE
                                                        expression
1 hierarchy(volume, labels = nace, hierarchy = ref[["nacecodes"]])
> 
> # set a output to NA when a code does not occur in the code list.
> d <- data.frame(
+      nace   = c("01","01.1","01.11","01.12", "01.2", "foo")
+    , volume = c(100 ,70    , 30    ,40     , 25     , 60)
+ )
> 
> d$nacecheck <- hierarchy(d$volume, labels = d$nace, hierarchy=nace_rev2[3:4]
+                          , na_value = NA)
> # we have that "01.1" == "01.11" + "01.12", but not "01" == "01.1" +  "01.2"
> print(d)
   nace volume nacecheck
1    01    100     FALSE
2  01.1     70     FALSE
3 01.11     30      TRUE
4 01.12     40      TRUE
5  01.2     25     FALSE
6   foo     60        NA
> 
> 
> 
> 
> cleanEx()
> nameEx("in_range")
> ### * in_range
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: in_range
> ### Title: Check variable range
> ### Aliases: in_range in_range.default in_range.character
> 
> ### ** Examples
> 
> 
> d <- data.frame(
+    number = c(3,-2,6)
+  , time   = as.Date(c("2018-02-01", "2018-03-01", "2018-04-01"))
+  , period = c("2020Q1", "2021Q2", "2020Q3") 
+ )
> 
> rules <- validator(
+    in_range(number, min=-2, max=7, strict=TRUE)
+  , in_range(time,   min=as.Date("2017-01-01"), max=as.Date("2018-12-31"))
+  , in_range(period, min="2020Q1", max="2020Q4")
+ )
> 
> result <- confront(d, rules)
> values(result)
        V1   V2    V3
[1,]  TRUE TRUE  TRUE
[2,] FALSE TRUE FALSE
[3,]  TRUE TRUE  TRUE
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("indicator")
> ### * indicator
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: indicator
> ### Title: Define indicators for data
> ### Aliases: indicator
> ### Keywords: internal
> 
> ### ** Examples
> 
> # create an indicator for the number of missing x in data set
> 
> 
> I <- indicator( 
+  sum(is.na(.))               # number of missing variables
+  , sum(is.na(.[c("x","y")])) # number of missing x and y
+  , mean(is.na(.))            # fraction of missing variables
+  , sum(x)
+  , mean(x)
+ ) 
> 
> dat <- data.frame(x=1:2, y=c(NA,1))
> C <- confront(dat, I)
> values(C)
     I1 I2   I3 I4  I5
[1,]  1  1 0.25  3 1.5
> 
> 
> 
> cleanEx()
> nameEx("is_complete")
> ### * is_complete
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is_complete
> ### Title: Test for completeness of records
> ### Aliases: is_complete all_complete
> 
> ### ** Examples
> 
> d <- data.frame(X = c('a','b',NA,'b'), Y = c(NA,'apple','banana','apple'), Z=1:4)
> v <- validator(is_complete(X, Y))
> values(confront(d, v))
        V1
[1,] FALSE
[2,]  TRUE
[3,] FALSE
[4,]  TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("is_linear_sequence")
> ### * is_linear_sequence
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is_linear_sequence
> ### Title: Check whether a variable represents a linear sequence
> ### Aliases: is_linear_sequence is_linear_sequence.numeric
> ###   is_linear_sequence.Date is_linear_sequence.POSIXct
> ###   is_linear_sequence.character in_linear_sequence
> ###   in_linear_sequence.character in_linear_sequence.numeric
> ###   in_linear_sequence.Date in_linear_sequence.POSIXct
> 
> ### ** Examples
> 
> 
> is_linear_sequence(1:5) # TRUE
[1] TRUE
> is_linear_sequence(c(1,3,5,4,2)) # FALSE
[1] TRUE
> is_linear_sequence(c(1,3,5,4,2), sort=TRUE) # TRUE 
[1] TRUE
> is_linear_sequence(NA_integer_) # TRUE
[1] TRUE
> is_linear_sequence(NA_integer_, begin=4) # FALSE
[1] FALSE
> is_linear_sequence(c(1, NA, 3)) # FALSE
[1] NA
> 
> 
> d <- data.frame(
+     number = c(pi, exp(1), 7)
+   , date = as.Date(c("2015-12-17","2015-12-19","2015-12-21"))
+   , time = as.POSIXct(c("2015-12-17","2015-12-19","2015-12-20"))
+ )
> 
> rules <- validator(
+     is_linear_sequence(number)  # fails
+   , is_linear_sequence(date)    # passes
+   , is_linear_sequence(time)    # fails
+ )
> summary(confront(d,rules))
  name items passes fails nNA error warning                 expression
1   V1     1      0     1   0 FALSE   FALSE is_linear_sequence(number)
2   V2     1      1     0   0 FALSE   FALSE   is_linear_sequence(date)
3   V3     1      0     1   0 FALSE   FALSE   is_linear_sequence(time)
> 
> ## check groupwise data
> dat <- data.frame(
+    time = c(2012, 2013, 2012, 2013, 2015)
+  , type = c("hi", "hi", "ha", "ha", "ha")
+ )
> rule <- validator(in_linear_sequence(time, by=type))
> values(confront(dat, rule)) ## 2xT, 3xF
        V1
[1,]  TRUE
[2,]  TRUE
[3,] FALSE
[4,] FALSE
[5,] FALSE
> 
> 
> rule <- validator(in_linear_sequence(time, type))
> values( confront(dat, rule) )
        V1
[1,]  TRUE
[2,]  TRUE
[3,] FALSE
[4,] FALSE
[5,] FALSE
> 
> 
> 
> 
> cleanEx()
> nameEx("is_unique")
> ### * is_unique
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is_unique
> ### Title: Test for uniquenes of records
> ### Aliases: is_unique all_unique n_unique
> 
> ### ** Examples
> 
> 
> d <- data.frame(X = c('a','b','c','b'), Y = c('banana','apple','banana','apple'), Z=1:4)
> v <- validator(is_unique(X, Y))
> values(confront(d, v))
        V1
[1,]  TRUE
[2,] FALSE
[3,]  TRUE
[4,] FALSE
> 
> # example with groupwise test
> df <- data.frame(x=c(rep("a",3), rep("b",3)),y=c(1,1,2,1:3))
> v <- validator(is_unique(y, by=x))
> values(confront(d,v))
list()
> 
> 
> 
> 
> cleanEx()
> nameEx("label")
> ### * label
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: label
> ### Title: Rule label
> ### Aliases: label label<- label,rule-method label<-,rule,character-method
> ###   label,expressionset-method label<-,expressionset,character-method
> 
> ### ** Examples
> 
> 
> # retrieve properties
> v <- validator(turnover > 0, staff.costs>0)
> 
> # number of rules in v:
> length(v)
[1] 2
> 
> # per-rule
> created(v)
[1] "2025-12-01 03:28:11 CST" "2025-12-01 03:28:11 CST"
> origin(v)
            V1             V2 
"command-line" "command-line" 
> names(v)
[1] "V1" "V2"
> 
> # set properties
> names(v)[1] <- "p1"
> 
> label(v)[1] <- "turnover positive"
> description(v)[1] <- "
+ According to the official definition,
+ only positive values can be considered
+ valid turnovers.
+ "
> 
> # short description is also printed:
> v
Object of class 'validator' with 2 elements:
 p1 [turnover positive]: turnover > 0
 V2                    : staff.costs > 0
> 
> # print all info for first rule
> v[[1]]

Object of class rule.
 expr       : turnover > 0 
 name       : p1 
 label      : turnover positive 
 description: 
According to the official definition,
only positive values can be considered
valid turnovers.
 
 origin     : command-line 
 created    : 2025-12-01 03:28:11
 meta       : language<chr>, severity<chr>> 
> 
> 
> # retrieve properties
> v <- validator(turnover > 0, staff.costs>0)
> 
> # number of rules in v:
> length(v)
[1] 2
> 
> # per-rule
> created(v)
[1] "2025-12-01 03:28:11 CST" "2025-12-01 03:28:11 CST"
> origin(v)
            V1             V2 
"command-line" "command-line" 
> names(v)
[1] "V1" "V2"
> 
> # set properties
> names(v)[1] <- "p1"
> 
> label(v)[1] <- "turnover positive"
> description(v)[1] <- "
+ According to the official definition,
+ only positive values can be considered
+ valid turnovers.
+ "
> 
> # short description is also printed:
> v
Object of class 'validator' with 2 elements:
 p1 [turnover positive]: turnover > 0
 V2                    : staff.costs > 0
> 
> # print all info for first rule
> v[[1]]

Object of class rule.
 expr       : turnover > 0 
 name       : p1 
 label      : turnover positive 
 description: 
According to the official definition,
only positive values can be considered
valid turnovers.
 
 origin     : command-line 
 created    : 2025-12-01 03:28:11
 meta       : language<chr>, severity<chr>> 
> 
> 
> 
> 
> cleanEx()
> nameEx("meta")
> ### * meta
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: meta
> ### Title: Get or set rule metadata
> ### Aliases: meta meta<- meta,rule-method meta<-,rule,character-method
> ###   meta,expressionset-method meta<-,expressionset,character-method
> 
> ### ** Examples
> 
> 
> v <- validator(x > 0, y > 0)
> 
> # metadata is recycled over rules
> meta(v,"foo") <- "bar" 
> 
> # assign metadata to a selection of rules
> meta(v[1],"fu") <- 2
> 
> # retrieve metadata as data.frame
> meta(v)
  name label description       origin             created       language
1   V1                   command-line 2025-12-01 03:28:11 validate 1.1.6
2   V2                   command-line 2025-12-01 03:28:11 validate 1.1.6
  severity foo fu
1    error bar  2
2    error bar NA
> 
> # retrieve metadata as list
> meta(v,simplify=TRUE)
  name label description       origin             created       language
1   V1                   command-line 2025-12-01 03:28:11 validate 1.1.6
2   V2                   command-line 2025-12-01 03:28:11 validate 1.1.6
  severity foo fu
1    error bar  2
2    error bar NA
> 
> 
> 
> 
> cleanEx()
> nameEx("names")
> ### * names
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: names<-,rule,character-method
> ### Title: Extract or set names
> ### Aliases: names<-,rule,character-method names,expressionset-method
> ###   names<-,expressionset,character-method names,confrontation-method
> 
> ### ** Examples
> 
> 
> # retrieve properties
> v <- validator(turnover > 0, staff.costs>0)
> 
> # number of rules in v:
> length(v)
[1] 2
> 
> # per-rule
> created(v)
[1] "2025-12-01 03:28:11 CST" "2025-12-01 03:28:11 CST"
> origin(v)
            V1             V2 
"command-line" "command-line" 
> names(v)
[1] "V1" "V2"
> 
> # set properties
> names(v)[1] <- "p1"
> 
> label(v)[1] <- "turnover positive"
> description(v)[1] <- "
+ According to the official definition,
+ only positive values can be considered
+ valid turnovers.
+ "
> 
> # short description is also printed:
> v
Object of class 'validator' with 2 elements:
 p1 [turnover positive]: turnover > 0
 V2                    : staff.costs > 0
> 
> # print all info for first rule
> v[[1]]

Object of class rule.
 expr       : turnover > 0 
 name       : p1 
 label      : turnover positive 
 description: 
According to the official definition,
only positive values can be considered
valid turnovers.
 
 origin     : command-line 
 created    : 2025-12-01 03:28:11
 meta       : language<chr>, severity<chr>> 
> 
> 
> # retrieve properties
> v <- validator(turnover > 0, staff.costs>0)
> 
> # number of rules in v:
> length(v)
[1] 2
> 
> # per-rule
> created(v)
[1] "2025-12-01 03:28:11 CST" "2025-12-01 03:28:11 CST"
> origin(v)
            V1             V2 
"command-line" "command-line" 
> names(v)
[1] "V1" "V2"
> 
> # set properties
> names(v)[1] <- "p1"
> 
> label(v)[1] <- "turnover positive"
> description(v)[1] <- "
+ According to the official definition,
+ only positive values can be considered
+ valid turnovers.
+ "
> 
> # short description is also printed:
> v
Object of class 'validator' with 2 elements:
 p1 [turnover positive]: turnover > 0
 V2                    : staff.costs > 0
> 
> # print all info for first rule
> v[[1]]

Object of class rule.
 expr       : turnover > 0 
 name       : p1 
 label      : turnover positive 
 description: 
According to the official definition,
only positive values can be considered
valid turnovers.
 
 origin     : command-line 
 created    : 2025-12-01 03:28:11
 meta       : language<chr>, severity<chr>> 
> 
> 
> 
> 
> cleanEx()
> nameEx("number_format")
> ### * number_format
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: number_format
> ### Title: Check the layouts of numbers.
> ### Aliases: number_format
> 
> ### ** Examples
> 
> df <- data.frame(number = c("12.34","0.23E55","0.98765E12"))
> rules <- validator(
+    number_format(number, format="dd.dd")
+    , number_format(number, "0.ddEdd")
+    , number_format(number, "0.*Edd")
+ )
> 
> out <- confront(df, rules)
> values(out)
        V1    V2    V3
[1,]  TRUE FALSE FALSE
[2,] FALSE  TRUE  TRUE
[3,] FALSE FALSE  TRUE
> 
> # a few examples, without 'validator'
> number_format("12.345", min_dig=2) # TRUE
[1] TRUE
> number_format("12.345", min_dig=4) # FALSE
[1] FALSE
> number_format("12.345", max_dig=2) # FALSE
[1] FALSE
> number_format("12.345", max_dig=5) # TRUE
[1] TRUE
> number_format("12,345", min_dig=2, max_dig=3, dec=",") # TRUE
[1] TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("origin")
> ### * origin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: origin
> ### Title: Origin of rules
> ### Aliases: origin origin<- origin,rule-method
> ###   origin<-,rule,character-method origin,expressionset-method
> ###   origin<-,expressionset,character-method
> 
> ### ** Examples
> 
> 
> # retrieve properties
> v <- validator(turnover > 0, staff.costs>0)
> 
> # number of rules in v:
> length(v)
[1] 2
> 
> # per-rule
> created(v)
[1] "2025-12-01 03:28:11 CST" "2025-12-01 03:28:11 CST"
> origin(v)
            V1             V2 
"command-line" "command-line" 
> names(v)
[1] "V1" "V2"
> 
> # set properties
> names(v)[1] <- "p1"
> 
> label(v)[1] <- "turnover positive"
> description(v)[1] <- "
+ According to the official definition,
+ only positive values can be considered
+ valid turnovers.
+ "
> 
> # short description is also printed:
> v
Object of class 'validator' with 2 elements:
 p1 [turnover positive]: turnover > 0
 V2                    : staff.costs > 0
> 
> # print all info for first rule
> v[[1]]

Object of class rule.
 expr       : turnover > 0 
 name       : p1 
 label      : turnover positive 
 description: 
According to the official definition,
only positive values can be considered
valid turnovers.
 
 origin     : command-line 
 created    : 2025-12-01 03:28:11
 meta       : language<chr>, severity<chr>> 
> 
> 
> # retrieve properties
> v <- validator(turnover > 0, staff.costs>0)
> 
> # number of rules in v:
> length(v)
[1] 2
> 
> # per-rule
> created(v)
[1] "2025-12-01 03:28:11 CST" "2025-12-01 03:28:11 CST"
> origin(v)
            V1             V2 
"command-line" "command-line" 
> names(v)
[1] "V1" "V2"
> 
> # set properties
> names(v)[1] <- "p1"
> 
> label(v)[1] <- "turnover positive"
> description(v)[1] <- "
+ According to the official definition,
+ only positive values can be considered
+ valid turnovers.
+ "
> 
> # short description is also printed:
> v
Object of class 'validator' with 2 elements:
 p1 [turnover positive]: turnover > 0
 V2                    : staff.costs > 0
> 
> # print all info for first rule
> v[[1]]

Object of class rule.
 expr       : turnover > 0 
 name       : p1 
 label      : turnover positive 
 description: 
According to the official definition,
only positive values can be considered
valid turnovers.
 
 origin     : command-line 
 created    : 2025-12-01 03:28:11
 meta       : language<chr>, severity<chr>> 
> 
> 
> 
> 
> cleanEx()
> nameEx("part_whole_relation")
> ### * part_whole_relation
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: part_whole_relation
> ### Title: Test whether details combine to a chosen aggregate
> ### Aliases: part_whole_relation
> 
> ### ** Examples
> 
> df <- data.frame(
+    id = 10011:10020
+  , period   = rep(c("2018Q1", "2018Q2", "2018Q3", "2018Q4","2018"),2)
+  , direction = c(rep("import",5), rep("export", 5))
+  , value     = c(1,2,3,4,10, 3,3,3,3,13)
+ )
> ## use 'rx' to interpret 'whole' as a regular expression.
> rules <- validator(
+   part_whole_relation(value, period, whole=rx("^\\d{4}$")
+   , by=direction)
+ )
> 
> out <- confront(df, rules, key="id")
> as.data.frame(out)
      id name value
1  10011   V1  TRUE
2  10012   V1  TRUE
3  10013   V1  TRUE
4  10014   V1  TRUE
5  10015   V1  TRUE
6  10016   V1 FALSE
7  10017   V1 FALSE
8  10018   V1 FALSE
9  10019   V1 FALSE
10 10020   V1 FALSE
                                                                     expression
1  part_whole_relation(value, period, whole = rx("^\\\\d{4}$"), by = direction)
2  part_whole_relation(value, period, whole = rx("^\\\\d{4}$"), by = direction)
3  part_whole_relation(value, period, whole = rx("^\\\\d{4}$"), by = direction)
4  part_whole_relation(value, period, whole = rx("^\\\\d{4}$"), by = direction)
5  part_whole_relation(value, period, whole = rx("^\\\\d{4}$"), by = direction)
6  part_whole_relation(value, period, whole = rx("^\\\\d{4}$"), by = direction)
7  part_whole_relation(value, period, whole = rx("^\\\\d{4}$"), by = direction)
8  part_whole_relation(value, period, whole = rx("^\\\\d{4}$"), by = direction)
9  part_whole_relation(value, period, whole = rx("^\\\\d{4}$"), by = direction)
10 part_whole_relation(value, period, whole = rx("^\\\\d{4}$"), by = direction)
> 
> 
> 
> cleanEx()
> nameEx("plot-validation-method")
> ### * plot-validation-method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot,validation-method
> ### Title: Plot validation results
> ### Aliases: plot,validation-method
> 
> ### ** Examples
> 
> rules <- validator( r1 = staff.costs < total.costs
+                   , r2 = turnover + other.rev == total.rev
+                   , r3 = other.rev > 0
+                   , r4 = total.rev > 0
+                   , r5 = nace %in% c("A", "B")
+                   )
> plot(rules, cex=0.8, show_legend=TRUE)
> 
> data(retailers)
> cf <- confront(retailers, rules)
> plot(cf, main="Retailers check")
Rules r5 not included in plot since they could not be executed. See ?errors
> 
> 
> 
> cleanEx()
> nameEx("plot-validator-method")
> ### * plot-validator-method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot,validator-method
> ### Title: Plot a validator object
> ### Aliases: plot,validator-method
> 
> ### ** Examples
> 
> rules <- validator( r1 = staff.costs < total.costs
+                   , r2 = turnover + other.rev == total.rev
+                   , r3 = other.rev > 0
+                   , r4 = total.rev > 0
+                   , r5 = nace %in% c("A", "B")
+                   )
> plot(rules, cex=0.8, show_legend=TRUE)
> 
> data(retailers)
> cf <- confront(retailers, rules)
> plot(cf, main="Retailers check")
Rules r5 not included in plot since they could not be executed. See ?errors
> 
> 
> 
> cleanEx()
> nameEx("plus-indicator-indicator-method")
> ### * plus-indicator-indicator-method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: +,indicator,indicator-method
> ### Title: Combine two indicator objects
> ### Aliases: +,indicator,indicator-method
> 
> ### ** Examples
> 
> indicator(mean(x)) + indicator(x/median(x))
Object of class 'indicator' with 2 elements:
 I1  : mean(x)
 I1.1: x/median(x)
> 
> 
> 
> cleanEx()
> nameEx("plus-validator-validator-method")
> ### * plus-validator-validator-method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: +,validator,validator-method
> ### Title: Combine two validator objects
> ### Aliases: +,validator,validator-method
> 
> ### ** Examples
> 
> validator(x>0) + validator(x<=1)
Object of class 'validator' with 2 elements:
 V1  : x > 0
 V1.1: x <= 1
> 
> 
> 
> cleanEx()
> nameEx("satisfying")
> ### * satisfying
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: satisfying
> ### Title: Select records (not) satisfying rules
> ### Aliases: satisfying violating violating.default lacking
> 
> ### ** Examples
> 
> rules <- validator(speed >= 12, dist < 100)
> satisfying(cars, rules)
   speed dist
12    12   14
13    12   20
14    12   24
15    12   28
16    13   26
17    13   34
18    13   34
19    13   46
20    14   26
21    14   36
22    14   60
23    14   80
24    15   20
25    15   26
26    15   54
27    16   32
28    16   40
29    17   32
30    17   40
31    17   50
32    18   42
33    18   56
34    18   76
35    18   84
36    19   36
37    19   46
38    19   68
39    20   32
40    20   48
41    20   52
42    20   56
43    20   64
44    22   66
45    23   54
46    24   70
47    24   92
48    24   93
50    25   85
> violating(cars, rules)
   speed dist
1      4    2
2      4   10
3      7    4
4      7   22
5      8   16
6      9   10
7     10   18
8     10   26
9     10   34
10    11   17
11    11   28
49    24  120
> 
> out <- confront(cars, rules)
> summary(out)
  name items passes fails nNA error warning           expression
1   V1    50     39    11   0 FALSE   FALSE speed - 12 >= -1e-08
2   V2    50     49     1   0 FALSE   FALSE           dist < 100
> satisfying(cars, out)
   speed dist
12    12   14
13    12   20
14    12   24
15    12   28
16    13   26
17    13   34
18    13   34
19    13   46
20    14   26
21    14   36
22    14   60
23    14   80
24    15   20
25    15   26
26    15   54
27    16   32
28    16   40
29    17   32
30    17   40
31    17   50
32    18   42
33    18   56
34    18   76
35    18   84
36    19   36
37    19   46
38    19   68
39    20   32
40    20   48
41    20   52
42    20   56
43    20   64
44    22   66
45    23   54
46    24   70
47    24   92
48    24   93
50    25   85
> violating(cars, out)
   speed dist
1      4    2
2      4   10
3      7    4
4      7   22
5      8   16
6      9   10
7     10   18
8     10   26
9     10   34
10    11   17
11    11   28
49    24  120
> 
> 
> 
> 
> cleanEx()
> nameEx("sdmx_codelist")
> ### * sdmx_codelist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sdmx_codelist
> ### Title: Get code list from an SDMX REST API endpoint.
> ### Aliases: sdmx_codelist estat_codelist global_codelist
> 
> ### ** Examples
> 
>  
> 
>  # here we download the CL_ACTIVITY codelist from the  ESTAT registry.
> ## Not run: 
> ##D  codelist <- sdmx_codelist(
> ##D    endpoint = "https://registry.sdmx.org/ws/public/sdmxapi/rest/"
> ##D    , agency_id = "ESTAT"
> ##D    , resource_id = "CL_ACTIVITY" 
> ## End(Not run)
> 
> ## Not run: 
> ##D   estat_codelist("CL_ACTIVITY")
> ## End(Not run)
> ## Not run: 
> ##D   global_codelist("CL_AGE") )
> ##D   global_codelist("CL_CONF_STATUS")
> ##D   global_codelist("CL_SEX")
> ## End(Not run)
> # An example of using SDMX information, downloaded from the SDMX global
> # registry
> ## Not run: 
> ##D  # economic data from the country of Samplonia
> ##D  data(samplonomy)
> ##D  head(samplonomy)
> ##D 
> ##D  rules <- validator(
> ##D    , freq %in% global_codelist("CL_FREQ")
> ##D    , value >= 0
> ##D  )
> ##D  cf <- confront(samplonomy, rules) 
> ##D  summary(cf)
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("sdmx_endpoint")
> ### * sdmx_endpoint
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sdmx_endpoint
> ### Title: Get URL for known SDMX registry endpoints
> ### Aliases: sdmx_endpoint
> 
> ### ** Examples
> 
> sdmx_endpoint()
                                                 ESTAT 
"https://webgate.ec.europa.eu/fusionregistry/sdmx/v2/" 
                                                GLOBAL 
    "https://registry.sdmx.org/ws/public/sdmxapi/rest" 
> sdmx_endpoint("ESTAT")
                                                 ESTAT 
"https://webgate.ec.europa.eu/fusionregistry/sdmx/v2/" 
> sdmx_endpoint("global")
                                            GLOBAL 
"https://registry.sdmx.org/ws/public/sdmxapi/rest" 
> 
> 
> 
> 
> cleanEx()
> nameEx("sort-validation-method")
> ### * sort-validation-method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sort,validation-method
> ### Title: Aggregate and sort the results of a validation.
> ### Aliases: sort,validation-method
> 
> ### ** Examples
> 
> 
> data(retailers)
> retailers$id <- paste0("ret",1:nrow(retailers))
> v <- validator(
+     staff.costs/staff < 25
+   , turnover + other.rev==total.rev)
> 
> cf <- confront(retailers,v,key="id")
> a <- aggregate(cf,by='record')
> head(a)
    id npass nfail nNA rel.pass rel.fail rel.NA
1 ret1     0     0   2      0.0      0.0    1.0
2 ret2     1     0   1      0.5      0.0    0.5
3 ret3     0     1   1      0.0      0.5    0.5
4 ret4     1     0   1      0.5      0.0    0.5
5 ret5     0     0   2      0.0      0.0    1.0
6 ret6     0     0   2      0.0      0.0    1.0
> 
> # or, get a sorted result:
> s <- sort(cf, by='record')
> head(s)
      id npass nfail nNA rel.pass rel.fail rel.NA
1   ret1     0     0   2        0      0.0    1.0
3   ret3     0     1   1        0      0.5    0.5
5   ret5     0     0   2        0      0.0    1.0
6   ret6     0     0   2        0      0.0    1.0
7   ret7     0     1   1        0      0.5    0.5
10 ret10     0     0   2        0      0.0    1.0
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("validate-summary")
> ### * validate-summary
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary
> ### Title: Create a summary
> ### Aliases: summary summary,expressionset-method summary,indication-method
> ###   validate-summary summary,validation-method
> 
> ### ** Examples
> 
> data(retailers)
> v <- validator(staff > 0, staff.costs/staff < 20, turnover+other.revenue == total.revenue)
> summary(v)
  block nvar rules linear
1     1    2     2      1
2     2    3     1      1
> 
> cf <- confront(retailers,v)
> summary(cf)
  name items passes fails nNA error warning
1   V1    60     54     0   6 FALSE   FALSE
2   V2    60     25    19  16 FALSE   FALSE
3   V3     0      0     0   0  TRUE   FALSE
                                              expression
1                                              staff > 0
2                                 staff.costs/staff < 20
3 abs(turnover + other.revenue - total.revenue) <= 1e-08
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("validator")
> ### * validator
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: validator
> ### Title: Define validation rules for data
> ### Aliases: validator
> 
> ### ** Examples
> 
> 
> v <- validator(
+   height>0
+   ,weight>0
+   ,height < 1.5*mean(height)
+ )
> cf <- confront(women, v)
> summary(cf)
  name items passes fails nNA error warning                  expression
1   V1    15     15     0   0 FALSE   FALSE                  height > 0
2   V2    15     15     0   0 FALSE   FALSE                  weight > 0
3   V3    15     15     0   0 FALSE   FALSE height < 1.5 * mean(height)
> 
> 
> 
> 
> cleanEx()
> nameEx("variables")
> ### * variables
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: variables
> ### Title: Get variable names
> ### Aliases: variables variables,rule-method variables,list-method
> ###   variables,data.frame-method variables,environment-method
> ###   variables,expressionset-method
> 
> ### ** Examples
> 
> 
> v <- validator(
+   root = y := sqrt(x)
+  , average = mean(x) > 3
+  , sum = x + y == z
+ )
> variables(v)
[1] "x" "z"
> variables(v,dummy=TRUE)
[1] "y" "x" "z"
> variables(v,matrix=TRUE)
[1] "x" "z"
> variables(v,matrix=TRUE,dummy=TRUE)
[1] "y" "x" "z"
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("vin")
> ### * vin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: %vin%
> ### Title: A consistent set membership operator
> ### Aliases: %vin%
> 
> ### ** Examples
> 
> # we cannot be sure about the first element:
> c(NA, "a") %vin% c("a","b")
[1]   NA TRUE
> 
> # we cannot be sure about the 2nd and 3rd element (but note that they
> # cannot both be TRUE):
> c("a","b","c") %vin% c("a",NA)
[1] TRUE   NA   NA
> 
> # we can be sure about all elements:
> c("a","b") %in% character(0)
[1] FALSE FALSE
> 
> 
> 
> 
> cleanEx()
> nameEx("voptions")
> ### * voptions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: voptions
> ### Title: Set or get options globally or per object.
> ### Aliases: voptions voptions,ANY-method validate_options reset
> ###   reset,ANY-method voptions,expressionset-method
> ###   reset,expressionset-method
> 
> ### ** Examples
> 
> 
> # set an option, local to a validator object:
> v <- validator(x + y > z)
> voptions(v,raise='all')
> # check that local option was set:
> voptions(v,'raise')
[1] "all"
> # check that global options have not changed:
> voptions('raise')
[1] "none"
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  3.299 0.116 3.562 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
