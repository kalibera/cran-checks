
R Under development (unstable) (2023-05-06 r84401) -- "Unsuffered Consequences"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "reproducible"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('reproducible')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("Cache")
> ### * Cache
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Cache
> ### Title: Saves a wide variety function call outputs to disk and
> ###   optionally RAM, for recovery later
> ### Aliases: Cache
> 
> ### ** Examples
> 
> data.table::setDTthreads(2)
> tmpDir <- file.path(tempdir())
> opts <- options(reproducible.cachePath = tmpDir)
> 
> # Usage -- All below are equivalent; even where args are missing or provided,
> #   Cache evaluates using default values, if these are specified in formals(FUN)
> a <- list()
> b <- list(fun = rnorm)
> bbb <- 1
> ee <- new.env(parent = emptyenv())
> ee$qq <- bbb
> 
> a[[1]] <- Cache(rnorm(1)) # no evaluation prior to Cache
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
> a[[2]] <- Cache(rnorm, 1) # no evaluation prior to Cache
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (422bae4ed2f770cc.rds))
     loaded cached result from previous rnorm call
> a[[3]] <- Cache(do.call, rnorm, list(1))
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (422bae4ed2f770cc.rds))
     loaded cached result from previous rnorm call
> a[[4]] <- Cache(do.call(rnorm, list(1)))
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (422bae4ed2f770cc.rds))
     loaded cached result from previous rnorm call
> a[[5]] <- Cache(do.call(b$fun, list(1)))
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (422bae4ed2f770cc.rds))
     loaded cached result from previous b$fun call
> a[[6]] <- Cache(do.call, b$fun, list(1))
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (422bae4ed2f770cc.rds))
     loaded cached result from previous b$fun call
> a[[7]] <- Cache(b$fun, 1)
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (422bae4ed2f770cc.rds))
     loaded cached result from previous b$fun call
> a[[8]] <- Cache(b$fun(1))
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (422bae4ed2f770cc.rds))
     loaded cached result from previous $ call
> a[[10]] <- Cache(quote(rnorm(1)))
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (422bae4ed2f770cc.rds))
     loaded cached result from previous quote call
> a[[11]] <- Cache(stats::rnorm(1))
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (422bae4ed2f770cc.rds))
     loaded cached result from previous stats::rnorm call
> a[[12]] <- Cache(stats::rnorm, 1)
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (422bae4ed2f770cc.rds))
     loaded cached result from previous stats::rnorm call
> a[[13]] <- Cache(rnorm(1, 0, get("bbb", inherits = FALSE)))
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (422bae4ed2f770cc.rds))
     loaded cached result from previous rnorm call
> a[[14]] <- Cache(rnorm(1, 0, get("qq", inherits = FALSE, envir = ee)))
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (422bae4ed2f770cc.rds))
     loaded cached result from previous rnorm call
> a[[15]] <- Cache(rnorm(1, bbb - bbb, get("bbb", inherits = FALSE)))
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (422bae4ed2f770cc.rds))
     loaded cached result from previous rnorm call
> a[[16]] <- Cache(rnorm(sd = 1, 0, n = get("bbb", inherits = FALSE))) # change order
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (422bae4ed2f770cc.rds))
     loaded cached result from previous rnorm call
> a[[17]] <- Cache(rnorm(1, sd = get("ee", inherits = FALSE)$qq), mean = 0)
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (422bae4ed2f770cc.rds))
     loaded cached result from previous rnorm call
> 
> # with base pipe -- this is put in quotes ('') because R version 4.0 can't understand this
> #  if you are using R >= 4.1 or R >= 4.2 if using the _ placeholder,
> #  then you can just use pipe normally
> usingPipe1 <- 'b$fun(1) |> Cache()'  # base pipe
> 
> # For long pipe, need to wrap sequence in { }, or else only last step is cached
> usingPipe2 <-
+   '{"bbb" |>
+       parse(text = _) |>
+       eval() |>
+       rnorm()} |>
+     Cache()'
> if (getRversion() >= 4.1) {
+   a[[9]] <- eval(parse(text = usingPipe1)) # recovers cached copy
+ }
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (422bae4ed2f770cc.rds))
     loaded cached result from previous $ call
> if (getRversion() >= 4.2) { # uses the _ placeholder; only available in R >= 4.2
+   a[[18]] <- eval(parse(text = usingPipe2)) # recovers cached copy
+ }
There is an `eval` call in a chain of calls for Cache; 
  eval is evaluated before Cache which may be undesired. 
  Perhaps use `do.call` if the evaluation should not occur prior to Cache
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (422bae4ed2f770cc.rds))
     loaded cached result from previous rnorm call
> 
> length(unique(a)) == 1 #  all same
[1] FALSE
> 
> ### Pipe -- have to use { } or else only final function is Cached
> if (getRversion() >= 4.1) {
+   b1a <- 'sample(1e5, 1) |> rnorm() |> Cache()'
+   b1b <- 'sample(1e5, 1) |> rnorm() |> Cache()'
+   b2a <- '{sample(1e5, 1) |> rnorm()} |> Cache()'
+   b2b <- '{sample(1e5, 1) |> rnorm()} |> Cache()'
+   b1a <- eval(parse(text = b1a))
+   b1b <- eval(parse(text = b1b))
+   b2a <- eval(parse(text = b2a))
+   b2b <- eval(parse(text = b2b))
+   all.equal(b1a, b1b) # Not TRUE because the sample is run first
+   all.equal(b2a, b2b) # TRUE because of {  }
+ }
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (65d6fc4cf6012274.rds))
     loaded cached result from previous rnorm call
[1] "Attributes: < Component “.Cache”: Component “newCache”: 1 element mismatch >"
> 
> #########################
> # Advanced examples
> #########################
> 
> # .cacheExtra -- add something to digest
> Cache(rnorm(1), .cacheExtra = "sfessee11") # adds something other than fn args
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
[1] -0.8004696
attr(,".Cache")
attr(,".Cache")$newCache
[1] TRUE

attr(,"tags")
[1] "cacheId:15a06cafd7e0d37e"
attr(,"call")
[1] ""
> Cache(rnorm(1), .cacheExtra = "nothing") # even though fn is same, the extra is different
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
[1] -0.7303742
attr(,".Cache")
attr(,".Cache")$newCache
[1] TRUE

attr(,"tags")
[1] "cacheId:b35d37e57ba86333"
attr(,"call")
[1] ""
> 
> # omitArgs -- remove something from digest (kind of the opposite of .cacheExtra)
> Cache(rnorm(2, sd = 1), omitArgs = "sd") # removes one or more args from cache digest
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
[1] 0.4690498 0.3480166
attr(,".Cache")
attr(,".Cache")$newCache
[1] TRUE

attr(,"tags")
[1] "cacheId:d1e9b95723b3afa0"
attr(,"call")
[1] ""
> Cache(rnorm(2, sd = 2), omitArgs = "sd") # b/c sd is not used, this is same as previous
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (d1e9b95723b3afa0.rds))
     loaded cached result from previous rnorm call
[1] 0.4690498 0.3480166
attr(,".Cache")
attr(,".Cache")$newCache
[1] FALSE

attr(,"tags")
[1] "cacheId:d1e9b95723b3afa0"
attr(,"call")
[1] ""
> 
> # cacheId -- force the use of a digest -- can give undesired consequences
> Cache(rnorm(3), cacheId = "k323431232") # sets the cacheId for this call
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
cacheId is not same as calculated hash. Manually searching for cacheId:k323431232
[1]  0.33574750  0.02916845 -0.70366763
attr(,".Cache")
attr(,".Cache")$newCache
[1] TRUE

attr(,"tags")
[1] "cacheId:k323431232"
attr(,"call")
[1] ""
> Cache(runif(14), cacheId = "k323431232") # recovers same as above, i.e, rnorm(3)
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
cacheId is not same as calculated hash. Manually searching for cacheId:k323431232
 [1] 0.82657747 0.06330764 0.58535952 0.10954727 0.16799763 0.56128377
 [7] 0.77143248 0.96076003 0.88712779 0.02301652 0.69649534 0.79026812
[13] 0.75366756 0.44443493
attr(,".Cache")
attr(,".Cache")$newCache
[1] TRUE

attr(,"tags")
[1] "cacheId:k323431232"
attr(,"call")
[1] ""
> 
> # Turn off Caching session-wide
> opts <- options(reproducible.useCache = FALSE)
> Cache(rnorm(3)) # doesn't cache
  useCache is FALSE; skipping Cache on function rnorm (currently running nested Cache level 2)
[1] -0.06348935 -2.08337188  0.52299571
> options(opts)
> 
> # showSimilar can help with debugging why a Cache call isn't picking up a cached copy
> Cache(rnorm(4), showSimilar = TRUE) # shows that the argument `n` is different
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
    Cache of 'rnorm' differs from
    the next closest cacheId(s) k323431232 (whose function name(s) was/were 'runif')

    ... because of (a) different n, .FUN
[1] -1.2964733 -0.7063454 -0.9490119 -0.2897013
attr(,".Cache")
attr(,".Cache")$newCache
[1] TRUE

attr(,"tags")
[1] "cacheId:ad0ea27476c50b66"
attr(,"call")
[1] ""
> 
> ###############################################
> # devMode -- enables cache database to stay
> #            small even when developing code
> ###############################################
> opt <- options("reproducible.useCache" = "devMode")
> clearCache(tmpDir, ask = FALSE)
> centralTendency <- function(x)
+   mean(x)
> funnyData <- c(1, 1, 1, 1, 10)
> uniqueUserTags <- c("thisIsUnique", "reallyUnique")
> ranNumsB <- Cache(centralTendency, funnyData, cachePath = tmpDir,
+                   userTags = uniqueUserTags) # sets new value to Cache
> showCache(tmpDir) # 1 unique cacheId -- cacheId is 71cd24ec3b0d0cac
Cache size: 
  Total (including Rasters): 246 bytes
  Selected objects (not including Rasters): 246 bytes
             cacheId              tagKey                  tagValue
 1: 71cd24ec3b0d0cac        thisIsUnique              thisIsUnique
 2: 71cd24ec3b0d0cac        reallyUnique              reallyUnique
 3: 71cd24ec3b0d0cac            function           centralTendency
 4: 71cd24ec3b0d0cac               class                   numeric
 5: 71cd24ec3b0d0cac         object.size                       984
 6: 71cd24ec3b0d0cac            accessed 2023-05-07 07:17:37.03852
 7: 71cd24ec3b0d0cac             inCloud                     FALSE
 8: 71cd24ec3b0d0cac          resultHash                          
 9: 71cd24ec3b0d0cac   elapsedTimeDigest          0.007635117 secs
10: 71cd24ec3b0d0cac elapsedTimeFirstRun          0.004617929 secs
11: 71cd24ec3b0d0cac      otherFunctions                          
12: 71cd24ec3b0d0cac           preDigest        x:e4aa8de28dc6c1bb
13: 71cd24ec3b0d0cac           preDigest     .FUN:d5f5f91cbb662db9
                  createdDate
 1: 2023-05-07 07:17:37.04066
 2: 2023-05-07 07:17:37.04066
 3: 2023-05-07 07:17:37.04066
 4: 2023-05-07 07:17:37.04066
 5: 2023-05-07 07:17:37.04066
 6: 2023-05-07 07:17:37.04066
 7: 2023-05-07 07:17:37.04066
 8: 2023-05-07 07:17:37.04066
 9: 2023-05-07 07:17:37.04066
10: 2023-05-07 07:17:37.04066
11: 2023-05-07 07:17:37.04066
12: 2023-05-07 07:17:37.04066
13: 2023-05-07 07:17:37.04066
> 
> # During development, we often redefine function internals
> centralTendency <- function(x)
+   median(x)
> # When we rerun, we don't want to keep the "old" cache because the function will
> #   never again be defined that way. Here, because of userTags being the same,
> #   it will replace the entry in the Cache, effetively overwriting it, even though
> #   it has a different cacheId
> ranNumsD <- Cache(centralTendency, funnyData, cachePath = tmpDir, userTags = uniqueUserTags)
Overwriting Cache entry with userTags: 'thisIsUnique, reallyUnique, centralTendency'
> showCache(tmpDir) # 1 unique artifact -- cacheId is 632cd06f30e111be
Cache size: 
  Total (including Rasters): 246 bytes
  Selected objects (not including Rasters): 246 bytes
             cacheId              tagKey                   tagValue
 1: 632cd06f30e111be        thisIsUnique               thisIsUnique
 2: 632cd06f30e111be        reallyUnique               reallyUnique
 3: 632cd06f30e111be            function            centralTendency
 4: 632cd06f30e111be               class                    numeric
 5: 632cd06f30e111be         object.size                        984
 6: 632cd06f30e111be            accessed 2023-05-07 07:17:37.234023
 7: 632cd06f30e111be             inCloud                      FALSE
 8: 632cd06f30e111be          resultHash                           
 9: 632cd06f30e111be   elapsedTimeDigest           0.005967379 secs
10: 632cd06f30e111be elapsedTimeFirstRun           0.003727674 secs
11: 632cd06f30e111be      otherFunctions                           
12: 632cd06f30e111be           preDigest         x:e4aa8de28dc6c1bb
13: 632cd06f30e111be           preDigest      .FUN:af11d20d957667d9
                   createdDate
 1: 2023-05-07 07:17:37.235777
 2: 2023-05-07 07:17:37.235777
 3: 2023-05-07 07:17:37.235777
 4: 2023-05-07 07:17:37.235777
 5: 2023-05-07 07:17:37.235777
 6: 2023-05-07 07:17:37.235777
 7: 2023-05-07 07:17:37.235777
 8: 2023-05-07 07:17:37.235777
 9: 2023-05-07 07:17:37.235777
10: 2023-05-07 07:17:37.235777
11: 2023-05-07 07:17:37.235777
12: 2023-05-07 07:17:37.235777
13: 2023-05-07 07:17:37.235777
> 
> # If it finds it by cacheID, doesn't matter what the userTags are
> ranNumsD <- Cache(centralTendency, funnyData, cachePath = tmpDir, userTags = "thisIsUnique")
  ...(Object to retrieve (632cd06f30e111be.rds))
     loaded cached result from previous centralTendency call
> options(opt)
> 
> #########################################
> # For more in depth uses, see vignette
> if (interactive())
+   browseVignettes(package = "reproducible")
> 
> 
> 
> cleanEx()
> nameEx("CacheDigest")
> ### * CacheDigest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CacheDigest
> ### Title: The exact digest function that 'Cache' uses
> ### Aliases: CacheDigest
> 
> ### ** Examples
> 
> data.table::setDTthreads(2)
> a <- Cache(rnorm, 1)
No cachePath supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
> 
> # like with Cache, user can pass function and args in a few ways
> CacheDigest(rnorm(1)) # shows same cacheId as previous line
$outputHash
[1] "422bae4ed2f770cc"

$preDigest
$preDigest$n
[1] "853b1797f54b229c"

$preDigest$mean
[1] "c40c00762a0dac94"

$preDigest$sd
[1] "853b1797f54b229c"

$preDigest$.FUN
[1] "4f604aa46882b368"


> CacheDigest(rnorm, 1) # shows same cacheId as previous line
$outputHash
[1] "422bae4ed2f770cc"

$preDigest
$preDigest$n
[1] "853b1797f54b229c"

$preDigest$mean
[1] "c40c00762a0dac94"

$preDigest$sd
[1] "853b1797f54b229c"

$preDigest$.FUN
[1] "4f604aa46882b368"


> 
> 
> 
> 
> cleanEx()
> nameEx("CacheGeo")
> ### * CacheGeo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CacheGeo
> ### Title: Cache-like function for spatial domains
> ### Aliases: CacheGeo
> 
> ### ** Examples
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("CacheHelpers")
> ### * CacheHelpers
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: createCache
> ### Title: Functions to create and work with a cache
> ### Aliases: createCache loadFromCache rmFromCache CacheDBFile
> ###   CacheStorageDir CacheStoredFile CacheDBTableName CacheIsACache
> 
> ### ** Examples
> 
> data.table::setDTthreads(2)
> newCache <- tempdir2()
> createCache(newCache)
> 
> out <- Cache(rnorm(1), cachePath = newCache)
> cacheId <- gsub("cacheId:", "", attr(out, "tags"))
> loadFromCache(newCache, cacheId = cacheId)
     loaded cached result from previous  call
[1] 0.7635935
attr(,".Cache")
attr(,".Cache")$newCache
[1] TRUE

attr(,"tags")
[1] "cacheId:422bae4ed2f770cc"
attr(,"call")
[1] ""
> 
> rmFromCache(newCache, cacheId = cacheId)
> 
> # clean up
> unlink(newCache, recursive = TRUE)
> 
> data.table::setDTthreads(2)
> newCache <- tempdir2()
> 
> # Given the drv and conn, creates the minimum infrastructure for a cache
> createCache(newCache)
> 
> CacheDBFile(newCache) # identifies the database file
[1] "/var/scratch2/tomas/tmp/RtmpLvcADl/reproducible/ZoHewjy5/cache.db"
> CacheStorageDir(newCache) # identifies the directory where cached objects are stored
[1] "/var/scratch2/tomas/tmp/RtmpLvcADl/reproducible/ZoHewjy5/cacheOutputs"
> 
> out <- Cache(rnorm(1), cachePath = newCache)
> cacheId <- gsub("cacheId:", "", attr(out, "tags"))
> CacheStoredFile(newCache, cacheId = cacheId)
[1] "/var/scratch2/tomas/tmp/RtmpLvcADl/reproducible/ZoHewjy5/cacheOutputs/422bae4ed2f770cc.rds"
> 
> # The name of the table inside the SQL database
> CacheDBTableName(newCache)
[1] "reproducible_ZoHewjy5"
> 
> CacheIsACache(newCache) # returns TRUE
[1] TRUE
> 
> # clean up
> unlink(newCache, recursive = TRUE)
> 
> 
> 
> cleanEx()
> nameEx("Checksums")
> ### * Checksums
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Checksums
> ### Title: Calculate checksum
> ### Aliases: Checksums Checksums,character,logical-method
> ###   Checksums,character,missing-method
> 
> ### ** Examples
> 
> ## Not run: 
> ##D modulePath <- file.path(tempdir(), "myModulePath")
> ##D dir.create(modulePath, recursive = TRUE, showWarnings = FALSE)
> ##D moduleName <- "myModule"
> ##D cat("hi", file = file.path(modulePath, moduleName)) # put something there for this example
> ##D 
> ##D ## verify checksums of all data files
> ##D Checksums(modulePath, files = moduleName)
> ##D 
> ##D ## write new CHECKSUMS.txt file
> ##D Checksums(files = moduleName, modulePath, write = TRUE)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("Copy")
> ### * Copy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Copy
> ### Title: Recursive copying of nested environments, and other "hard to
> ###   copy" objects
> ### Aliases: Copy Copy,ANY-method Copy,data.table-method Copy,list-method
> ###   Copy,refClass-method Copy,data.frame-method
> 
> ### ** Examples
> 
> e <- new.env()
> e$abc <- letters
> e$one <- 1L
> e$lst <- list(W = 1:10, X = runif(10), Y = rnorm(10), Z = LETTERS[1:10])
> ls(e)
[1] "abc" "lst" "one"
> 
> # 'normal' copy
> f <- e
> ls(f)
[1] "abc" "lst" "one"
> f$one
[1] 1
> f$one <- 2L
> f$one
[1] 2
> e$one ## uh oh, e has changed!
[1] 2
> 
> # deep copy
> e$one <- 1L
> g <- Copy(e)
> ls(g)
[1] "abc" "lst" "one"
> g$one
[1] 1
> g$one <- 3L
> g$one
[1] 3
> f$one
[1] 1
> e$one
[1] 1
> ## To create a new deep copy method, use the following template
> ## setMethod("Copy", signature = "the class", # where = specify here if not in a package,
> ##           definition = function(object, filebackendDir, ...) {
> ##           # write deep copy code here
> ##           })
> 
> 
> 
> 
> cleanEx()
> nameEx("Path-class")
> ### * Path-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Path-class
> ### Title: Coerce a character string to a class "Path"
> ### Aliases: Path-class asPath asPath.character asPath.null
> 
> ### ** Examples
> 
> tmpf <- tempfile(fileext = ".csv")
> file.exists(tmpf)    ## FALSE
[1] FALSE
> tmpfPath <- asPath(tmpf)
> is(tmpf, "Path")     ## FALSE
[1] FALSE
> is(tmpfPath, "Path") ## TRUE
[1] TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("assessDataType")
> ### * assessDataType
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: assessDataType
> ### Title: Assess the appropriate raster layer data type
> ### Aliases: assessDataType assessDataType.default
> 
> ### ** Examples
> 
> if (!requireNamespace("terra")) stop("Need terra to run example")
Loading required namespace: terra
>   ## LOG1S
> ras <- terra::rast(ncol = 10, nrow = 10)
> ras[] <- rep(c(0,1),50)
> assessDataType(ras)
[1] "LOG1S"
> 
> ras <- terra::rast(ncol = 10, nrow = 10)
> ras[] <- rep(c(0,1),50)
> assessDataType(ras)
[1] "LOG1S"
> 
> ras[] <- rep(c(TRUE,FALSE),50)
> assessDataType(ras)
[1] "LOG1S"
> 
> ras[] <- c(NA, NA, rep(c(0,1),49))
> assessDataType(ras)
[1] "LOG1S"
> 
> ras <- terra::rast(ncol = 10, nrow = 10)
> ras[] <- c(0, NaN, rep(c(0,1),49))
> assessDataType(ras)
[1] "LOG1S"
> 
> 
> ## INT1S
> ras[] <- -1:98
> assessDataType(ras)
[1] "INT1S"
> 
> ras[] <- c(NA, -1:97)
> assessDataType(ras)
[1] "INT1S"
> 
> ## INT1U
> ras <- terra::rast(ncol = 10, nrow = 10)
> ras[] <- 1:100
> assessDataType(ras)
[1] "INT1U"
> 
> ras[] <- c(NA, 2:100)
> assessDataType(ras)
[1] "INT1U"
> 
> ## INT2U
> ras <- terra::rast(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = 64000, max = 65000))
> assessDataType(ras)
[1] "INT2U"
> 
> ## INT2S
> ras <- terra::rast(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = -32767, max = 32767))
> assessDataType(ras)
[1] "INT2S"
> 
> ras[54] <- NA
> assessDataType(ras)
[1] "INT2S"
> 
> ## INT4U
> ras <- terra::rast(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = 0, max = 500000000))
> assessDataType(ras)
[1] "INT4U"
> 
> ras[14] <- NA
> assessDataType(ras)
[1] "INT4U"
> 
> ## INT4S
> ras <- terra::rast(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = -200000000, max = 200000000))
> assessDataType(ras)
[1] "INT4S"
> 
> ras[14] <- NA
> assessDataType(ras)
[1] "INT4S"
> 
> ## FLT4S
> ras <- terra::rast(ncol = 10, nrow = 10)
> ras[] <- runif(100, min = -10, max = 87)
> assessDataType(ras)
[1] "FLT4S"
> 
> ras <- terra::rast(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = -3.4e+26, max = 3.4e+28))
> assessDataType(ras)
[1] "FLT4S"
> 
> ras <- terra::rast(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = 3.4e+26, max = 3.4e+28))
> assessDataType(ras)
[1] "FLT4S"
> 
> ras <- terra::rast(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = -3.4e+26, max = -1))
> assessDataType(ras)
[1] "FLT4S"
> 
> ## FLT8S
> ras <- terra::rast(ncol = 10, nrow = 10)
> ras[] <- c(-Inf, 1, rep(c(0,1),49))
> assessDataType(ras)
[1] "FLT8S"
> 
> ras <- terra::rast(ncol = 10, nrow = 10)
> ras[] <- c(Inf, 1, rep(c(0,1),49))
> assessDataType(ras)
[1] "FLT8S"
> 
> ras <- terra::rast(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = -1.7e+30, max = 1.7e+308))
> assessDataType(ras)
[1] "FLT8S"
> 
> ras <- terra::rast(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = 1.7e+30, max = 1.7e+308))
> assessDataType(ras)
[1] "FLT8S"
> 
> ras <- terra::rast(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = -1.7e+308, max = -1))
> assessDataType(ras)
[1] "FLT8S"
> 
> # 2 layer with different types LOG1S and FLT8S
> ras <- terra::rast(ncol = 10, nrow = 10)
> ras[] <- rep(c(0,1),50)
> ras1 <- terra::rast(ncol = 10, nrow = 10)
> ras1[] <- round(runif(100, min = -1.7e+308, max = -1))
> sta <- c(ras, ras1)
> assessDataType(sta)
[1] "LOG1S" "FLT8S"
> 
> 
> 
> 
> cleanEx()
> nameEx("checkPath")
> ### * checkPath
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkPath
> ### Title: Check directory path
> ### Aliases: checkPath checkPath,character,logical-method
> ###   checkPath,character,missing-method checkPath,NULL,ANY-method
> ###   checkPath,missing,ANY-method
> 
> ### ** Examples
> 
> ## normalize file paths
> paths <- list("./aaa/zzz",
+               "./aaa/zzz/",
+               ".//aaa//zzz",
+               ".//aaa//zzz/",
+               ".\\\\aaa\\\\zzz",
+               ".\\\\aaa\\\\zzz\\\\",
+               file.path(".", "aaa", "zzz"))
> 
> checked <- normPath(paths)
> length(unique(checked)) ## 1; all of the above are equivalent
[1] 3
> 
> ## check to see if a path exists
> tmpdir <- file.path(tempdir(), "example_checkPath")
> 
> dir.exists(tmpdir) ## FALSE
[1] FALSE
> tryCatch(checkPath(tmpdir, create = FALSE), error = function(e) FALSE) ## FALSE
[1] FALSE
> 
> checkPath(tmpdir, create = TRUE)
[1] "/var/scratch2/tomas/tmp/RtmpLvcADl/example_checkPath"
> dir.exists(tmpdir) ## TRUE
[1] TRUE
> 
> unlink(tmpdir, recursive = TRUE)
> 
> 
> 
> cleanEx()
> nameEx("compareNA")
> ### * compareNA
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compareNA
> ### Title: 'NA'-aware comparison of two vectors
> ### Aliases: compareNA
> 
> ### ** Examples
> 
> a <- c(NA, 1, 2, NA)
> b <- c(1, NA, 2, NA)
> compareNA(a, b)
[1] FALSE FALSE  TRUE  TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("convertPaths")
> ### * convertPaths
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: convertPaths
> ### Title: Change the absolute path of a file
> ### Aliases: convertPaths convertRasterPaths
> 
> ### ** Examples
> 
> filenames <- c("/home/user1/Documents/file.txt", "/Users/user1/Documents/file.txt")
> oldPaths <- dirname(filenames)
> newPaths <- c("/home/user2/Desktop", "/Users/user2/Desktop")
> convertPaths(filenames, oldPaths, newPaths)
[1] "/home/user2/Desktop/file.txt"  "/Users/user2/Desktop/file.txt"
> 
> 
> 
> 
> cleanEx()
> nameEx("copyFile")
> ### * copyFile
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: copySingleFile
> ### Title: Copy a file using 'robocopy' on Windows and 'rsync' on
> ###   Linux/macOS
> ### Aliases: copySingleFile copyFile
> 
> ### ** Examples
> 
> tmpDirFrom <- file.path(tempdir(), "example_fileCopy_from")
> tmpDirTo <- file.path(tempdir(), "example_fileCopy_to")
> tmpFile1 <- tempfile("file1", tmpDirFrom, ".csv")
> tmpFile2 <- tempfile("file2", tmpDirFrom, ".csv")
> dir.create(tmpDirFrom, recursive = TRUE, showWarnings = FALSE)
> dir.create(tmpDirTo, recursive = TRUE, showWarnings = FALSE)
> f1 <- normalizePath(tmpFile1, mustWork = FALSE)
> f2 <- normalizePath(tmpFile2, mustWork = FALSE)
> t1 <- normalizePath(file.path(tmpDirTo, basename(tmpFile1)), mustWork = FALSE)
> t2 <- normalizePath(file.path(tmpDirTo, basename(tmpFile2)), mustWork = FALSE)
> 
> write.csv(data.frame(a = 1:10, b = runif(10), c = letters[1:10]), f1)
> write.csv(data.frame(c = 11:20, d = runif(10), e = letters[11:20]), f2)
> copyFile(c(f1, f2), c(t1, t2))
/var/scratch2/tomas/tmp/RtmpLvcADl/example_fileCopy_from/file13f46941d8184a6.csv 
"/var/scratch2/tomas/tmp/RtmpLvcADl/example_fileCopy_to/file13f46941d8184a6.csv" 
/var/scratch2/tomas/tmp/RtmpLvcADl/example_fileCopy_from/file23f469454208c0d.csv 
"/var/scratch2/tomas/tmp/RtmpLvcADl/example_fileCopy_to/file23f469454208c0d.csv" 
> file.exists(t1) ## TRUE
[1] TRUE
> file.exists(t2) ## TRUE
[1] TRUE
> identical(read.csv(f1), read.csv(f2)) ## FALSE
[1] FALSE
> identical(read.csv(f1), read.csv(t1)) ## TRUE
[1] TRUE
> identical(read.csv(f2), read.csv(t2)) ## TRUE
[1] TRUE
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("deprecated")
> ### * deprecated
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cropInputs
> ### Title: Crop a Spatial* or Raster* object
> ### Aliases: cropInputs cropInputs.default fixErrors fixErrors.default
> ###   projectInputs projectInputs.default maskInputs writeOutputs
> ###   writeOutputs.default
> ### Keywords: internal
> 
> ### ** Examples
> 
> if (requireNamespace("terra")) {
+   r <- terra::rast(terra::ext(0,100,0,100), vals = 1:1e2)
+ 
+   tf <- tempfile(fileext = ".tif")
+   writeOutputs(r, tf)
+ }
    writing......done in 0.258 secs
class       : SpatRaster 
dimensions  : 10, 10, 1  (nrow, ncol, nlyr)
resolution  : 10, 10  (x, y)
extent      : 0, 100, 0, 100  (xmin, xmax, ymin, ymax)
coord. ref. :  
source      : file3f46941f83ff5c.tif 
name        : lyr.1 
min value   :     1 
max value   :   100 
> 
> 
> 
> cleanEx()
> nameEx("exportedMethods")
> ### * exportedMethods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: .sortDotsUnderscoreFirst
> ### Title: Exported generics and methods
> ### Aliases: .sortDotsUnderscoreFirst .orderDotsUnderscoreFirst
> ###   ExportedMethods .tagsByClass .tagsByClass,ANY-method .cacheMessage
> ###   .cacheMessage,ANY-method .addTagsToOutput .addTagsToOutput,ANY-method
> ###   .preDigestByClass .preDigestByClass,ANY-method .checkCacheRepo
> ###   .checkCacheRepo,ANY-method .prepareOutput .prepareOutput,ANY-method
> ###   .addChangedAttr .addChangedAttr,ANY-method updateFilenameSlots
> ###   updateFilenameSlots.default updateFilenameSlots.list
> ###   updateFilenameSlots.environment makeMemoisable makeMemoisable.default
> ###   makeMemoisable.data.table unmakeMemoisable unmakeMemoisable.default
> ### Keywords: internal
> 
> ### ** Examples
> 
> items <- c(A = "a", Z = "z", `.D` = ".d", `_C` = "_C")
> .sortDotsUnderscoreFirst(items)
   A    Z   _C   .D 
 "a"  "z" "_C" ".d" 
> 
> # dots & underscore (using 2nd character), then all lower then all upper
> items <- c(B = "Upper", b = "lower", A = "a", `.D` = ".d", `_C` = "_C")
> .sortDotsUnderscoreFirst(items)
      A       B      _C      .D       b 
    "a" "Upper"    "_C"    ".d" "lower" 
> 
> # with a vector
> .sortDotsUnderscoreFirst(c(".C", "_B", "A")) # _B is first
[1] "A"  "_B" ".C"
> 
> .tagsByClass(character())
NULL
> 
> a <- 1
> .cacheMessage(a, "mean")
     loaded cached result from previous mean call (and added a memoised copy)
> 
> a <- 1
> .preDigestByClass(a) # returns NULL in the simple case here.
NULL
> 
> a <- normalizePath(file.path(tempdir(), "test"), mustWork = FALSE)
> .checkCacheRepo(a, create = TRUE)
> 
> a <- 1
> .prepareOutput(a) # does nothing
[1] 1
> 
> b <- "NULL"
> .prepareOutput(b) # converts to NULL
NULL
> 
> if (requireNamespace("terra")) {
+   r <- terra::rast(terra::ext(0,10,0,10), vals = 1:100)
+ 
+   # write to disk manually -- will be in tempdir()
+   r <- terra::writeRaster(r, file = tempfile(fileext = ".tif"))
+ 
+   # copy it to the cache repository
+   r <- .prepareOutput(r, tempdir())
+ }
> a <- 1
> .addChangedAttr(a) # does nothing because default method is just a pass through
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("linkOrCopy")
> ### * linkOrCopy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: linkOrCopy
> ### Title: Hardlink, symlink, or copy a file
> ### Aliases: linkOrCopy
> 
> ### ** Examples
> 
> 
> tmpDir <- file.path(tempdir(), "symlink-test")
> tmpDir <- normalizePath(tmpDir, winslash = '/', mustWork = FALSE)
> dir.create(tmpDir)
> 
> f0 <- file.path(tmpDir, "file0.csv")
> write.csv(iris, f0)
> 
> d1 <- file.path(tmpDir, "dir1")
> dir.create(d1)
> write.csv(iris, file.path(d1, "file1.csv"))
> 
> d2 <- file.path(tmpDir, "dir2")
> dir.create(d2)
> f2 <- file.path(tmpDir, "file2.csv")
> 
> ## create link to a file
> linkOrCopy(f0, f2)
Hardlinked version of file(s) created at: /var/scratch2/tomas/tmp/RtmpLvcADl/symlink-test/file2.csv, which point(s) to /var/scratch2/tomas/tmp/RtmpLvcADl/symlink-test/file0.csv; no copy was made.
[1] TRUE
> file.exists(f2) ## TRUE
[1] TRUE
> identical(read.table(f0), read.table(f2)) ## TRUE
[1] TRUE
> 
> ## deleting the link shouldn't delete the original file
> unlink(f0)
> file.exists(f0) ## FALSE
[1] FALSE
> file.exists(f2) ## TRUE
[1] TRUE
> 
> if (requireNamespace("terra")) {
+   ## using spatRasters and other file-backed objects
+   f3a <- system.file("ex/test.grd", package = "terra")
+   f3b <- system.file("ex/test.gri", package = "terra")
+   r3a <- terra::rast(f3a)
+   f4a <- file.path(tmpDir, "raster4.grd")
+   f4b <- file.path(tmpDir, "raster4.gri")
+   linkOrCopy(f3a, f4a) ## hardlink
+   linkOrCopy(f3b, f4b) ## hardlink
+   r4a <- terra::rast(f4a)
+ 
+   isTRUE(all.equal(r3a, r4a)) # TRUE
+ 
+   ## cleanup
+   unlink(tmpDir, recursive = TRUE)
+ }
Hardlinked version of file(s) created at: /var/scratch2/tomas/tmp/RtmpLvcADl/symlink-test/raster4.grd, which point(s) to /var/scratch2/tomas/cran/rcnst/lib/terra/ex/test.grd; no copy was made.
Hardlinked version of file(s) created at: /var/scratch2/tomas/tmp/RtmpLvcADl/symlink-test/raster4.gri, which point(s) to /var/scratch2/tomas/cran/rcnst/lib/terra/ex/test.gri; no copy was made.
> 
> 
> 
> cleanEx()
> nameEx("movedCache")
> ### * movedCache
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: movedCache
> ### Title: Deal with moved cache issues
> ### Aliases: movedCache
> 
> ### ** Examples
> 
> data.table::setDTthreads(2)
> tmpdir <- "tmpdir"
> tmpCache <- "tmpCache"
> tmpCacheDir <- normalizePath(file.path(tempdir(), tmpCache), mustWork = FALSE)
> tmpdirPath <- normalizePath(file.path(tempdir(), tmpdir), mustWork = FALSE)
> bb <- Cache(rnorm, 1, cachePath = tmpCacheDir)
> 
> # Copy all files from tmpCache to tmpdir
> froms <- normalizePath(dir(tmpCacheDir, recursive = TRUE, full.names = TRUE),
+                        mustWork = FALSE)
> dir.create(file.path(tmpdirPath, "rasters"), recursive = TRUE, showWarnings = FALSE)
> dir.create(file.path(tmpdirPath, "cacheOutputs"), recursive = TRUE, showWarnings = FALSE)
> file.copy(from = froms, overwrite = TRUE,
+           to = gsub(tmpCache, tmpdir, froms))
[1] TRUE TRUE
> 
> # Can use 'movedCache' to update the database table, though will generally
> #   happen automatically, with message indicating so
> movedCache(new = tmpdirPath, old = tmpCacheDir)
> bb <- Cache(rnorm, 1, cachePath = tmpdirPath) # should recover the previous call
  ...(Object to retrieve (422bae4ed2f770cc.rds))
     loaded cached result from previous rnorm call
> 
> 
> 
> 
> cleanEx()
> nameEx("normPath")
> ### * normPath
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: normPath
> ### Title: Normalize filepath
> ### Aliases: normPath normPath,character-method normPath,list-method
> ###   normPath,NULL-method normPath,missing-method normPath,logical-method
> 
> ### ** Examples
> 
> ## normalize file paths
> paths <- list("./aaa/zzz",
+               "./aaa/zzz/",
+               ".//aaa//zzz",
+               ".//aaa//zzz/",
+               ".\\\\aaa\\\\zzz",
+               ".\\\\aaa\\\\zzz\\\\",
+               file.path(".", "aaa", "zzz"))
> 
> checked <- normPath(paths)
> length(unique(checked)) ## 1; all of the above are equivalent
[1] 3
> 
> ## check to see if a path exists
> tmpdir <- file.path(tempdir(), "example_checkPath")
> 
> dir.exists(tmpdir) ## FALSE
[1] FALSE
> tryCatch(checkPath(tmpdir, create = FALSE), error = function(e) FALSE) ## FALSE
[1] FALSE
> 
> checkPath(tmpdir, create = TRUE)
[1] "/var/scratch2/tomas/tmp/RtmpLvcADl/example_checkPath"
> dir.exists(tmpdir) ## TRUE
[1] TRUE
> 
> unlink(tmpdir, recursive = TRUE)
> 
> 
> 
> cleanEx()
> nameEx("objSize")
> ### * objSize
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: objSize
> ### Title: Wrapper around 'lobstr::obj_size'
> ### Aliases: objSize objSizeSession
> 
> ### ** Examples
> 
> library(utils)
> 
> foo <- new.env()
> foo$b <- 1:10
> foo$d <- 1:10
> 
> objSize(foo) # all the elements in the environment
1.39 kB
> utils::object.size(foo) # different - only measuring the environment as an object
56 bytes
> 
> utils::object.size(prepInputs) # only the function, without its enclosing environment
145496 bytes
> objSize(prepInputs)     # the function, plus its enclosing environment
38.27 kB
> 
> os1 <- utils::object.size(as.environment("package:reproducible"))
> (os1) # very small -- just the environment container
568 bytes
> 
> # slow next bit
> 
> 
> 
> cleanEx()
> nameEx("paddedFloatToChar")
> ### * paddedFloatToChar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: paddedFloatToChar
> ### Title: Convert numeric to character with padding
> ### Aliases: paddedFloatToChar
> 
> ### ** Examples
> 
> paddedFloatToChar(1.25)
[1] "1.250"
> paddedFloatToChar(1.25, padL = 3, padR = 5)
[1] "001.25000"
> paddedFloatToChar(1.25, padL = 3, padR = 1) # no rounding, so keeps 2 right of decimal
[1] "001.25"
> 
> 
> 
> cleanEx()
> nameEx("postProcess")
> ### * postProcess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: postProcess
> ### Title: Generic function to post process objects
> ### Aliases: postProcess postProcess.list postProcess.default
> 
> ### ** Examples
> 
> if (requireNamespace("terra") && requireNamespace("sf")) {
+   library(reproducible)
+   od <- setwd(tempdir2())
+   # download a (spatial) file from remote url (which often is an archive) load into R
+   # need 3 files for this example; 1 from remote, 2 local
+   dPath <- file.path(tempdir2())
+   remoteTifUrl <- "https://github.com/rspatial/terra/raw/master/inst/ex/elev.tif"
+   localFileLuxSm <- system.file("ex/luxSmall.shp", package = "reproducible")
+   localFileLux <- system.file("ex/lux.shp", package = "terra")
+ 
+   # 1 step for each layer
+   # 1st step -- get study area
+   studyArea <- prepInputs(localFileLuxSm, fun = "terra::vect") # default is sf::st_read
+   # 2nd step: make the input data layer like the studyArea map
+   elevForStudy <- prepInputs(url = remoteTifUrl, to = studyArea, res = 250,
+                              destinationPath = dPath)
+ 
+ 
+   # Alternate way, one step at a time. Must know each of these steps, and perform for each layer
+ 
+   # sf class
+   studyAreaSmall <- prepInputs(localFileLuxSm)
+   studyAreas <- list()
+   studyAreas[["orig"]] <- prepInputs(localFileLux)
+   studyAreas[["reprojected"]] <- projectTo(studyAreas[["orig"]], studyAreaSmall)
+   studyAreas[["cropped"]] <- suppressWarnings(cropTo(studyAreas[["orig"]], studyAreaSmall))
+   studyAreas[["masked"]] <- suppressWarnings(maskTo(studyAreas[["orig"]], studyAreaSmall))
+ 
+   # SpatVector-- note: doesn't matter what class the "to" object is, only the "from"
+   studyAreas <- list()
+   studyAreas[["orig"]] <- prepInputs(localFileLux, fun = "terra::vect")
+   studyAreas[["reprojected"]] <- projectTo(studyAreas[["orig"]], studyAreaSmall)
+   studyAreas[["cropped"]] <- suppressWarnings(cropTo(studyAreas[["orig"]], studyAreaSmall))
+   studyAreas[["masked"]] <- suppressWarnings(maskTo(studyAreas[["orig"]], studyAreaSmall))
+   if (interactive()) {
+     par(mfrow = c(2,2));
+     out <- lapply(studyAreas, function(x) terra::plot(x))
+   }
+ 
+   setwd(od)
+ 
+ }
Loading required namespace: sf
Running preProcess
Preparing: /var/scratch2/tomas/cran/rcnst/lib/reproducible/ex/luxSmall.shp
Checking local files...
Finished checking local files.
alsoExtract is unspecified; assuming that all files must be extracted
targetFile located at /var/scratch2/tomas/cran/rcnst/lib/reproducible/ex/luxSmall.shp
Loading object into R
Running preProcess
targetFile was not supplied; guessed and will try /var/scratch2/tomas/tmp/RtmpLvcADl/reproducible/dhWOwkkF/elev.tif. If this is incorrect, please supply targetFile
Preparing: elev.tif
Checking local files...
Finished checking local files.
...downloading...
  |                                                                              |                                                                      |   0%  |                                                                              |===================================================================   |  96%  |                                                                              |======================================================================| 100%
Hardlinked version of file(s) created at: /var/scratch2/tomas/tmp/RtmpLvcADl/reproducible/dhWOwkkF/elev.tif, which point(s) to /var/scratch2/tomas/tmp/RtmpLvcADl/reproducible/Hewjy5/elev.tif; no copy was made.
Checking local files...
Finished checking local files.
alsoExtract is unspecified; assuming that all files must be extracted
Appending checksums to CHECKSUMS.txt. If you see this messagePrepInputs repeatedly,
  you can specify targetFile (and optionally alsoExtract) so it knows
  what to look for.
targetFile located at /var/scratch2/tomas/tmp/RtmpLvcADl/reproducible/dhWOwkkF/elev.tif
Loading object into R
    cropping......done in 0.999 secs
    projecting...
         projectTo is a Vector dataset, which does not define all metadata required. 
         in the projection of `projectTo`, using the origin and extent
         from `ext(from)` (in the projection from `projectTo`).
         If this is not correct, create a template gridded object and pass that to projectTo...
         done in 0.983 secs
    masking......done in 0.455 secs
    cropping......done in 0.205 secs
  postProcessTo done in 2.73 secs
Running preProcess
Preparing: /var/scratch2/tomas/cran/rcnst/lib/reproducible/ex/luxSmall.shp
Checking local files...
Finished checking local files.
alsoExtract is unspecified; assuming that all files must be extracted
alsoExtract is unspecified; assuming that all files must be extracted
Using sf::st_read on shapefile because sf package is available; to force old behaviour with 'raster::shapefile' use fun = 'raster::shapefile' or options('reproducible.shapefileRead' = 'raster::shapefile')
targetFile located at /var/scratch2/tomas/cran/rcnst/lib/reproducible/ex/luxSmall.shp
Loading object into R
Reading layer `luxSmall' from data source 
  `/var/scratch2/tomas/cran/rcnst/lib/reproducible/ex/luxSmall.shp' 
  using driver `ESRI Shapefile'
Simple feature collection with 4 features and 6 fields
Geometry type: POLYGON
Dimension:     XY
Bounding box:  xmin: 4522355 ymin: 11299040 xmax: 4575913 ymax: 11339850
Projected CRS: +proj=lcc +lat_0=0 +lon_0=-95 +lat_1=49 +lat_2=77 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs
Running preProcess
Preparing: /var/scratch2/tomas/cran/rcnst/lib/terra/ex/lux.shp
Checking local files...
Finished checking local files.
alsoExtract is unspecified; assuming that all files must be extracted
alsoExtract is unspecified; assuming that all files must be extracted
Using sf::st_read on shapefile because sf package is available; to force old behaviour with 'raster::shapefile' use fun = 'raster::shapefile' or options('reproducible.shapefileRead' = 'raster::shapefile')
targetFile located at /var/scratch2/tomas/cran/rcnst/lib/terra/ex/lux.shp
Loading object into R
Reading layer `lux' from data source 
  `/var/scratch2/tomas/cran/rcnst/lib/terra/ex/lux.shp' using driver `ESRI Shapefile'
Simple feature collection with 12 features and 6 fields
Geometry type: POLYGON
Dimension:     XY
Bounding box:  xmin: 5.74414 ymin: 49.44781 xmax: 6.528252 ymax: 50.18162
Geodetic CRS:  WGS 84
    projecting...done in 0.127 secs
    cropping......done in 0.746 secs
    masking......done in 0.195 secs
Running preProcess
Preparing: /var/scratch2/tomas/cran/rcnst/lib/terra/ex/lux.shp
Checking local files...
Finished checking local files.
alsoExtract is unspecified; assuming that all files must be extracted
alsoExtract is unspecified; assuming that all files must be extracted
targetFile located at /var/scratch2/tomas/cran/rcnst/lib/terra/ex/lux.shp
Loading object into R
    projecting...done in 0.226 secs
    cropping......done in 0.2 secs
    masking......done in 0.151 secs
> 
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("prefix")
> ### * prefix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: .prefix
> ### Title: Add a prefix or suffix to the basename part of a file path
> ### Aliases: .prefix suffix .suffix
> 
> ### ** Examples
> 
> # file's full path is specified (i.e., dirname is known)
> myFile <- file.path("~/data", "file.tif")
> .prefix(myFile, "small_")    ## "/home/username/data/small_file.tif"
[1] "/space/tkalibera/data/small_file.tif"
> .suffix(myFile, "_cropped") ## "/home/username/data/myFile_cropped.shp"
[1] "/space/tkalibera/data/file_cropped.tif"
> 
> # file's full path is not specified
> .prefix("myFile.shp", "small")    ## "./small_myFile.shp"
[1] "./smallmyFile.shp"
> .suffix("myFile.shp", "_cropped") ## "./myFile_cropped.shp"
[1] "./myFile_cropped.shp"
> 
> 
> 
> 
> cleanEx()
> nameEx("prepInputs")
> ### * prepInputs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: prepInputs
> ### Title: Download and optionally post-process files
> ### Aliases: prepInputs
> 
> ### ** Examples
> 
> 
> ## Using quoted dlFun and fun -- this is not intended to be run but used as a template
> ## prepInputs(..., fun = quote(customFun(x = targetFile)), customFun = customFun)
> ##   # or more complex
> ##  test5 <- prepInputs(
> ##   targetFile = targetFileLuxRDS,
> ##   dlFun = quote({
> ##     getDataFn(name = "GADM", country = "LUX", level = 0) # preProcess keeps file from this!
> ##   }),
> ##   fun = quote({
> ##     out <- readRDS(targetFile)
> ##     sf::st_as_sf(out)})
> ##  )
> 
> 
> 
> cleanEx()
> nameEx("robustDigest")
> ### * robustDigest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: .robustDigest
> ### Title: Create reproducible digests of objects in R
> ### Aliases: .robustDigest .robustDigest,ANY-method
> ###   .robustDigest,function-method .robustDigest,expression-method
> ###   .robustDigest,language-method .robustDigest,character-method
> ###   .robustDigest,Path-method .robustDigest,environment-method
> ###   .robustDigest,list-method .robustDigest,data.frame-method
> ###   .robustDigest,numeric-method .robustDigest,matrix-method
> ###   .robustDigest,integer-method
> ### Keywords: internal
> 
> ### ** Examples
> 
> 
> a <- 2
> tmpfile1 <- tempfile()
> tmpfile2 <- tempfile()
> tmpfile3 <- tempfile(fileext = ".grd")
> tmpfile4 <- tempfile(fileext = ".grd")
> save(a, file = tmpfile1)
> save(a, file = tmpfile2)
> 
> # treats as character string, so 2 filenames are different
> digest::digest(tmpfile1)
[1] "2b92574545bb05e5fd861eecaaee560a"
> digest::digest(tmpfile2)
[1] "bb20feb75b0099b484cd968eeaccaba8"
> 
> # tests to see whether character string is representing a file
> .robustDigest(tmpfile1)
[1] "94c61fb1b6303aeb"
> .robustDigest(tmpfile2) # same
[1] "94c61fb1b6303aeb"
> 
> # if you tell it that it is a path, then you can decide if you want it to be
> #  treated as a character string or as a file path
> .robustDigest(asPath(tmpfile1), quick = TRUE)
[1] "740780642807ad5c"
> .robustDigest(asPath(tmpfile2), quick = TRUE) # different because using file info
[1] "0c2eb2b8ae63946a"
> 
> .robustDigest(asPath(tmpfile1), quick = FALSE)
[[1]]
[1] "94c61fb1b6303aeb"

> .robustDigest(asPath(tmpfile2), quick = FALSE) # same because using file content
[[1]]
[1] "94c61fb1b6303aeb"

> 
> # SpatRasters are have pointers
> if (requireNamespace("terra")) {
+   r <- terra::rast(system.file("ex/elev.tif", package = "terra"))
+   r3 <- terra::deepcopy(r)
+   r1 <- terra::writeRaster(r, filename = tmpfile3)
+ 
+   digest::digest(r)
+   digest::digest(r3) # different but should be same
+   .robustDigest(r1)
+   .robustDigest(r3) # same... data & metadata are the same
+ 
+   # note, this is not true for comparing memory and file-backed rasters
+   .robustDigest(r)
+   .robustDigest(r1) # different
+ }
[1] "7b1f1ca9faaf4cfa"
> 
> 
> 
> 
> cleanEx()
> nameEx("search")
> ### * search
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: searchFull
> ### Title: Search up the full scope for functions
> ### Aliases: searchFull searchFullEx
> 
> ### ** Examples
> 
> seeScope <- function() {
+   searchFull()
+ }
> seeScope()
[[1]]
<environment: R_GlobalEnv>

[[2]]
[1] "package:reproducible"

[[3]]
[1] "CheckExEnv"

[[4]]
[1] "package:stats"

[[5]]
[1] "package:graphics"

[[6]]
[1] "package:grDevices"

[[7]]
[1] "package:utils"

[[8]]
[1] "package:datasets"

[[9]]
[1] "package:methods"

[[10]]
[1] "Autoloads"

[[11]]
<environment: base>

> searchFull()
[[1]]
[1] "package:reproducible"

[[2]]
[1] "CheckExEnv"

[[3]]
[1] "package:stats"

[[4]]
[1] "package:graphics"

[[5]]
[1] "package:grDevices"

[[6]]
[1] "package:utils"

[[7]]
[1] "package:datasets"

[[8]]
[1] "package:methods"

[[9]]
[1] "Autoloads"

[[10]]
<environment: base>

> searchFullEx()
[[1]]
<environment: namespace:reproducible>

[[2]]
[1] "imports:reproducible"

[[3]]
<environment: namespace:base>

[[4]]
<environment: R_GlobalEnv>

[[5]]
[1] "package:reproducible"

[[6]]
[1] "CheckExEnv"

[[7]]
[1] "package:stats"

[[8]]
[1] "package:graphics"

[[9]]
[1] "package:grDevices"

[[10]]
[1] "package:utils"

[[11]]
[1] "package:datasets"

[[12]]
[1] "package:methods"

[[13]]
[1] "Autoloads"

[[14]]
<environment: base>

> 
> 
> 
> cleanEx()
> nameEx("studyAreaName")
> ### * studyAreaName
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: studyAreaName
> ### Title: Get a unique name for a given study area
> ### Aliases: studyAreaName studyAreaName,character-method
> ###   studyAreaName,ANY-method
> 
> ### ** Examples
> 
> studyAreaName("Ontario")
[1] "f8871845734fa227"
> 
> 
> 
> cleanEx()
> nameEx("terra-migration")
> ### * terra-migration
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: minFn
> ### Title: Get min or maximum value of a (Spat)Raster
> ### Aliases: minFn maxFn dataType2 nlayers2 values2
> 
> ### ** Examples
> 
> if (requireNamespace("terra")) {
+   ras <- terra::rast(terra::ext(0, 10, 0, 10), vals = 1:100)
+   maxFn(ras)
+   minFn(ras)
+ }
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("viewCache")
> ### * viewCache
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: showCache
> ### Title: Examining and modifying the cache
> ### Aliases: showCache clearCache clearCache,ANY-method cc
> ###   showCache,ANY-method keepCache keepCache,ANY-method
> 
> ### ** Examples
> 
> data.table::setDTthreads(2)
> 
> tmpDir <- file.path(tempdir(), "reproducible_examples", "Cache")
> try(clearCache(tmpDir, ask = FALSE), silent = TRUE) # just to make sure it is clear
> 
> # Basic use
> ranNumsA <- Cache(rnorm, 10, 16, cachePath = tmpDir)
> 
> # All same
> ranNumsB <- Cache(rnorm, 10, 16, cachePath = tmpDir) # recovers cached copy
  ...(Object to retrieve (4fca280cda001fc9.rds))
     loaded cached result from previous rnorm call
> ranNumsD <- Cache(quote(rnorm(n = 10, 16)), cachePath = tmpDir) # recovers cached copy
  ...(Object to retrieve (4fca280cda001fc9.rds))
     loaded cached result from previous quote call
> 
> # Any minor change makes it different
> ranNumsE <- Cache(rnorm, 10, 6, cachePath = tmpDir) # different
> 
> ## Example 1: basic cache use with tags
> ranNumsA <- Cache(rnorm, 4, cachePath = tmpDir, userTags = "objectName:a")
> ranNumsB <- Cache(runif, 4, cachePath = tmpDir, userTags = "objectName:b")
> ranNumsC <- Cache(runif, 40, cachePath = tmpDir, userTags = "objectName:b")
> 
> showCache(tmpDir, userTags = c("objectName"))
Cache size: 
  Total (including Rasters): 828 bytes
  Selected objects (not including Rasters): 828 bytes
             cacheId              tagKey                   tagValue
 1: a0603ff09bb4ce83          objectName                          b
 2: a0603ff09bb4ce83            function                      runif
 3: a0603ff09bb4ce83               class                    numeric
 4: a0603ff09bb4ce83         object.size                       1296
 5: a0603ff09bb4ce83            accessed 2023-05-07 07:20:32.315587
 6: a0603ff09bb4ce83             inCloud                      FALSE
 7: a0603ff09bb4ce83          resultHash                           
 8: a0603ff09bb4ce83   elapsedTimeDigest            0.00655508 secs
 9: a0603ff09bb4ce83 elapsedTimeFirstRun          0.0001032352 secs
10: a0603ff09bb4ce83      otherFunctions                           
11: a0603ff09bb4ce83           preDigest         n:1393aef18608c8be
12: a0603ff09bb4ce83           preDigest       min:c40c00762a0dac94
13: a0603ff09bb4ce83           preDigest       max:853b1797f54b229c
14: a0603ff09bb4ce83           preDigest      .FUN:881ec847b7161f3c
15: ad0ea27476c50b66          objectName                          a
16: ad0ea27476c50b66            function                      rnorm
17: ad0ea27476c50b66               class                    numeric
18: ad0ea27476c50b66         object.size                       1008
19: ad0ea27476c50b66            accessed 2023-05-07 07:20:32.162419
20: ad0ea27476c50b66             inCloud                      FALSE
21: ad0ea27476c50b66          resultHash                           
22: ad0ea27476c50b66   elapsedTimeDigest           0.004830599 secs
23: ad0ea27476c50b66 elapsedTimeFirstRun          0.0001263618 secs
24: ad0ea27476c50b66      otherFunctions                           
25: ad0ea27476c50b66           preDigest         n:7eef4eae85fd9229
26: ad0ea27476c50b66           preDigest      mean:c40c00762a0dac94
27: ad0ea27476c50b66           preDigest        sd:853b1797f54b229c
28: ad0ea27476c50b66           preDigest      .FUN:4f604aa46882b368
29: deaa37372f85861b          objectName                          b
30: deaa37372f85861b            function                      runif
31: deaa37372f85861b               class                    numeric
32: deaa37372f85861b         object.size                       1008
33: deaa37372f85861b            accessed 2023-05-07 07:20:32.249954
34: deaa37372f85861b             inCloud                      FALSE
35: deaa37372f85861b          resultHash                           
36: deaa37372f85861b   elapsedTimeDigest           0.005599499 secs
37: deaa37372f85861b elapsedTimeFirstRun          9.274483e-05 secs
38: deaa37372f85861b      otherFunctions                           
39: deaa37372f85861b           preDigest         n:7eef4eae85fd9229
40: deaa37372f85861b           preDigest       min:c40c00762a0dac94
41: deaa37372f85861b           preDigest       max:853b1797f54b229c
42: deaa37372f85861b           preDigest      .FUN:881ec847b7161f3c
             cacheId              tagKey                   tagValue
                   createdDate
 1:  2023-05-07 07:20:32.31733
 2:  2023-05-07 07:20:32.31733
 3:  2023-05-07 07:20:32.31733
 4:  2023-05-07 07:20:32.31733
 5:  2023-05-07 07:20:32.31733
 6:  2023-05-07 07:20:32.31733
 7:  2023-05-07 07:20:32.31733
 8:  2023-05-07 07:20:32.31733
 9:  2023-05-07 07:20:32.31733
10:  2023-05-07 07:20:32.31733
11:  2023-05-07 07:20:32.31733
12:  2023-05-07 07:20:32.31733
13:  2023-05-07 07:20:32.31733
14:  2023-05-07 07:20:32.31733
15: 2023-05-07 07:20:32.164229
16: 2023-05-07 07:20:32.164229
17: 2023-05-07 07:20:32.164229
18: 2023-05-07 07:20:32.164229
19: 2023-05-07 07:20:32.164229
20: 2023-05-07 07:20:32.164229
21: 2023-05-07 07:20:32.164229
22: 2023-05-07 07:20:32.164229
23: 2023-05-07 07:20:32.164229
24: 2023-05-07 07:20:32.164229
25: 2023-05-07 07:20:32.164229
26: 2023-05-07 07:20:32.164229
27: 2023-05-07 07:20:32.164229
28: 2023-05-07 07:20:32.164229
29:  2023-05-07 07:20:32.25162
30:  2023-05-07 07:20:32.25162
31:  2023-05-07 07:20:32.25162
32:  2023-05-07 07:20:32.25162
33:  2023-05-07 07:20:32.25162
34:  2023-05-07 07:20:32.25162
35:  2023-05-07 07:20:32.25162
36:  2023-05-07 07:20:32.25162
37:  2023-05-07 07:20:32.25162
38:  2023-05-07 07:20:32.25162
39:  2023-05-07 07:20:32.25162
40:  2023-05-07 07:20:32.25162
41:  2023-05-07 07:20:32.25162
42:  2023-05-07 07:20:32.25162
                   createdDate
> showCache(tmpDir, userTags = c("^a$")) # regular expression ... "a" exactly
Cache size: 
  Total (including Rasters): 252 bytes
  Selected objects (not including Rasters): 252 bytes
             cacheId              tagKey                   tagValue
 1: ad0ea27476c50b66          objectName                          a
 2: ad0ea27476c50b66            function                      rnorm
 3: ad0ea27476c50b66               class                    numeric
 4: ad0ea27476c50b66         object.size                       1008
 5: ad0ea27476c50b66            accessed 2023-05-07 07:20:32.162419
 6: ad0ea27476c50b66             inCloud                      FALSE
 7: ad0ea27476c50b66          resultHash                           
 8: ad0ea27476c50b66   elapsedTimeDigest           0.004830599 secs
 9: ad0ea27476c50b66 elapsedTimeFirstRun          0.0001263618 secs
10: ad0ea27476c50b66      otherFunctions                           
11: ad0ea27476c50b66           preDigest         n:7eef4eae85fd9229
12: ad0ea27476c50b66           preDigest      mean:c40c00762a0dac94
13: ad0ea27476c50b66           preDigest        sd:853b1797f54b229c
14: ad0ea27476c50b66           preDigest      .FUN:4f604aa46882b368
                   createdDate
 1: 2023-05-07 07:20:32.164229
 2: 2023-05-07 07:20:32.164229
 3: 2023-05-07 07:20:32.164229
 4: 2023-05-07 07:20:32.164229
 5: 2023-05-07 07:20:32.164229
 6: 2023-05-07 07:20:32.164229
 7: 2023-05-07 07:20:32.164229
 8: 2023-05-07 07:20:32.164229
 9: 2023-05-07 07:20:32.164229
10: 2023-05-07 07:20:32.164229
11: 2023-05-07 07:20:32.164229
12: 2023-05-07 07:20:32.164229
13: 2023-05-07 07:20:32.164229
14: 2023-05-07 07:20:32.164229
> 
> # Fine control of cache elements -- pick out only the large runif object, and remove it
> cache1 <- showCache(tmpDir, userTags = c("runif")) # show only cached objects made during runif
Cache size: 
  Total (including Rasters): 576 bytes
  Selected objects (not including Rasters): 576 bytes
> toRemove <- cache1[tagKey == "object.size"][as.numeric(tagValue) > 700]$cacheId
> clearCache(tmpDir, userTags = toRemove, ask = FALSE)
Cache size: 
  Total (including Rasters): 0 bytes
  Selected objects (not including Rasters): 0 bytes
> cacheAfter <- showCache(tmpDir, userTags = c("runif")) # Only the small one is left
Cache size: 
  Total (including Rasters): 576 bytes
  Selected objects (not including Rasters): 576 bytes
> 
> data.table::setDTthreads(2)
> tmpDir <- file.path(tempdir(), "reproducible_examples", "Cache")
> try(clearCache(tmpDir, ask = FALSE), silent = TRUE) # just to make sure it is clear
> 
> Cache(rnorm, 1, cachePath = tmpDir)
[1] -0.275778
attr(,".Cache")
attr(,".Cache")$newCache
[1] TRUE

attr(,"tags")
[1] "cacheId:422bae4ed2f770cc"
attr(,"call")
[1] ""
> thisTime <- Sys.time()
> Cache(rnorm, 2, cachePath = tmpDir)
[1] 0.5962590 0.1197176
attr(,".Cache")
attr(,".Cache")$newCache
[1] TRUE

attr(,"tags")
[1] "cacheId:66299c88b3924bf4"
attr(,"call")
[1] ""
> Cache(rnorm, 3, cachePath = tmpDir)
[1]  0.04211587 -0.91092165  0.15802877
attr(,".Cache")
attr(,".Cache")$newCache
[1] TRUE

attr(,"tags")
[1] "cacheId:6724ef06570739aa"
attr(,"call")
[1] ""
> Cache(rnorm, 4, cachePath = tmpDir)
[1] -0.41251989 -0.97228684  0.02538287  0.02747534
attr(,".Cache")
attr(,".Cache")$newCache
[1] TRUE

attr(,"tags")
[1] "cacheId:ad0ea27476c50b66"
attr(,"call")
[1] ""
> showCache(x = tmpDir) # shows all 4 entries
Cache size: 
  Total (including Rasters): 998 bytes
  Selected objects (not including Rasters): 998 bytes
             cacheId              tagKey                   tagValue
 1: 422bae4ed2f770cc            function                      rnorm
 2: 422bae4ed2f770cc               class                    numeric
 3: 422bae4ed2f770cc         object.size                        984
 4: 422bae4ed2f770cc            accessed 2023-05-07 07:20:32.676803
 5: 422bae4ed2f770cc             inCloud                      FALSE
 6: 422bae4ed2f770cc          resultHash                           
 7: 422bae4ed2f770cc   elapsedTimeDigest           0.008238077 secs
 8: 422bae4ed2f770cc elapsedTimeFirstRun          0.0002269745 secs
 9: 422bae4ed2f770cc      otherFunctions                           
10: 422bae4ed2f770cc           preDigest         n:853b1797f54b229c
11: 422bae4ed2f770cc           preDigest      mean:c40c00762a0dac94
12: 422bae4ed2f770cc           preDigest        sd:853b1797f54b229c
13: 422bae4ed2f770cc           preDigest      .FUN:4f604aa46882b368
14: 66299c88b3924bf4            function                      rnorm
15: 66299c88b3924bf4               class                    numeric
16: 66299c88b3924bf4         object.size                        992
17: 66299c88b3924bf4            accessed 2023-05-07 07:20:32.815875
18: 66299c88b3924bf4             inCloud                      FALSE
19: 66299c88b3924bf4          resultHash                           
20: 66299c88b3924bf4   elapsedTimeDigest             0.0128541 secs
21: 66299c88b3924bf4 elapsedTimeFirstRun          0.0001885891 secs
22: 66299c88b3924bf4      otherFunctions                           
23: 66299c88b3924bf4           preDigest         n:82dc709f2b91918a
24: 66299c88b3924bf4           preDigest      mean:c40c00762a0dac94
25: 66299c88b3924bf4           preDigest        sd:853b1797f54b229c
26: 66299c88b3924bf4           preDigest      .FUN:4f604aa46882b368
27: 6724ef06570739aa            function                      rnorm
28: 6724ef06570739aa               class                    numeric
29: 6724ef06570739aa         object.size                       1008
30: 6724ef06570739aa            accessed 2023-05-07 07:20:32.976372
31: 6724ef06570739aa             inCloud                      FALSE
32: 6724ef06570739aa          resultHash                           
33: 6724ef06570739aa   elapsedTimeDigest           0.009477377 secs
34: 6724ef06570739aa elapsedTimeFirstRun           0.000166893 secs
35: 6724ef06570739aa      otherFunctions                           
36: 6724ef06570739aa           preDigest         n:7f12988bd88a0fb8
37: 6724ef06570739aa           preDigest      mean:c40c00762a0dac94
38: 6724ef06570739aa           preDigest        sd:853b1797f54b229c
39: 6724ef06570739aa           preDigest      .FUN:4f604aa46882b368
40: ad0ea27476c50b66            function                      rnorm
41: ad0ea27476c50b66               class                    numeric
42: ad0ea27476c50b66         object.size                       1008
43: ad0ea27476c50b66            accessed 2023-05-07 07:20:33.102747
44: ad0ea27476c50b66             inCloud                      FALSE
45: ad0ea27476c50b66          resultHash                           
46: ad0ea27476c50b66   elapsedTimeDigest            0.01147938 secs
47: ad0ea27476c50b66 elapsedTimeFirstRun          0.0001649857 secs
48: ad0ea27476c50b66      otherFunctions                           
49: ad0ea27476c50b66           preDigest         n:7eef4eae85fd9229
50: ad0ea27476c50b66           preDigest      mean:c40c00762a0dac94
51: ad0ea27476c50b66           preDigest        sd:853b1797f54b229c
52: ad0ea27476c50b66           preDigest      .FUN:4f604aa46882b368
             cacheId              tagKey                   tagValue
                   createdDate
 1: 2023-05-07 07:20:32.680215
 2: 2023-05-07 07:20:32.680215
 3: 2023-05-07 07:20:32.680215
 4: 2023-05-07 07:20:32.680215
 5: 2023-05-07 07:20:32.680215
 6: 2023-05-07 07:20:32.680215
 7: 2023-05-07 07:20:32.680215
 8: 2023-05-07 07:20:32.680215
 9: 2023-05-07 07:20:32.680215
10: 2023-05-07 07:20:32.680215
11: 2023-05-07 07:20:32.680215
12: 2023-05-07 07:20:32.680215
13: 2023-05-07 07:20:32.680215
14: 2023-05-07 07:20:32.820708
15: 2023-05-07 07:20:32.820708
16: 2023-05-07 07:20:32.820708
17: 2023-05-07 07:20:32.820708
18: 2023-05-07 07:20:32.820708
19: 2023-05-07 07:20:32.820708
20: 2023-05-07 07:20:32.820708
21: 2023-05-07 07:20:32.820708
22: 2023-05-07 07:20:32.820708
23: 2023-05-07 07:20:32.820708
24: 2023-05-07 07:20:32.820708
25: 2023-05-07 07:20:32.820708
26: 2023-05-07 07:20:32.820708
27: 2023-05-07 07:20:32.979125
28: 2023-05-07 07:20:32.979125
29: 2023-05-07 07:20:32.979125
30: 2023-05-07 07:20:32.979125
31: 2023-05-07 07:20:32.979125
32: 2023-05-07 07:20:32.979125
33: 2023-05-07 07:20:32.979125
34: 2023-05-07 07:20:32.979125
35: 2023-05-07 07:20:32.979125
36: 2023-05-07 07:20:32.979125
37: 2023-05-07 07:20:32.979125
38: 2023-05-07 07:20:32.979125
39: 2023-05-07 07:20:32.979125
40: 2023-05-07 07:20:33.105508
41: 2023-05-07 07:20:33.105508
42: 2023-05-07 07:20:33.105508
43: 2023-05-07 07:20:33.105508
44: 2023-05-07 07:20:33.105508
45: 2023-05-07 07:20:33.105508
46: 2023-05-07 07:20:33.105508
47: 2023-05-07 07:20:33.105508
48: 2023-05-07 07:20:33.105508
49: 2023-05-07 07:20:33.105508
50: 2023-05-07 07:20:33.105508
51: 2023-05-07 07:20:33.105508
52: 2023-05-07 07:20:33.105508
                   createdDate
> cc(ask = FALSE, x = tmpDir)
No time provided; removing the most recent entry to the Cache
Cache size: 
  Total (including Rasters): 252 bytes
  Selected objects (not including Rasters): 252 bytes
> showCache(x = tmpDir) # most recent is gone
Cache size: 
  Total (including Rasters): 746 bytes
  Selected objects (not including Rasters): 746 bytes
             cacheId              tagKey                   tagValue
 1: 422bae4ed2f770cc            function                      rnorm
 2: 422bae4ed2f770cc               class                    numeric
 3: 422bae4ed2f770cc         object.size                        984
 4: 422bae4ed2f770cc            accessed 2023-05-07 07:20:32.676803
 5: 422bae4ed2f770cc             inCloud                      FALSE
 6: 422bae4ed2f770cc          resultHash                           
 7: 422bae4ed2f770cc   elapsedTimeDigest           0.008238077 secs
 8: 422bae4ed2f770cc elapsedTimeFirstRun          0.0002269745 secs
 9: 422bae4ed2f770cc      otherFunctions                           
10: 422bae4ed2f770cc           preDigest         n:853b1797f54b229c
11: 422bae4ed2f770cc           preDigest      mean:c40c00762a0dac94
12: 422bae4ed2f770cc           preDigest        sd:853b1797f54b229c
13: 422bae4ed2f770cc           preDigest      .FUN:4f604aa46882b368
14: 66299c88b3924bf4            function                      rnorm
15: 66299c88b3924bf4               class                    numeric
16: 66299c88b3924bf4         object.size                        992
17: 66299c88b3924bf4            accessed 2023-05-07 07:20:32.815875
18: 66299c88b3924bf4             inCloud                      FALSE
19: 66299c88b3924bf4          resultHash                           
20: 66299c88b3924bf4   elapsedTimeDigest             0.0128541 secs
21: 66299c88b3924bf4 elapsedTimeFirstRun          0.0001885891 secs
22: 66299c88b3924bf4      otherFunctions                           
23: 66299c88b3924bf4           preDigest         n:82dc709f2b91918a
24: 66299c88b3924bf4           preDigest      mean:c40c00762a0dac94
25: 66299c88b3924bf4           preDigest        sd:853b1797f54b229c
26: 66299c88b3924bf4           preDigest      .FUN:4f604aa46882b368
27: 6724ef06570739aa            function                      rnorm
28: 6724ef06570739aa               class                    numeric
29: 6724ef06570739aa         object.size                       1008
30: 6724ef06570739aa            accessed 2023-05-07 07:20:32.976372
31: 6724ef06570739aa             inCloud                      FALSE
32: 6724ef06570739aa          resultHash                           
33: 6724ef06570739aa   elapsedTimeDigest           0.009477377 secs
34: 6724ef06570739aa elapsedTimeFirstRun           0.000166893 secs
35: 6724ef06570739aa      otherFunctions                           
36: 6724ef06570739aa           preDigest         n:7f12988bd88a0fb8
37: 6724ef06570739aa           preDigest      mean:c40c00762a0dac94
38: 6724ef06570739aa           preDigest        sd:853b1797f54b229c
39: 6724ef06570739aa           preDigest      .FUN:4f604aa46882b368
             cacheId              tagKey                   tagValue
                   createdDate
 1: 2023-05-07 07:20:32.680215
 2: 2023-05-07 07:20:32.680215
 3: 2023-05-07 07:20:32.680215
 4: 2023-05-07 07:20:32.680215
 5: 2023-05-07 07:20:32.680215
 6: 2023-05-07 07:20:32.680215
 7: 2023-05-07 07:20:32.680215
 8: 2023-05-07 07:20:32.680215
 9: 2023-05-07 07:20:32.680215
10: 2023-05-07 07:20:32.680215
11: 2023-05-07 07:20:32.680215
12: 2023-05-07 07:20:32.680215
13: 2023-05-07 07:20:32.680215
14: 2023-05-07 07:20:32.820708
15: 2023-05-07 07:20:32.820708
16: 2023-05-07 07:20:32.820708
17: 2023-05-07 07:20:32.820708
18: 2023-05-07 07:20:32.820708
19: 2023-05-07 07:20:32.820708
20: 2023-05-07 07:20:32.820708
21: 2023-05-07 07:20:32.820708
22: 2023-05-07 07:20:32.820708
23: 2023-05-07 07:20:32.820708
24: 2023-05-07 07:20:32.820708
25: 2023-05-07 07:20:32.820708
26: 2023-05-07 07:20:32.820708
27: 2023-05-07 07:20:32.979125
28: 2023-05-07 07:20:32.979125
29: 2023-05-07 07:20:32.979125
30: 2023-05-07 07:20:32.979125
31: 2023-05-07 07:20:32.979125
32: 2023-05-07 07:20:32.979125
33: 2023-05-07 07:20:32.979125
34: 2023-05-07 07:20:32.979125
35: 2023-05-07 07:20:32.979125
36: 2023-05-07 07:20:32.979125
37: 2023-05-07 07:20:32.979125
38: 2023-05-07 07:20:32.979125
39: 2023-05-07 07:20:32.979125
                   createdDate
> cc(thisTime, ask = FALSE, x = tmpDir)
Cache size: 
  Total (including Rasters): 500 bytes
  Selected objects (not including Rasters): 500 bytes
> showCache(x = tmpDir) # all those after thisTime gone, i.e., only 1 left
Cache size: 
  Total (including Rasters): 246 bytes
  Selected objects (not including Rasters): 246 bytes
             cacheId              tagKey                   tagValue
 1: 422bae4ed2f770cc            function                      rnorm
 2: 422bae4ed2f770cc               class                    numeric
 3: 422bae4ed2f770cc         object.size                        984
 4: 422bae4ed2f770cc            accessed 2023-05-07 07:20:32.676803
 5: 422bae4ed2f770cc             inCloud                      FALSE
 6: 422bae4ed2f770cc          resultHash                           
 7: 422bae4ed2f770cc   elapsedTimeDigest           0.008238077 secs
 8: 422bae4ed2f770cc elapsedTimeFirstRun          0.0002269745 secs
 9: 422bae4ed2f770cc      otherFunctions                           
10: 422bae4ed2f770cc           preDigest         n:853b1797f54b229c
11: 422bae4ed2f770cc           preDigest      mean:c40c00762a0dac94
12: 422bae4ed2f770cc           preDigest        sd:853b1797f54b229c
13: 422bae4ed2f770cc           preDigest      .FUN:4f604aa46882b368
                   createdDate
 1: 2023-05-07 07:20:32.680215
 2: 2023-05-07 07:20:32.680215
 3: 2023-05-07 07:20:32.680215
 4: 2023-05-07 07:20:32.680215
 5: 2023-05-07 07:20:32.680215
 6: 2023-05-07 07:20:32.680215
 7: 2023-05-07 07:20:32.680215
 8: 2023-05-07 07:20:32.680215
 9: 2023-05-07 07:20:32.680215
10: 2023-05-07 07:20:32.680215
11: 2023-05-07 07:20:32.680215
12: 2023-05-07 07:20:32.680215
13: 2023-05-07 07:20:32.680215
> cc(ask = FALSE, x = tmpDir) # Cache is
No time provided; removing the most recent entry to the Cache
Cache size: 
  Total (including Rasters): 246 bytes
  Selected objects (not including Rasters): 246 bytes
> cc(ask = FALSE, x = tmpDir) # Cache is already empty
No time provided; removing the most recent entry to the Cache
Cache already empty
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  171.132 9.023 188.422 0.031 0.055 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
