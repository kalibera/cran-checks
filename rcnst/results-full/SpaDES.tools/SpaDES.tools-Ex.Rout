
R Under development (unstable) (2022-07-27 r82635) -- "Unsuffered Consequences"
Copyright (C) 2022 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "SpaDES.tools"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('SpaDES.tools')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("adj")
> ### * adj
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: adj
> ### Title: Fast 'adjacent' function, and Just In Time compiled version
> ### Aliases: adj
> 
> ### ** Examples
> 
> library(raster)
Loading required package: sp
> a <- raster(extent(0, 1000, 0, 1000), res = 1)
> sam <- sample(1:length(a), 1e4)
> numCol <- ncol(a)
> numCell <- ncell(a)
> adj.new <- adj(numCol = numCol, numCell = numCell, cells = sam, directions = 8)
> adj.new <- adj(numCol = numCol, numCell = numCell, cells = sam, directions = 8,
+                include = TRUE)
> 
> 
> 
> 
> cleanEx()

detaching ‘package:raster’, ‘package:sp’

> nameEx("cir")
> ### * cir
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cir
> ### Title: Identify pixels in a circle or ring (donut) around an object.
> ### Aliases: cir
> 
> ### ** Examples
> 
> library(data.table)
> library(sp)
> library(raster)
> library(quickPlot)
> 
> set.seed(1462)
> 
> if (require(RandomFields)) {
+   # circle centred
+   ras <- raster(extent(0, 15, 0, 15), res = 1, val = 0)
+   middleCircle <- cir(ras)
+   ras[middleCircle[, "indices"]] <- 1
+   circlePoints <- SpatialPoints(middleCircle[, c("x", "y")])
+   if (interactive()) {
+     clearPlot()
+     Plot(ras)
+     Plot(circlePoints, addTo = "ras")
+   }
+ 
+   # circles non centred
+   ras <- randomPolygons(ras, numTypes = 4)
+   n <- 2
+   agent <- SpatialPoints(coords = cbind(x = stats::runif(n, xmin(ras), xmax(ras)),
+                                         y = stats::runif(n, xmin(ras), xmax(ras))))
+ 
+   cirs <- cir(ras, agent, maxRadius = 15, simplify = TRUE) ## TODO: empty with some seeds! e.g. 1642
+   cirsSP <- SpatialPoints(coords = cirs[, c("x", "y")]) ## TODO: error with some seeds! e.g. 1642
+   cirsRas <- raster(ras)
+   cirsRas[] <- 0
+   cirsRas[cirs[, "indices"]] <- 1
+ 
+   if (interactive()) {
+     clearPlot()
+     Plot(ras)
+     Plot(cirsRas, addTo = "ras", cols = c("transparent", "#00000055"))
+     Plot(agent, addTo = "ras")
+     Plot(cirsSP, addTo = "ras")
+   }
+ 
+   # Example comparing rings and cir
+   a <- raster(extent(0, 30, 0, 30), res = 1)
+   hab <- gaussMap(a, speedup = 1) # if raster is large (>1e6 pixels) use speedup > 1
+   radius <- 4
+   n <- 2
+   coords <- SpatialPoints(coords = cbind(x = stats::runif(n, xmin(hab), xmax(hab)),
+                                          y = stats::runif(n, xmin(hab), xmax(hab))))
+ 
+   # cirs
+   cirs <- cir(hab, coords, maxRadius = rep(radius, length(coords)), simplify = TRUE)
+ 
+   # rings
+   loci <- cellFromXY(hab, coordinates(coords))
+   cirs2 <- rings(hab, loci, maxRadius = radius, minRadius = radius - 1, returnIndices = TRUE)
+ 
+   # Plot both
+   ras1 <- raster(hab)
+   ras1[] <- 0
+   ras1[cirs[, "indices"]] <- cirs[, "id"]
+ 
+   ras2 <- raster(hab)
+   ras2[] <- 0
+   ras2[cirs2$indices] <- cirs2$id
+   if (interactive()) {
+     clearPlot()
+     Plot(ras1, ras2)
+   }
+ 
+   a <- raster(extent(0, 100, 0, 100), res = 1)
+   hab <- gaussMap(a, speedup = 1)
+   cirs <- cir(hab, coords, maxRadius = 44, minRadius = 0)
+   ras1 <- raster(hab)
+   ras1[] <- 0
+   cirsOverlap <- data.table(cirs)[, list(sumIDs = sum(id)), by = indices]
+   ras1[cirsOverlap$indices] <- cirsOverlap$sumIDs
+   if (interactive()) {
+     clearPlot()
+     Plot(ras1)
+   }
+ 
+   # Provide a specific set of angles
+   ras <- raster(extent(0, 330, 0, 330), res = 1)
+   ras[] <- 0
+   n <- 2
+   coords <- cbind(x = stats::runif(n, xmin(ras), xmax(ras)),
+                   y = stats::runif(n, xmin(ras), xmax(ras)))
+   circ <- cir(ras, coords, angles = seq(0, 2 * pi, length.out = 21),
+               maxRadius = 200, minRadius = 0, returnIndices = FALSE,
+               allowOverlap = TRUE, returnAngles = TRUE)
+ }
Loading required package: RandomFields
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘RandomFields’
> 
> 
> 
> cleanEx()

detaching ‘package:quickPlot’, ‘package:raster’, ‘package:sp’,
  ‘package:data.table’

> nameEx("directions")
> ### * directions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: directionFromEachPoint
> ### Title: Calculate distances and directions between many points and many
> ###   grid cells
> ### Aliases: directionFromEachPoint .pointDirection
> ### Keywords: internal
> 
> ### ** Examples
> 
> library(raster)
Loading required package: sp
> library(quickPlot)
> 
> N <- 2
> dirRas <- raster(extent(0,40,0,40), res = 1)
> coords <- cbind(x = round(runif(N, xmin(dirRas), xmax(dirRas))) + 0.5,
+                 y = round(runif(N, xmin(dirRas), xmax(dirRas))) + 0.5,
+                 id = 1:N)
> 
> dirs1 <- directionFromEachPoint(from = coords, landscape = dirRas)
> library(CircStats)
Loading required package: MASS

Attaching package: ‘MASS’

The following objects are masked from ‘package:raster’:

    area, select

Loading required package: boot
> dirs1[, "angles"] <- deg(dirs1[,"angles"] %% (2*pi))
> indices <- cellFromXY(dirRas,dirs1[, c("x", "y")])
> minDir <- tapply(dirs1[, "angles"], indices, function(x) min(x)) # minimum angle
> dirRas[] <- as.vector(minDir)
> if (interactive()) {
+   clearPlot()
+   Plot(dirRas)
+   library(sp)
+   start <- SpatialPoints(coords[, c("x", "y"), drop = FALSE])
+   Plot(start, addTo = "dirRas")
+ }
> 
> 
> 
> cleanEx()

detaching ‘package:CircStats’, ‘package:boot’, ‘package:MASS’,
  ‘package:quickPlot’, ‘package:raster’, ‘package:sp’

> nameEx("distanceFromEachPoint")
> ### * distanceFromEachPoint
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: distanceFromEachPoint
> ### Title: Calculate distances and directions between many points and many
> ###   grid cells
> ### Aliases: distanceFromEachPoint
> 
> ### ** Examples
> 
> library(raster)
Loading required package: sp
> library(quickPlot)
> 
> n <- 2
> distRas <- raster(extent(0, 40, 0, 40), res = 1)
> coords <- cbind(x = round(runif(n, xmin(distRas), xmax(distRas))) + 0.5,
+                 y = round(runif(n, xmin(distRas), xmax(distRas))) + 0.5)
> 
> # inverse distance weights
> dists1 <- distanceFromEachPoint(coords, landscape = distRas)
> indices <- cellFromXY(distRas, dists1[, c("x", "y")])
> invDist <- tapply(dists1[, "dists"], indices, function(x) sum(1 / (1 + x))) # idw function
> distRas[] <- as.vector(invDist)
> if (interactive()) {
+   clearPlot()
+   Plot(distRas)
+ }
> 
> # With iterative summing via cumulativeFn to keep memory use low, with same result
> dists1 <- distanceFromEachPoint(coords[, c("x", "y"), drop = FALSE],
+                                 landscape = distRas, cumulativeFn = `+`)
> idwRaster <- raster(distRas)
> idwRaster[] <- dists1[, "dists"]
> if (interactive()) Plot(idwRaster)
> 
> all(idwRaster[] == distRas[]) # TRUE
[1] TRUE
> 
> # A more complex example of cumulative inverse distance sums, weighted by the value
> #  of the origin cell
> ras <- raster(extent(0, 34, 0, 34), res = 1, val = 0)
> rp <- randomPolygons(ras, numTypes = 10) ^ 2
> n <- 15
> cells <- sample(ncell(ras), n)
> coords <- xyFromCell(ras, cells)
> distFn <- function(landscape, fromCell, dist) landscape[fromCell] / (1 + dist)
> 
> #beginCluster(3) # can do parallel
> dists1 <- distanceFromEachPoint(coords[, c("x", "y"), drop = FALSE],
+                                 landscape = rp, distFn = distFn, cumulativeFn = `+`)
> #endCluster() # if beginCluster was run
> 
> idwRaster <- raster(ras)
> idwRaster[] <- dists1[, "dists"]
> if (interactive()) {
+   clearPlot()
+   Plot(rp, idwRaster)
+   sp1 <- SpatialPoints(coords)
+   Plot(sp1, addTo = "rp")
+   Plot(sp1, addTo = "idwRaster")
+ }
> 
> # On linux; can use numeric passed to cl; will use mclapply with mc.cores = cl
> if (identical(Sys.info()["sysname"], "Linux")) {
+   dists1 <- distanceFromEachPoint(coords[, c("x", "y"), drop = FALSE],
+                                   landscape = rp, distFn = distFn,
+                                   cumulativeFn = `+`, cl = 2)
+ }
> 
> 
> 
> cleanEx()

detaching ‘package:quickPlot’, ‘package:raster’, ‘package:sp’

> nameEx("dwrpnorm2")
> ### * dwrpnorm2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dwrpnorm2
> ### Title: Vectorized wrapped normal density function
> ### Aliases: dwrpnorm2
> 
> ### ** Examples
> 
> # Values for which to evaluate density
> theta <- c(1:500) * 2 * pi / 500
> # Compute wrapped normal density function
> density <- c(1:500)
> for(i in 1:500) density[i] <- dwrpnorm2(theta[i], pi, .75)
> if (interactive()) plot(theta, density)
> # Approximate area under density curve
> sum(density * 2 * pi / 500)
[1] 1
> 
> 
> 
> 
> cleanEx()
> nameEx("gaussMap")
> ### * gaussMap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gaussMap
> ### Title: Produce a 'raster' of a random Gaussian process.
> ### Aliases: gaussMap
> 
> ### ** Examples
> 
> ## Not run: 
> ##D if (require(RandomFields)) {
> ##D   library(raster)
> ##D   nx <- ny <- 100L
> ##D   r <- raster(nrows = ny, ncols = nx, xmn = -nx/2, xmx = nx/2, ymn = -ny/2, ymx = ny/2)
> ##D   speedup <- max(1, nx/5e2)
> ##D   map1 <- gaussMap(r, scale = 300, var = 0.03, speedup = speedup, inMemory = TRUE)
> ##D   if (interactive()) Plot(map1)
> ##D 
> ##D   # with non-default method
> ##D   map1 <- gaussMap(r, scale = 300, var = 0.03, method = "RMgauss")
> ##D }
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("heading")
> ### * heading
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: heading
> ### Title: Heading between spatial points.
> ### Aliases: heading heading,SpatialPoints,SpatialPoints-method
> ###   heading,matrix,matrix-method heading,matrix,SpatialPoints-method
> ###   heading,SpatialPoints,matrix-method
> 
> ### ** Examples
> 
> library(sp)
> N <- 10L                # number of agents
> x1 <- stats::runif(N, -50, 50) # previous X location
> y1 <- stats::runif(N, -50, 50) # previous Y location
> x0 <- stats::rnorm(N, x1, 5)   # current X location
> y0 <- stats::rnorm(N, y1, 5)   # current Y location
> 
> # using SpatialPoints
> prev <- SpatialPoints(cbind(x = x1, y = y1))
> curr <- SpatialPoints(cbind(x = x0, y = y0))
> heading(prev, curr)
 [1]  58.70553  26.49322 276.84424 228.06827  61.14567 218.67886 185.93288
 [8] 147.31021 120.20979  54.86510
> 
> # using matrix
> prev <- matrix(c(x1, y1), ncol = 2, dimnames = list(NULL, c("x","y")))
> curr <- matrix(c(x0, y0), ncol = 2, dimnames = list(NULL, c("x","y")))
> heading(prev, curr)
 [1]  58.70553  26.49322 276.84424 228.06827  61.14567 218.67886 185.93288
 [8] 147.31021 120.20979  54.86510
> 
> #using both
> prev <- SpatialPoints(cbind(x = x1, y = y1))
> curr <- matrix(c(x0, y0), ncol = 2, dimnames = list(NULL, c("x","y")))
> heading(prev, curr)
 [1]  58.70553  26.49322 276.84424 228.06827  61.14567 218.67886 185.93288
 [8] 147.31021 120.20979  54.86510
> 
> prev <- matrix(c(x1, y1), ncol = 2, dimnames = list(NULL, c("x","y")))
> curr <- SpatialPoints(cbind(x = x0, y = y0))
> heading(prev, curr)
 [1]  58.70553  26.49322 276.84424 228.06827  61.14567 218.67886 185.93288
 [8] 147.31021 120.20979  54.86510
> 
> 
> 
> 
> cleanEx()

detaching ‘package:sp’

> nameEx("inRange")
> ### * inRange
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: inRange
> ### Title: Test whether a number lies within range '[a,b]'
> ### Aliases: inRange
> 
> ### ** Examples
> 
> set.seed(100)
> x <- stats::rnorm(4) # -0.50219235  0.13153117 -0.07891709  0.88678481
> inRange(x, 0, 1)
[1] FALSE  TRUE FALSE  TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("initiateAgents")
> ### * initiateAgents
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: initiateAgents
> ### Title: 'SELES' - Initiate agents
> ### Aliases: initiateAgents
> ###   initiateAgents,Raster,missing,missing,ANY,missing-method
> ###   initiateAgents,Raster,missing,Raster,ANY,missing-method
> ###   initiateAgents,Raster,numeric,missing,ANY,missing-method
> ###   initiateAgents,Raster,numeric,Raster,ANY,missing-method
> ###   initiateAgents,Raster,missing,missing,ANY,numeric-method
> 
> ### ** Examples
> 
> if (require(RandomFields)) {
+   library(magrittr)
+   library(raster)
+   library(quickPlot)
+ 
+   map <- raster(xmn = 0, xmx = 10, ymn = 0, ymx = 10, val = 0, res = 1)
+   map <- gaussMap(map, scale = 1, var = 4, speedup = 1)
+   pr <- probInit(map, p = (map/maxValue(map))^2)
+   agents <- initiateAgents(map, 100, pr)
+   if (interactive()) {
+     clearPlot()
+     Plot(map)
+     Plot(agents, addTo = "map")
+   }
+   # Test that they are indeed selecting according to probabilities in pr
+   library(data.table)
+   dt1 <- data.table(table(round(map[agents], 0)))
+   setnames(dt1, old = "N", new = "count")
+   dt2 <- data.table(table(round(map[], 0)))
+   setnames(dt2, old = "N", new = "available")
+   dt <-dt1[dt2, on = "V1"]  # join the counts and available data.tables
+   setnames(dt, old = "V1", new = "mapValue")
+   dt[, selection := count/available]
+   dt[is.na(selection), selection := 0]
+   if (interactive())
+     with(dt, {plot(mapValue, selection)})
+   #'
+   # Note, can also produce a Raster representing agents,
+   # then the number of points produced can't be more than
+   # the number of pixels:
+   agentsRas <- initiateAgents(map, 30, pr, asSpatialPoints = FALSE)
+   if (interactive()) Plot(agentsRas)
+   #'
+   if (require(dplyr) && getRversion() >= 3.4) {
+     # Check that the agents are more often at the higher probability areas based on pr
+     if (utils::packageVersion("raster") >= "2.8-11") {
+       out <- data.frame(stats::na.omit(crosstab(agentsRas, map)), table(round(map[]))) %>%
+                dplyr::mutate(selectionRatio = Freq / Freq.1) %>%
+                dplyr::select(-layer.1, -Var1) %>%
+                dplyr::rename(Present = Freq, Avail = Freq.1, Type = layer.2)
+     } else {
+       out <- data.frame(stats::na.omit(crosstab(agentsRas, map)), table(round(map[]))) %>%
+                dplyr::mutate(selectionRatio = Freq/Freq.1) %>%
+                dplyr::select(-Var1, -Var1.1) %>%
+                dplyr::rename(Present = Freq, Avail = Freq.1, Type = Var2)
+     }
+     out
+   }
+ }
Loading required package: RandomFields
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘RandomFields’
> 
> 
> 
> cleanEx()
> nameEx("randomPolygons")
> ### * randomPolygons
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: randomPolygons
> ### Title: Produce a 'RasterLayer' of random polygons
> ### Aliases: randomPolygons randomPolygon randomPolygon.SpatialPoints
> ###   randomPolygon.matrix randomPolygon.SpatialPolygons
> 
> ### ** Examples
> 
> library(quickPlot)
> 
> set.seed(1234)
> Ras <- randomPolygons(numTypes = 5)
> if (interactive()) {
+   clearPlot()
+   Plot(Ras, cols = c("yellow", "dark green", "blue", "dark red"))
+ }
> 
> library(raster)
Loading required package: sp
> # more complex patterning, with a range of patch sizes
> a <- randomPolygons(numTypes = 400, raster(extent(0, 50, 0, 50), res = 1, vals = 0))
duplicate initial loci are provided
> a[a < 320] <- 0
ERROR: modification of compiler constant of type character, length 4
ERROR: the modified value of the constant is:
[1] "includePixel" "excludePixel" "includeRing"  "excludeRing" 
attr(,".match.hash")
<hash table>
ERROR: the original value of the constant is:
[1] "includePixel" "excludePixel" "includeRing"  "excludeRing" 
ERROR: the modified constant is at index 40
ERROR: the modified constant is in this function body:
{
    if (!is.null(neighProbs)) {
        if (isTRUE(allowOverlap)) 
            stop("Can't use neighProbs and allowOverlap = TRUE together")
    }
    if (requireNamespace("dqrng", quietly = TRUE)) {
        samInt <- dqrng::dqsample.int
        dqrng::dqset.seed(sample.int(1e+09, 2))
    }
    else {
        samInt <- sample.int
    }
    if (!is.null(mapID)) {
        warning("mapID is deprecated, use id")
        id <- mapID
    }
    if (!quick) {
        allowedRules <- c("includePixel", "excludePixel", "includeRing", 
            "excludeRing")
        if (!any(stopRuleBehavior %fin% allowedRules)) 
            stop("stopRuleBehaviour must be one of \"", paste(allowedRules, 
                collapse = "\", \""), "\".")
    }
    if (isTRUE(lowMemory)) {
        requireNamespace("ff", quietly = TRUE)
        requireNamespace("ffbase", quietly = TRUE)
    }
    spreadStateExists <- is(spreadState, "data.table")
    spreadProbLaterExists <- TRUE
    if (!is(spreadProbLater, "Raster")) {
        if (anyNA(spreadProbLater)) {
            spreadProbLaterExists <- FALSE
            spreadProbLater <- spreadProb
        }
    }
    if (any(is.na(loci))) {
        if (!spreadStateExists) 
            loci <- middlePixel(landscape)
    }
    if (!is.integer(loci)) {
        loci <- as.integer(loci)
    }
    if (!quick) {
        dupLoci <- duplicated(loci)
        if (any(duplicated(loci))) {
            message("duplicate initial loci are provided")
        }
    }
    if (length(loci) == 0) 
        stop("No loci. Nothing to do")
    if (any(!is.na(maxSize))) {
        msEqZero <- maxSize < 1
        if (any(msEqZero)) {
            loci <- loci[!msEqZero]
            maxSize <- maxSize[!msEqZero]
        }
    }
    if (spreadStateExists) {
        keepers <- spreadState$active == TRUE
        loci <- initialActiveCells <- spreadState[keepers, indices]
        initialLoci <- unique(spreadState$initialLocus)
    }
    else {
        initialLoci <- loci
    }
    lenInitialLoci <- length(initialLoci)
    sequenceInitialLoci <- seq(lenInitialLoci)
    if (!quick) {
        if (is(spreadProbLater, "RasterLayer") | is(spreadProb, 
            "Rasterlayer")) {
            if ((minValue(spreadProb) > 1L) || (maxValue(spreadProb) < 
                0L) || (maxValue(spreadProb) > 1L) || (minValue(spreadProb) < 
                0L)) {
                relativeSpreadProb <- TRUE
            }
            if (spreadProbLaterExists) 
                if (((minValue(spreadProbLater) > 1L) || (maxValue(spreadProbLater) < 
                  0L) || (maxValue(spreadProbLater) > 1L) || 
                  (minValue(spreadProbLater) < 0L))) {
                  relativeSpreadProb <- TRUE
                }
        }
        else {
            if (!all(inRange(na.omit(spreadProb)))) {
                relativeSpreadProb <- TRUE
                stop("spreadProb is not a probability")
            }
            if (spreadProbLaterExists) {
                relativeSpreadProb <- TRUE
                if (!all(inRange(na.omit(spreadProbLater)))) 
                  stop("spreadProbLater is not a probability")
            }
        }
    }
    ncells <- as.integer(ncell(landscape))
    allowOverlapOrReturnDistances <- allowOverlap | returnDistances
    useMatrixVersionSpreads <- allowOverlapOrReturnDistances | 
        spreadStateExists
    if (useMatrixVersionSpreads) {
        if (spreadStateExists) {
            spreads <- as.matrix(spreadState[, list(initialLocus, 
                indices, id, active)])
        }
        else {
            spreads <- cbind(initialLocus = initialLoci, indices = initialLoci, 
                id = 1:length(loci), active = 1)
        }
    }
    else {
        if (!is.null(lowMemory)) {
            message("lowMemory argument is now deprecated; using standard spread")
        }
        needEmptySpreads <- TRUE
        stNamespace <- asNamespace("SpaDES.tools")
        if (exists("spreadsDTInNamespace", envir = stNamespace)) {
            spreadsDT <- getFromNamespace("spreadsDTInNamespace", 
                "SpaDES.tools")
            if (identical(NROW(spreadsDT), ncells)) {
                needEmptySpreads <- FALSE
            }
        }
        if (needEmptySpreads) {
            spreadsDT <- data.table(spreads = vector("integer", 
                ncells))
            set(spreadsDT, NULL, "spreads", 0L)
            assignInMyNamespace("spreadsDTInNamespace", spreadsDT)
            on.exit({
                assignInMyNamespace("spreadsDTInNamespace", integer())
            })
        }
    }
    n <- 1L
    if (circle | !is.na(asymmetry)) {
        if (circle) 
            directions <- 8L
        initialLociXY <- cbind(id = seq_along(initialLoci), xyFromCell(landscape, 
            initialLoci))
        id <- TRUE
        if (allowOverlapOrReturnDistances) {
            spreads <- cbind(spreads, dists = 0)
        }
    }
    otherVars <- list(...)
    anyList <- unlist(lapply(otherVars, is.list))
    if (any(anyList)) {
        otherVarsLists <- unlist(unname(otherVars), recursive = FALSE)
        otherVars[anyList] <- NULL
        otherVars <- append(otherVars, otherVarsLists)
    }
    if (is.function(stopRule)) {
        id <- TRUE
        stopRuleObjs <- names(formals(stopRule))
        if (!quick) {
            if (any(is.na(match(stopRuleObjs, c("id", "landscape", 
                "cells", names(otherVars)))))) {
                stop("Arguments in stopRule not valid.\n", "The function definition must be a function of built-in options,", 
                  " (id, landscape, or cells) or user supplied variables.", 
                  " If user supplied, the variables", " must be passed as named vectors, or lists or data.frames.", 
                  " See examples.")
            }
        }
        landRasNeeded <- any(stopRuleObjs == "landscape")
        colNamesPotentials <- c("id", "landscape"[landRasNeeded], 
            "cells", "prev")
        argNames <- c(colNamesPotentials, names(otherVars))
        whArgs <- match(names(formals(stopRule)), argNames)
        rasters <- unlist(lapply(otherVars[names(otherVars)], 
            function(x) is(x, "Raster")))
        if (any(rasters)) {
            for (i in 1:which(rasters)) {
                otherVars[[names(rasters[i])]] <- otherVars[[names(rasters[i])]][]
            }
        }
        landRas <- landscape[]
    }
    if (!allowOverlap && !returnDistances) {
        if (id | returnIndices > 0 | relativeSpreadProb) {
            if (!spreadStateExists) {
                set(spreadsDT, loci, "spreads", 1L:length(loci))
            }
        }
        else {
            spreadsDT$spreads[loci] <- n
        }
        spreadsIndices <- unname(loci)
        length(spreadsIndices) <- length(loci) * 100
        prevSpreadIndicesActiveLen <- length(loci)
        prevSpreadIndicesFullLen <- length(spreadsIndices)
    }
    if (is(spreadProb, "Raster")) {
    }
    else if (is.numeric(spreadProb)) {
        if (is(mask, "Raster")) {
            spreadProb <- raster(extent(landscape), res = res(landscape), 
                vals = spreadProb)
        }
    }
    if (is(spreadProbLater, "Raster")) {
    }
    else if (is.numeric(spreadProbLater)) {
        if (is(mask, "Raster")) {
            spreadProbLater <- raster(extent(landscape), res = res(landscape), 
                vals = spreadProbLater)
        }
    }
    if (is(mask, "Raster")) {
        spreadProbLater[mask[] == 1L] <- 0L
        spreadProb[mask[] == 1L] <- 0L
    }
    if (spreadStateExists) {
        if (allowOverlapOrReturnDistances) {
            stop("Using spreadState with either allowOverlap = TRUE", 
                " or returnDistances = TRUE is not implemented")
        }
        else {
            if (sum(colnames(spreadState) %fin% c("indices", 
                "id", "active", "initialLocus")) != 4) {
                stop("spreadState must have at least columns: ", 
                  "indices, id, active, and initialLocus.")
            }
        }
    }
    if (!quick) {
        if (any(loci > ncells)) 
            stop("loci indices are not on landscape")
    }
    if (any(!is.na(maxSize))) {
        if (!is.integer(maxSize)) 
            maxSize <- floor(maxSize)
        if (spreadStateExists) {
            sizeAll <- spreadState[, list(len = .N), by = id]
            size <- c(sizeAll[, len])
        }
        else {
            maxSize <- rep_len(maxSize, length(loci))
            size <- rep_len(1L, length(loci))
        }
    }
    else {
        maxSize <- ncells
        size <- length(loci)
    }
    noMaxSize <- all(maxSize >= ncells)
    if (is.null(neighProbs)) {
        numNeighs <- NULL
    }
    if (!exists("numRetries", envir = .pkgEnv)) {
        assign("numRetries", rep(0, lenInitialLoci), envir = .pkgEnv)
    }
    toColumn <- c("to", "indices")
    while (length(loci) & (n <= iterations)) {
        if (!is.null(neighProbs)) {
            numNeighs <- if (is.list(neighProbs)) {
                unlist(lapply(neighProbs, function(x) {
                  sample.int(length(x), size = 1, replace = TRUE, 
                    prob = x)
                }))
            }
            else {
                sample.int(length(neighProbs), size = length(loci), 
                  replace = TRUE, prob = neighProbs)
            }
        }
        if (useMatrixVersionSpreads) {
            whActive <- spreads[, "active"] == 1
            potentials <- adj(landscape, loci, directions, pairs = TRUE, 
                id = spreads[whActive, "id"])
            spreads[whActive, "active"] <- 0
            potentials <- cbind(potentials, active = 1)
        }
        else {
            if (id | returnIndices > 0 | circle | relativeSpreadProb | 
                !is.null(neighProbs)) {
                potentials <- adj(landscape, loci, directions, 
                  pairs = TRUE)
            }
            else {
                newAdj <- adj(landscape, loci, directions, pairs = FALSE)
                potentials <- cbind(NA_integer_, newAdj)
            }
        }
        if (circle) {
            potentials <- cbind(potentials, dists = 0)
        }
        if (useMatrixVersionSpreads) {
            if (NROW(potentials) > 2000) {
                spreadsDT <- as.data.table(spreads)
                potentialsDT <- as.data.table(potentials)
                potentialsDT[, `:=`(initialLocus, initialLoci[potentialsDT$id])]
                colnamesPot <- colnames(potentialsDT)
                whIL <- which(colnamesPot == "initialLocus")
                whFrom <- which(colnamesPot == "from")
                setcolorder(potentialsDT, c(colnamesPot[whIL], 
                  colnamesPot[-c(whIL, whFrom)], colnamesPot[whFrom]))
                setnames(potentialsDT, old = "to", new = "indices")
                newPot <- potentialsDT[!spreadsDT, on = c("id", 
                  "indices")]
                potentials <- as.matrix(newPot)
            }
            else {
                potentials <- cbind(initialLocus = initialLoci[potentials[, 
                  "id"]], potentials)
                colnames(potentials)[which(colnames(potentials) == 
                  "to")] <- "indices"
                colnamesPot <- colnames(potentials)
                whIL <- which(colnamesPot == "initialLocus")
                whFrom <- which(colnamesPot == "from")
                potentials <- potentials[, c(colnamesPot[whIL], 
                  colnamesPot[-c(whIL, whFrom)], colnamesPot[whFrom])]
                seq2 <- sequenceInitialLoci[sequenceInitialLoci %in% 
                  potentials[, "id"]]
                out <- lapply(seq2, function(ind) {
                  hasID <- potentials[, "id"] == ind
                  po <- potentials[hasID, ]
                  hasID2 <- spreads[, "id"] == ind
                  inds <- spreads[hasID2, "indices"]
                  vals <- po[, 2L] %in% inds
                  po[!vals, ]
                })
                potentials <- do.call(rbind, out)
            }
        }
        else {
            keep <- spreadsDT$spreads[potentials[, 2L]] == 0L
            potentials <- potentials[keep, , drop = FALSE]
        }
        if (n == 2) {
            spreadProb <- spreadProbLater
        }
        if (is.numeric(spreadProb)) {
            if (!(length(spreadProb) == 1 || length(spreadProb) == 
                ncell(landscape))) 
                stop("spreadProb must be length 1 or length ncell(landscape), or a raster")
            if (n == 1 & spreadProbLaterExists) {
                spreadProbs <- rep(spreadProb, NROW(potentials))
                spreadProb <- spreadProbLater
            }
            else {
                if (length(spreadProb) > 1) {
                  spreadProbs <- spreadProb[potentials[, 2L]]
                }
                else {
                  spreadProbs <- rep(spreadProb, NROW(potentials))
                }
            }
        }
        else {
            if (n == 1 & spreadProbLaterExists) {
                spreadProbs <- spreadProb[][potentials[, 2L]]
                spreadProb <- spreadProbLater
            }
            else {
                spreadProbs <- spreadProb[][potentials[, 2L]]
            }
        }
        if (anyNA(spreadProbs)) 
            spreadProbs[is.na(spreadProbs)] <- 0
        if (!is.na(asymmetry)) {
            if (allowOverlapOrReturnDistances) {
                a <- cbind(id = potentials[, 3L], to = potentials[, 
                  2L], xyFromCell(landscape, potentials[, 2L]))
            }
            else {
                if (useMatrixVersionSpreads) {
                  a <- cbind(id = spreads[potentials[, 1L]], 
                    to = potentials[, 2L], xyFromCell(landscape, 
                      potentials[, 2L]))
                }
                else {
                  a <- cbind(id = spreadsDT$spreads[potentials[, 
                    1L]], to = potentials[, 2L], xyFromCell(landscape, 
                    potentials[, 2L]))
                }
            }
            d <- directionFromEachPoint(from = initialLociXY, 
                to = a)
            newSpreadProbExtremes <- (spreadProb[] * 2)/(asymmetry + 
                1) * c(1, asymmetry)
            angleQuality <- (cos(d[, "angles"] - rad(asymmetryAngle)) + 
                1)/2
            spreadProbs <- newSpreadProbExtremes[1] + (angleQuality * 
                diff(newSpreadProbExtremes))
            spreadProbs <- spreadProbs - diff(c(spreadProb[], 
                mean(spreadProbs)))
        }
        if (!is.null(neighProbs) | relativeSpreadProb) {
            aaa <- split(seq_along(potentials[, toColumn[spreadStateExists + 
                1]]), potentials[, "from"])
            if (length(aaa) != length(numNeighs)) {
                activeCellContinue <- loci %in% unique(potentials[, 
                  "from"])
                numNeighs <- numNeighs[activeCellContinue]
            }
            tmpA <- unlist(lapply(aaa, length))
            tmpB <- which(tmpA < numNeighs)
            if (length(tmpB) > 0) 
                numNeighs[tmpB] <- unname(tmpA[tmpB])
            if (relativeSpreadProb) {
                rescaledProbs <- tapply(spreadProbs, potentials[, 
                  "from"], function(x) {
                  x/sum(x, na.rm = TRUE)
                }, simplify = FALSE)
                neighIndexToKeep <- unlist(lapply(seq_along(aaa), 
                  function(x) resample(aaa[[x]], size = numNeighs[x], 
                    prob = rescaledProbs[[x]])))
            }
            else {
                neighIndexToKeep <- unlist(lapply(seq_along(aaa), 
                  function(x) resample(aaa[[x]], size = numNeighs[x])))
            }
            potentials <- potentials[neighIndexToKeep, , drop = FALSE]
            spreadProbs <- spreadProbs[neighIndexToKeep]
            spreadProbs[spreadProbs > 0] <- 1
        }
        randomSuccesses <- runifC(NROW(potentials)) <= spreadProbs
        potentials <- potentials[randomSuccesses, , drop = FALSE]
        lenPot <- NROW(potentials)
        if (lenPot) {
            reorderVals <- samInt(lenPot)
            potentials <- potentials[reorderVals, , drop = FALSE]
        }
        if (!allowOverlap) {
            potentials <- potentials[!duplicated(potentials[, 
                2L]), , drop = FALSE]
        }
        else {
            pots <- potentials[, c("id", "indices"), drop = FALSE]
            potentials <- potentials[!duplicated(pots), , drop = FALSE]
        }
        n <- n + 1L
        if (length(potentials) > 0) {
            if (!missing(circle)) {
                if (circle) {
                  if (allowOverlapOrReturnDistances) {
                    a <- cbind(potentials, xyFromCell(landscape, 
                      potentials[, 2L]))
                  }
                  else {
                    if (useMatrixVersionSpreads) {
                      a <- cbind(potentials, id = spreads[potentials[, 
                        "from"]], xyFromCell(landscape, potentials[, 
                        "to"]))
                    }
                    else {
                      a <- cbind(potentials, id = spreadsDT$spreads[potentials[, 
                        "from"]], xyFromCell(landscape, potentials[, 
                        "to"]))
                    }
                  }
                  a <- a[, !(colnames(a) %fin% c("dists")), drop = FALSE]
                  d <- distanceFromEachPoint(initialLociXY, a, 
                    angles = asymmetry)
                  cMR <- (n - 1) * res(landscape)[1]
                  if (!any(is.na(circleMaxRadius))) {
                    if (any(circleMaxRadius <= ((n - 1) * res(landscape)[1]))) {
                      if (length(circleMaxRadius) > 1) {
                        cMR <- circleMaxRadius[d[, "id"]]
                      }
                      else {
                        cMR <- circleMaxRadius
                      }
                    }
                  }
                  potentials <- d[, !(colnames(d) %fin% c("x", 
                    "y")), drop = FALSE]
                  potentials <- potentials[(d[, "dists"] %<=% 
                    cMR), , drop = FALSE]
                }
            }
            events <- if (!is.integer(potentials)) 
                as.integer(potentials[, 2L])
            else potentials[, 2L]
            if (!noMaxSize) {
                if (useMatrixVersionSpreads) {
                  len <- tabulate(potentials[, 3L], length(maxSize))
                }
                else {
                  len <- tabulate(spreadsDT$spreads[potentials[, 
                    1L]], length(maxSize))
                }
                if (any((size + len) > maxSize & size <= maxSize)) {
                  whichID <- which(size + len > maxSize)
                  toRm <- (size + len)[whichID] - maxSize[whichID]
                  for (i in 1:length(whichID)) {
                    if (useMatrixVersionSpreads) {
                      thisID <- which(potentials[, 3L] == whichID[i])
                    }
                    else {
                      thisID <- which(spreadsDT$spreads[potentials[, 
                        1L]] == whichID[i])
                    }
                    if (length(thisID)) 
                      potentials <- potentials[-resample(thisID, 
                        toRm[i]), , drop = FALSE]
                  }
                  events <- as.integer(potentials[, 2L])
                }
                size <- pmin(size + len, maxSize)
            }
            if (is.function(stopRule) & length(events) > 0) {
                if (allowOverlapOrReturnDistances) {
                  prevCells <- cbind(id = spreads[, "id"], landscape = if (landRasNeeded) 
                    landRas[spreads[, "indices"]]
                  else NULL, cells = spreads[, "indices"], prev = 1)
                  eventCells <- cbind(id = potentials[, "id"], 
                    landscape = if (landRasNeeded) 
                      landRas[events]
                    else NULL, cells = events, prev = 0)
                }
                else {
                  whgtZero <- spreadsIndices
                  if (useMatrixVersionSpreads) {
                    prevCells <- cbind(id = spreads[whgtZero], 
                      landscape = if (landRasNeeded) 
                        landRas[whgtZero]
                      else NULL, cells = whgtZero, prev = 1)
                    eventCells <- cbind(id = spreads[potentials[, 
                      1L]], landscape = if (landRasNeeded) 
                      landRas[potentials[, 2L]]
                    else NULL, cells = potentials[, 2L], prev = 0)
                  }
                  else {
                    prevCells <- cbind(id = spreadsDT$spreads[whgtZero], 
                      landscape = if (landRasNeeded) 
                        landRas[whgtZero]
                      else NULL, cells = whgtZero, prev = 1)
                    eventCells <- cbind(id = spreadsDT$spreads[potentials[, 
                      1L]], landscape = if (landRasNeeded) 
                      landRas[potentials[, 2L]]
                    else NULL, cells = potentials[, 2L], prev = 0)
                  }
                }
                if (circle) {
                  prevCells <- cbind(prevCells, dist = NA)
                  eventCells <- cbind(eventCells, dist = potentials[, 
                    "dists"])
                }
                tmp <- rbind(prevCells[prevCells[, "id"] %fin% 
                  unique(eventCells[, "id"]), ], eventCells)
                ids <- unique(tmp[, "id"])
                shouldStopList <- lapply(ids, function(id) {
                  shortTmp <- tmp[tmp[, "id"] == id, ]
                  args <- append(list(id = id), lapply(colNamesPotentials[-1], 
                    function(j) shortTmp[, j]))
                  names(args) <- colNamesPotentials
                  args <- append(args, otherVars)
                  do.call(stopRule, args[whArgs])
                })
                if (any(lapply(shouldStopList, length) > 1)) 
                  stop("stopRule does not return a length-one logical.", 
                    " Perhaps stopRule need indexing by cells or id?")
                shouldStop <- unlist(shouldStopList)
                names(shouldStop) <- ids
                if (any(shouldStop)) {
                  if (stopRuleBehavior != "includeRing") {
                    if (stopRuleBehavior != "excludeRing") {
                      whStop <- as.numeric(names(shouldStop)[shouldStop])
                      whStopAll <- tmp[, "id"] %fin% whStop
                      tmp2 <- tmp[whStopAll, ]
                      whStopEvents <- eventCells[, "id"] %fin% 
                        whStop
                      out <- lapply(whStop, function(id) {
                        tmp3 <- tmp2[tmp2[, "id"] == id, ]
                        newOnes <- tmp3[, "prev"] == 0
                        ord <- seq_along(newOnes)
                        if (sum(newOnes) > 1) {
                          ord[newOnes] <- sample(ord[newOnes])
                          if (circle) 
                            ord[newOnes] <- ord[newOnes][order(tmp3[ord[newOnes], 
                              "dist"])]
                          tmp3 <- tmp3[ord, ]
                        }
                        startLen <- sum(!newOnes)
                        addIncr <- 1
                        done <- FALSE
                        args <- append(list(id = id), lapply(colNamesPotentials[-1], 
                          function(j) {
                            tmp3[1:startLen, j]
                          }))
                        names(args) <- colNamesPotentials
                        args <- append(args, otherVars)
                        argsSeq <- seq_along(colNamesPotentials[-1]) + 
                          1
                        while (!done) {
                          args[argsSeq] <- lapply(colNamesPotentials[-1], 
                            function(j) {
                              unname(c(args[[j]], tmp3[(startLen + 
                                addIncr), j]))
                            })
                          done <- do.call(stopRule, args[whArgs])
                          addIncr <- addIncr + 1
                        }
                        if (stopRuleBehavior == "excludePixel") 
                          addIncr <- addIncr - 1
                        firstInd <- startLen + addIncr
                        lastInd <- NROW(tmp3)
                        sequ <- if (firstInd > lastInd) 
                          0
                        else firstInd:lastInd
                        tmp3[sequ, , drop = FALSE]
                      })
                      eventRm <- do.call(rbind, out)[, "cells"]
                      cellsKeep <- !(potentials[, 2L] %fin% eventRm)
                    }
                    else {
                      cellsKeep <- rep(FALSE, NROW(potentials))
                    }
                    potentials <- potentials[cellsKeep, , drop = FALSE]
                    events <- as.integer(potentials[, 2L])
                    eventCells <- eventCells[cellsKeep, , drop = FALSE]
                  }
                  toKeepSR <- !(eventCells[, "id"] %fin% as.numeric(names(which((shouldStop)))))
                }
            }
            if (length(events) > 0) {
                if (useMatrixVersionSpreads) {
                  fromCol <- colnames(potentials) == "from"
                  spreads <- rbind(spreads, potentials[, !fromCol])
                  if ((returnDistances | spreadStateExists) & 
                    !allowOverlap) {
                    notDups <- !duplicated(spreads[, "indices"])
                    nrSpreads <- NROW(spreads)
                    nrPotentials <- NROW(potentials)
                    notDupsEvents <- notDups[-(1:(nrSpreads - 
                      nrPotentials))]
                    spreads <- spreads[notDups, , drop = FALSE]
                    events <- events[notDupsEvents]
                  }
                }
                else {
                  if (id | returnIndices > 0 | relativeSpreadProb) {
                    set(spreadsDT, events, "spreads", spreadsDT$spreads[potentials[, 
                      1L]])
                  }
                  else {
                    set(spreadsDT, events, "spreads", n)
                  }
                  curEventsLen <- length(events)
                  addedIndices <- prevSpreadIndicesActiveLen + 
                    1:curEventsLen
                  if (sum(curEventsLen, prevSpreadIndicesActiveLen) > 
                    prevSpreadIndicesFullLen) {
                    length(spreadsIndices) <- (prevSpreadIndicesActiveLen + 
                      curEventsLen) * 2
                    prevSpreadIndicesFullLen <- length(spreadsIndices)
                  }
                  spreadsIndices[addedIndices] <- events
                  prevSpreadIndicesActiveLen <- prevSpreadIndicesActiveLen + 
                    curEventsLen
                }
            }
            if (length(maxSize) > 1L) {
                if (exists("whichID", inherits = FALSE)) {
                  if (exists("toKeepSR", inherits = FALSE)) {
                    if (allowOverlapOrReturnDistances) {
                      maxSizeKeep <- !(spreads[spreads[, "active"] == 
                        1, "id"] %fin% whichID)
                      spreads <- spreads[c(rep(TRUE, sum(spreads[, 
                        "active"] == 0)), maxSizeKeep), ]
                    }
                    else {
                      if (useMatrixVersionSpreads) {
                        maxSizeKeep <- !spreads[events] %fin% 
                          whichID
                      }
                      else {
                        maxSizeKeep <- !spreadsDT$spreads[events] %fin% 
                          whichID
                      }
                    }
                    events <- events[maxSizeKeep]
                    toKeepSR <- toKeepSR[maxSizeKeep]
                  }
                  rm(whichID)
                }
            }
            else {
                if (all(size >= maxSize)) {
                  potentials <- potentials[0L, ]
                  events <- NULL
                }
            }
            if (is.function(stopRule)) {
                if (exists("toKeepSR", inherits = FALSE)) {
                  events <- events[toKeepSR]
                  if (allowOverlapOrReturnDistances) {
                    spreads[c(rep(TRUE, sum(spreads[, "active"] == 
                      0)), !toKeepSR), "active"] <- 0
                  }
                  rm(toKeepSR)
                }
            }
        }
        else {
            events <- NULL
        }
        if (exactSizes) {
            if (all(get("numRetries", inherits = FALSE, envir = .pkgEnv) < 
                10)) {
                if (spreadStateExists) {
                  tooSmall <- tabulate(spreads[, "id"], length(maxSize)) < 
                    maxSize
                  inactive <- tabulate(spreads[spreads[, "active"] == 
                    1, "id"], length(maxSize)) == 0
                }
                else {
                  if (useMatrixVersionSpreads) {
                    tooSmall <- tabulate(spreads, length(maxSize)) < 
                      maxSize
                    inactive <- tabulate(spreads[events], length(maxSize)) == 
                      0
                  }
                  else {
                    tooSmall <- tabulate(spreadsDT$spreads, length(maxSize)) < 
                      maxSize
                    inactive <- tabulate(spreadsDT$spreads[events], 
                      length(maxSize)) == 0
                  }
                }
                needPersist <- tooSmall & inactive
                needPersistJump <- TRUE
                if (any(needPersist)) {
                  assign("numRetries", envir = .pkgEnv, get("numRetries", 
                    inherits = FALSE, envir = .pkgEnv) + needPersist)
                  if (spreadStateExists) {
                    whSmallInactive <- which(tooSmall & inactive)
                    spreadsSmallInactive <- spreads[spreads[, 
                      "id"] %in% whSmallInactive, , drop = FALSE]
                    if (needPersistJump) {
                      message("Jumping to new active location, up to 1000 m away")
                      mmm <- rings(landscape, loci = spreadsSmallInactive[, 
                        "indices"], maxRadius = 1000, minRadius = 1, 
                        returnIndices = TRUE)
                      wh <- mmm[, list(whKeepLoci = resample(.I, 
                        1)), by = id]$whKeepLoci
                    }
                    else {
                      for (whSI in whSmallInactive) {
                        wh <- which(spreads[, "id"] == whSI)
                        wh <- tail(wh, 2)
                        keepLoci <- spreads[wh, "indices"]
                        events <- c(keepLoci, events)
                        spreads[wh, "active"] <- 1
                      }
                    }
                  }
                  else {
                    keepLoci <- spreads[loci] %fin% which(tooSmall & 
                      inactive)
                    events <- c(loci[keepLoci], events)
                  }
                }
            }
        }
        if (is.na(persistence) | persistence == 0L) {
            loci <- NULL
        }
        else {
            if (inRange(persistence)) {
                loci <- loci[runif(length(loci)) <= persistence]
            }
            else {
                stop("Unsupported type: persistence")
            }
        }
        if (plot.it) {
            if (n == 2 & !spreadStateExists) 
                clearPlot()
            if (allowOverlapOrReturnDistances) {
                spreadsDT <- data.table(spreads)
                hab2 <- landscape
                hab2[] <- 0
                pixVal <- spreadsDT[, sum(id), by = indices]
                hab2[pixVal$indices] <- pixVal$V1
                Plot(hab2, legendRange = c(0, sum(seq_along(initialLoci))))
            }
            else {
                plotCur <- raster(landscape)
                plotCur <- setValues(plotCur, spreads)
                Plot(plotCur)
            }
        }
        loci <- c(loci, events)
    }
    if (requireNamespace("dqrng", quietly = TRUE)) 
        set.seed(dqrng::dqsample.int(1e+09, 1) + sample.int(1e+09, 
            1))
    if (!allowOverlap & !returnDistances) {
        spreadsIndices <- spreadsIndices[1:prevSpreadIndicesActiveLen]
    }
    if (!allowOverlap & !returnDistances & !spreadStateExists) {
        wh <- if (spreadStateExists) {
            c(spreadState[!keepers]$indices, spreadsIndices)
        }
        else {
            spreadsIndices
        }
        if (returnIndices > 0) {
            wh <- wh[!(wh %in% potentials[, 2L])]
            completed <- wh %>% data.table(indices = ., id = spreadsDT$spreads[.], 
                active = FALSE)
            if (NROW(potentials) > 0) {
                active <- data.table(indices = as.integer(potentials[, 
                  2L]), id = spreadsDT$spreads[potentials[, 1L]], 
                  active = TRUE)
            }
            else {
                active <- data.table(indices = integer(0), id = integer(0), 
                  active = logical(0))
            }
        }
    }
    if (returnIndices == 1) {
        if (useMatrixVersionSpreads) {
            keepCols <- c(3, 1, 2, 4)
            if (circle) 
                keepCols <- c(keepCols, 5)
            allCells <- as.data.table(spreads[, keepCols, drop = FALSE])
            set(allCells, NULL, j = "active", as.logical(allCells$active))
        }
        else {
            allCells <- rbindlist(list(completed, active))
            if (spreadStateExists) {
                initEventID <- unique(spreadState$id)
            }
            else {
                initEventID <- allCells[indices %fin% initialLoci, 
                  id]
            }
            if (!all(is.na(initialLoci))) {
                attr(initialLoci, ".match.hash") <- NULL
                dtToJoin <- data.table(id = sort(initEventID), 
                  initialLocus = initialLoci)
            }
            else {
                dtToJoin <- data.table(id = numeric(0), initialLocus = numeric(0))
            }
            setkeyv(dtToJoin, "id")
            setkeyv(allCells, "id")
            allCells <- dtToJoin[allCells]
        }
        allCells[]
        if (exactSizes) 
            if (exists("numRetries", envir = .pkgEnv)) {
                if (sum(allCells$active) == 0) 
                  rm("numRetries", envir = .pkgEnv)
            }
        if (!(useMatrixVersionSpreads)) {
            set(spreadsDT, allCells$indices, "spreads", 0L)
            on.exit()
        }
        return(allCells)
    }
    if (returnIndices == 2) {
        return(wh)
    }
    landscape[] <- 0
    landscape@legend@colortable <- logical(0)
    if (allowOverlapOrReturnDistances) {
        if (returnDistances & !allowOverlap) {
            landscape[spreads[, "indices"]] <- spreads[, "dists"]
        }
        else {
            spreadsDTFinal <- data.table(spreads)
            if (returnDistances & allowOverlap) {
                pixVal <- spreadsDTFinal[, min(dists), by = indices]
                message("returnDistances is TRUE, allowOverlap is TRUE, but returnIndices is FALSE; ", 
                  "returning minimum distance raster.")
            }
            else {
                pixVal <- spreadsDTFinal[, sum(id), by = indices]
            }
            landscape[pixVal$indices] <- pixVal$V1
        }
    }
    else {
        landscape[wh] <- spreadsDT$spreads[wh]
        if (exists("potentials")) {
            if (NROW(potentials) > 0) {
                landscape[potentials[, 1L]] <- spreadsDT$spreads[potentials[, 
                  2L]]
                set(spreadsDT, as.integer(potentials[, 1L]), 
                  "spreads", 0L)
            }
        }
        set(spreadsDT, wh, "spreads", 0L)
    }
    return(landscape)
}
S4 Method spread:SpaDES.tools defined in namespace SpaDES.tools with signature RasterLayer has this body.
Fatal error: compiler constants were modified!

