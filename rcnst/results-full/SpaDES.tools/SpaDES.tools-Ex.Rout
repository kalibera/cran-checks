
R Under development (unstable) (2022-05-16 r82368) -- "Unsuffered Consequences"
Copyright (C) 2022 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "SpaDES.tools"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('SpaDES.tools')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("adj")
> ### * adj
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: adj
> ### Title: Fast 'adjacent' function, and Just In Time compiled version
> ### Aliases: adj
> 
> ### ** Examples
> 
> library(raster)
Loading required package: sp
> a <- raster(extent(0, 1000, 0, 1000), res = 1)
> sam <- sample(1:length(a), 1e4)
> numCol <- ncol(a)
> numCell <- ncell(a)
> adj.new <- adj(numCol = numCol, numCell = numCell, cells = sam, directions = 8)
> adj.new <- adj(numCol = numCol, numCell = numCell, cells = sam, directions = 8,
+                include = TRUE)
> 
> 
> 
> 
> cleanEx()

detaching ‘package:raster’, ‘package:sp’

> nameEx("cir")
> ### * cir
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cir
> ### Title: Identify pixels in a circle or ring (donut) around an object.
> ### Aliases: cir
> 
> ### ** Examples
> 
> library(data.table)
> library(sp)
> library(raster)
> library(quickPlot)
> 
> set.seed(1462)
> 
> if (require(RandomFields)) {
+   # circle centred
+   ras <- raster(extent(0, 15, 0, 15), res = 1, val = 0)
+   middleCircle <- cir(ras)
+   ras[middleCircle[, "indices"]] <- 1
+   circlePoints <- SpatialPoints(middleCircle[, c("x", "y")])
+   if (interactive()) {
+     clearPlot()
+     Plot(ras)
+     Plot(circlePoints, addTo = "ras")
+   }
+ 
+   # circles non centred
+   ras <- randomPolygons(ras, numTypes = 4)
+   n <- 2
+   agent <- SpatialPoints(coords = cbind(x = stats::runif(n, xmin(ras), xmax(ras)),
+                                         y = stats::runif(n, xmin(ras), xmax(ras))))
+ 
+   cirs <- cir(ras, agent, maxRadius = 15, simplify = TRUE) ## TODO: empty with some seeds! e.g. 1642
+   cirsSP <- SpatialPoints(coords = cirs[, c("x", "y")]) ## TODO: error with some seeds! e.g. 1642
+   cirsRas <- raster(ras)
+   cirsRas[] <- 0
+   cirsRas[cirs[, "indices"]] <- 1
+ 
+   if (interactive()) {
+     clearPlot()
+     Plot(ras)
+     Plot(cirsRas, addTo = "ras", cols = c("transparent", "#00000055"))
+     Plot(agent, addTo = "ras")
+     Plot(cirsSP, addTo = "ras")
+   }
+ 
+   # Example comparing rings and cir
+   a <- raster(extent(0, 30, 0, 30), res = 1)
+   hab <- gaussMap(a, speedup = 1) # if raster is large (>1e6 pixels) use speedup > 1
+   radius <- 4
+   n <- 2
+   coords <- SpatialPoints(coords = cbind(x = stats::runif(n, xmin(hab), xmax(hab)),
+                                          y = stats::runif(n, xmin(hab), xmax(hab))))
+ 
+   # cirs
+   cirs <- cir(hab, coords, maxRadius = rep(radius, length(coords)), simplify = TRUE)
+ 
+   # rings
+   loci <- cellFromXY(hab, coordinates(coords))
+   cirs2 <- rings(hab, loci, maxRadius = radius, minRadius = radius - 1, returnIndices = TRUE)
+ 
+   # Plot both
+   ras1 <- raster(hab)
+   ras1[] <- 0
+   ras1[cirs[, "indices"]] <- cirs[, "id"]
+ 
+   ras2 <- raster(hab)
+   ras2[] <- 0
+   ras2[cirs2$indices] <- cirs2$id
+   if (interactive()) {
+     clearPlot()
+     Plot(ras1, ras2)
+   }
+ 
+   a <- raster(extent(0, 100, 0, 100), res = 1)
+   hab <- gaussMap(a, speedup = 1)
+   cirs <- cir(hab, coords, maxRadius = 44, minRadius = 0)
+   ras1 <- raster(hab)
+   ras1[] <- 0
+   cirsOverlap <- data.table(cirs)[, list(sumIDs = sum(id)), by = indices]
+   ras1[cirsOverlap$indices] <- cirsOverlap$sumIDs
+   if (interactive()) {
+     clearPlot()
+     Plot(ras1)
+   }
+ 
+   # Provide a specific set of angles
+   ras <- raster(extent(0, 330, 0, 330), res = 1)
+   ras[] <- 0
+   n <- 2
+   coords <- cbind(x = stats::runif(n, xmin(ras), xmax(ras)),
+                   y = stats::runif(n, xmin(ras), xmax(ras)))
+   circ <- cir(ras, coords, angles = seq(0, 2 * pi, length.out = 21),
+               maxRadius = 200, minRadius = 0, returnIndices = FALSE,
+               allowOverlap = TRUE, returnAngles = TRUE)
+ }
Loading required package: RandomFields
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘RandomFields’
> 
> 
> 
> cleanEx()

detaching ‘package:quickPlot’, ‘package:raster’, ‘package:sp’,
  ‘package:data.table’

> nameEx("directions")
> ### * directions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: directionFromEachPoint
> ### Title: Calculate distances and directions between many points and many
> ###   grid cells
> ### Aliases: directionFromEachPoint .pointDirection
> ### Keywords: internal
> 
> ### ** Examples
> 
> library(raster)
Loading required package: sp
> library(quickPlot)
> 
> N <- 2
> dirRas <- raster(extent(0,40,0,40), res = 1)
> coords <- cbind(x = round(runif(N, xmin(dirRas), xmax(dirRas))) + 0.5,
+                 y = round(runif(N, xmin(dirRas), xmax(dirRas))) + 0.5,
+                 id = 1:N)
> 
> dirs1 <- directionFromEachPoint(from = coords, landscape = dirRas)
> library(CircStats)
Loading required package: MASS

Attaching package: ‘MASS’

The following objects are masked from ‘package:raster’:

    area, select

Loading required package: boot
> dirs1[, "angles"] <- deg(dirs1[,"angles"] %% (2*pi))
> indices <- cellFromXY(dirRas,dirs1[, c("x", "y")])
> minDir <- tapply(dirs1[, "angles"], indices, function(x) min(x)) # minimum angle
> dirRas[] <- as.vector(minDir)
> if (interactive()) {
+   clearPlot()
+   Plot(dirRas)
+   library(sp)
+   start <- SpatialPoints(coords[, c("x", "y"), drop = FALSE])
+   Plot(start, addTo = "dirRas")
+ }
> 
> 
> 
> cleanEx()

detaching ‘package:CircStats’, ‘package:boot’, ‘package:MASS’,
  ‘package:quickPlot’, ‘package:raster’, ‘package:sp’

> nameEx("distanceFromEachPoint")
> ### * distanceFromEachPoint
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: distanceFromEachPoint
> ### Title: Calculate distances and directions between many points and many
> ###   grid cells
> ### Aliases: distanceFromEachPoint
> 
> ### ** Examples
> 
> library(raster)
Loading required package: sp
> library(quickPlot)
> 
> n <- 2
> distRas <- raster(extent(0, 40, 0, 40), res = 1)
> coords <- cbind(x = round(runif(n, xmin(distRas), xmax(distRas))) + 0.5,
+                 y = round(runif(n, xmin(distRas), xmax(distRas))) + 0.5)
> 
> # inverse distance weights
> dists1 <- distanceFromEachPoint(coords, landscape = distRas)
> indices <- cellFromXY(distRas, dists1[, c("x", "y")])
> invDist <- tapply(dists1[, "dists"], indices, function(x) sum(1 / (1 + x))) # idw function
> distRas[] <- as.vector(invDist)
> if (interactive()) {
+   clearPlot()
+   Plot(distRas)
+ }
> 
> # With iterative summing via cumulativeFn to keep memory use low, with same result
> dists1 <- distanceFromEachPoint(coords[, c("x", "y"), drop = FALSE],
+                                 landscape = distRas, cumulativeFn = `+`)
> idwRaster <- raster(distRas)
> idwRaster[] <- dists1[, "dists"]
> if (interactive()) Plot(idwRaster)
> 
> all(idwRaster[] == distRas[]) # TRUE
[1] TRUE
> 
> # A more complex example of cumulative inverse distance sums, weighted by the value
> #  of the origin cell
> ras <- raster(extent(0, 34, 0, 34), res = 1, val = 0)
> rp <- randomPolygons(ras, numTypes = 10) ^ 2
> n <- 15
> cells <- sample(ncell(ras), n)
> coords <- xyFromCell(ras, cells)
> distFn <- function(landscape, fromCell, dist) landscape[fromCell] / (1 + dist)
> 
> #beginCluster(3) # can do parallel
> dists1 <- distanceFromEachPoint(coords[, c("x", "y"), drop = FALSE],
+                                 landscape = rp, distFn = distFn, cumulativeFn = `+`)
> #endCluster() # if beginCluster was run
> 
> idwRaster <- raster(ras)
> idwRaster[] <- dists1[, "dists"]
> if (interactive()) {
+   clearPlot()
+   Plot(rp, idwRaster)
+   sp1 <- SpatialPoints(coords)
+   Plot(sp1, addTo = "rp")
+   Plot(sp1, addTo = "idwRaster")
+ }
> 
> # On linux; can use numeric passed to cl; will use mclapply with mc.cores = cl
> if (identical(Sys.info()["sysname"], "Linux")) {
+   dists1 <- distanceFromEachPoint(coords[, c("x", "y"), drop = FALSE],
+                                   landscape = rp, distFn = distFn,
+                                   cumulativeFn = `+`, cl = 2)
+ }
> 
> 
> 
> cleanEx()

detaching ‘package:quickPlot’, ‘package:raster’, ‘package:sp’

> nameEx("dwrpnorm2")
> ### * dwrpnorm2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dwrpnorm2
> ### Title: Vectorized wrapped normal density function
> ### Aliases: dwrpnorm2
> 
> ### ** Examples
> 
> # Values for which to evaluate density
> theta <- c(1:500) * 2 * pi / 500
> # Compute wrapped normal density function
> density <- c(1:500)
> for(i in 1:500) density[i] <- dwrpnorm2(theta[i], pi, .75)
> if (interactive()) plot(theta, density)
> # Approximate area under density curve
> sum(density * 2 * pi / 500)
[1] 1
> 
> 
> 
> 
> cleanEx()
> nameEx("gaussMap")
> ### * gaussMap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gaussMap
> ### Title: Produce a 'raster' of a random Gaussian process.
> ### Aliases: gaussMap
> 
> ### ** Examples
> 
> ## Not run: 
> ##D if (require(RandomFields)) {
> ##D   library(raster)
> ##D   nx <- ny <- 100L
> ##D   r <- raster(nrows = ny, ncols = nx, xmn = -nx/2, xmx = nx/2, ymn = -ny/2, ymx = ny/2)
> ##D   speedup <- max(1, nx/5e2)
> ##D   map1 <- gaussMap(r, scale = 300, var = 0.03, speedup = speedup, inMemory = TRUE)
> ##D   if (interactive()) Plot(map1)
> ##D 
> ##D   # with non-default method
> ##D   map1 <- gaussMap(r, scale = 300, var = 0.03, method = "RMgauss")
> ##D }
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("heading")
> ### * heading
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: heading
> ### Title: Heading between spatial points.
> ### Aliases: heading heading,SpatialPoints,SpatialPoints-method
> ###   heading,matrix,matrix-method heading,matrix,SpatialPoints-method
> ###   heading,SpatialPoints,matrix-method
> 
> ### ** Examples
> 
> library(sp)
> N <- 10L                # number of agents
> x1 <- stats::runif(N, -50, 50) # previous X location
> y1 <- stats::runif(N, -50, 50) # previous Y location
> x0 <- stats::rnorm(N, x1, 5)   # current X location
> y0 <- stats::rnorm(N, y1, 5)   # current Y location
> 
> # using SpatialPoints
> prev <- SpatialPoints(cbind(x = x1, y = y1))
> curr <- SpatialPoints(cbind(x = x0, y = y0))
> heading(prev, curr)
 [1]  58.70553  26.49322 276.84424 228.06827  61.14567 218.67886 185.93288
 [8] 147.31021 120.20979  54.86510
> 
> # using matrix
> prev <- matrix(c(x1, y1), ncol = 2, dimnames = list(NULL, c("x","y")))
> curr <- matrix(c(x0, y0), ncol = 2, dimnames = list(NULL, c("x","y")))
> heading(prev, curr)
 [1]  58.70553  26.49322 276.84424 228.06827  61.14567 218.67886 185.93288
 [8] 147.31021 120.20979  54.86510
> 
> #using both
> prev <- SpatialPoints(cbind(x = x1, y = y1))
> curr <- matrix(c(x0, y0), ncol = 2, dimnames = list(NULL, c("x","y")))
> heading(prev, curr)
 [1]  58.70553  26.49322 276.84424 228.06827  61.14567 218.67886 185.93288
 [8] 147.31021 120.20979  54.86510
> 
> prev <- matrix(c(x1, y1), ncol = 2, dimnames = list(NULL, c("x","y")))
> curr <- SpatialPoints(cbind(x = x0, y = y0))
> heading(prev, curr)
 [1]  58.70553  26.49322 276.84424 228.06827  61.14567 218.67886 185.93288
 [8] 147.31021 120.20979  54.86510
> 
> 
> 
> 
> cleanEx()

detaching ‘package:sp’

> nameEx("inRange")
> ### * inRange
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: inRange
> ### Title: Test whether a number lies within range '[a,b]'
> ### Aliases: inRange
> 
> ### ** Examples
> 
> set.seed(100)
> x <- stats::rnorm(4) # -0.50219235  0.13153117 -0.07891709  0.88678481
> inRange(x, 0, 1)
[1] FALSE  TRUE FALSE  TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("initiateAgents")
> ### * initiateAgents
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: initiateAgents
> ### Title: 'SELES' - Initiate agents
> ### Aliases: initiateAgents
> ###   initiateAgents,Raster,missing,missing,ANY,missing-method
> ###   initiateAgents,Raster,missing,Raster,ANY,missing-method
> ###   initiateAgents,Raster,numeric,missing,ANY,missing-method
> ###   initiateAgents,Raster,numeric,Raster,ANY,missing-method
> ###   initiateAgents,Raster,missing,missing,ANY,numeric-method
> 
> ### ** Examples
> 
> if (require(RandomFields)) {
+   library(magrittr)
+   library(raster)
+   library(quickPlot)
+ 
+   map <- raster(xmn = 0, xmx = 10, ymn = 0, ymx = 10, val = 0, res = 1)
+   map <- gaussMap(map, scale = 1, var = 4, speedup = 1)
+   pr <- probInit(map, p = (map/maxValue(map))^2)
+   agents <- initiateAgents(map, 100, pr)
+   if (interactive()) {
+     clearPlot()
+     Plot(map)
+     Plot(agents, addTo = "map")
+   }
+   # Test that they are indeed selecting according to probabilities in pr
+   library(data.table)
+   dt1 <- data.table(table(round(map[agents], 0)))
+   setnames(dt1, old = "N", new = "count")
+   dt2 <- data.table(table(round(map[], 0)))
+   setnames(dt2, old = "N", new = "available")
+   dt <-dt1[dt2, on = "V1"]  # join the counts and available data.tables
+   setnames(dt, old = "V1", new = "mapValue")
+   dt[, selection := count/available]
+   dt[is.na(selection), selection := 0]
+   if (interactive())
+     with(dt, {plot(mapValue, selection)})
+   #'
+   # Note, can also produce a Raster representing agents,
+   # then the number of points produced can't be more than
+   # the number of pixels:
+   agentsRas <- initiateAgents(map, 30, pr, asSpatialPoints = FALSE)
+   if (interactive()) Plot(agentsRas)
+   #'
+   if (require(dplyr) && getRversion() >= 3.4) {
+     # Check that the agents are more often at the higher probability areas based on pr
+     if (utils::packageVersion("raster") >= "2.8-11") {
+       out <- data.frame(stats::na.omit(crosstab(agentsRas, map)), table(round(map[]))) %>%
+                dplyr::mutate(selectionRatio = Freq / Freq.1) %>%
+                dplyr::select(-layer.1, -Var1) %>%
+                dplyr::rename(Present = Freq, Avail = Freq.1, Type = layer.2)
+     } else {
+       out <- data.frame(stats::na.omit(crosstab(agentsRas, map)), table(round(map[]))) %>%
+                dplyr::mutate(selectionRatio = Freq/Freq.1) %>%
+                dplyr::select(-Var1, -Var1.1) %>%
+                dplyr::rename(Present = Freq, Avail = Freq.1, Type = Var2)
+     }
+     out
+   }
+ }
Loading required package: RandomFields
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘RandomFields’
> 
> 
> 
> cleanEx()
> nameEx("randomPolygons")
> ### * randomPolygons
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: randomPolygons
> ### Title: Produce a 'RasterLayer' of random polygons
> ### Aliases: randomPolygons randomPolygon randomPolygon.SpatialPoints
> ###   randomPolygon.matrix randomPolygon.SpatialPolygons
> 
> ### ** Examples
> 
> library(quickPlot)
> 
> set.seed(1234)
> Ras <- randomPolygons(numTypes = 5)
> if (interactive()) {
+   clearPlot()
+   Plot(Ras, cols = c("yellow", "dark green", "blue", "dark red"))
+ }
> 
> library(raster)
Loading required package: sp
> # more complex patterning, with a range of patch sizes
> a <- randomPolygons(numTypes = 400, raster(extent(0, 50, 0, 50), res = 1, vals = 0))
duplicate initial loci are provided
> a[a < 320] <- 0
ERROR: modification of compiler constant of type character, length 4
ERROR: the modified value of the constant is:
[1] "includePixel" "excludePixel" "includeRing"  "excludeRing" 
attr(,".match.hash")
<hash table>
ERROR: the original value of the constant is:
[1] "includePixel" "excludePixel" "includeRing"  "excludeRing" 
ERROR: the modified constant is at index 40
ERROR: the modified constant is in this function body:
{
    if (!is.null(neighProbs)) {
        if (isTRUE(allowOverlap)) 
            stop("Can't use neighProbs and allowOverlap = TRUE together")
    }
    if (requireNamespace("dqrng", quietly = TRUE)) {
        samInt <- dqrng::dqsample.int
        dqrng::dqset.seed(sample.int(1e+09, 2))
    }
    else {
        samInt <- sample.int
    }
    if (!is.null(mapID)) {
        warning("mapID is deprecated, use id")
        id <- mapID
    }
    if (!quick) {
        allowedRules <- c("includePixel", "excludePixel", "includeRing", 
            "excludeRing")
        if (!any(stopRuleBehavior %fin% allowedRules)) 
            stop("stopRuleBehaviour must be one of \"", paste(allowedRules, 
                collapse = "\", \""), "\".")
    }
    if (isTRUE(lowMemory)) {
        requireNamespace("ff", quietly = TRUE)
        requireNamespace("ffbase", quietly = TRUE)
    }
    spreadStateExists <- is(spreadState, "data.table")
    spreadProbLaterExists <- TRUE
    if (!is(spreadProbLater, "Raster")) {
        if (anyNA(spreadProbLater)) {
            spreadProbLaterExists <- FALSE
            spreadProbLater <- spreadProb
        }
    }
    if (any(is.na(loci))) {
        if (!spreadStateExists) 
            loci <- middlePixel(landscape)
    }
    if (!is.integer(loci)) {
        loci <- as.integer(loci)
    }
    if (!quick) {
        dupLoci <- duplicated(loci)
        if (any(duplicated(loci))) {
            message("duplicate initial loci are provided")
        }
    }
    if (length(loci) == 0) 
        stop("No loci. Nothing to do")
    if (any(!is.na(maxSize))) {
        msEqZero <- maxSize < 1
        if (any(msEqZero)) {
            loci <- loci[!msEqZero]
            maxSize <- maxSize[!msEqZero]
        }
    }
    if (spreadStateExists) {
        keepers <- spreadState$active == TRUE
        loci <- initialActiveCells <- spreadState[keepers, indices]
        initialLoci <- unique(spreadState$initialLocus)
    }
    else {
        initialLoci <- loci
    }
    lenInitialLoci <- length(initialLoci)
    sequenceInitialLoci <- seq(lenInitialLoci)
    if (!quick) {
        if (is(spreadProbLater, "RasterLayer") | is(spreadProb, 
            "Rasterlayer")) {
            if ((minValue(spreadProb) > 1L) || (maxValue(spreadProb) < 
                0L) || (maxValue(spreadProb) > 1L) || (minValue(spreadProb) < 
                0L)) {
                relativeSpreadProb <- TRUE
            }
            if (spreadProbLaterExists) 
                if (((minValue(spreadProbLater) > 1L) || (maxValue(spreadProbLater) < 
                  0L) || (maxValue(spreadProbLater) > 1L) || 
                  (minValue(spreadProbLater) < 0L))) {
                  relativeSpreadProb <- TRUE
                }
        }
        else {
            if (!all(inRange(na.omit(spreadProb)))) {
                relativeSpreadProb <- TRUE
                stop("spreadProb is not a probability")
            }
            if (spreadProbLaterExists) {
                relativeSpreadProb <- TRUE
                if (!all(inRange(na.omit(spreadProbLater)))) 
                  stop("spreadProbLater is not a probability")
            }
        }
    }
    ncells <- as.integer(ncell(landscape))
    allowOverlapOrReturnDistances <- allowOverlap | returnDistances
    useMatrixVersionSpreads <- allowOverlapOrReturnDistances | 
        spreadStateExists
    if (useMatrixVersionSpreads) {
        if (spreadStateExists) {
            spreads <- as.matrix(spreadState[, list(initialLocus, 
                indices, id, active)])
        }
        else {
            spreads <- cbind(initialLocus = initialLoci, indices = initialLoci, 
                id = 1:length(loci), active = 1)
        }
    }
    else {
        if (!is.null(lowMemory)) {
            message("lowMemory argument is now deprecated; using standard spread")
        }
        needEmptySpreads <- TRUE
        stNamespace <- asNamespace("SpaDES.tools")
        if (exists("spreadsDTInNamespace", envir = stNamespace)) {
            spreadsDT <- getFromNamespace("spreadsDTInNamespace", 
                "SpaDES.tools")
            if (identical(NROW(spreadsDT), ncells)) {
                needEmptySpreads <- FALSE
            }
        }
        if (needEmptySpreads) {
            spreadsDT <- data.table(spreads = vector("integer", 
                ncells))
            set(spreadsDT, NULL, "spreads", 0L)
            assignInMyNamespace("spreadsDTInNamespace", spreadsDT)
            on.exit({
                assignInMyNamespace("spreadsDTInNamespace", integer())
            })
        }
    }
    n <- 1L
    if (circle | !is.na(asymmetry)) {
        if (circle) 
            directions <- 8L
        initialLociXY <- cbind(id = seq_along(initialLoci), xyFromCell(landscape, 
            initialLoci))
        id <- TRUE
        if (allowOverlapOrReturnDistances) {
            spreads <- cbind(spreads, dists = 0)
        }
    }
    otherVars <- list(...)
    anyList <- unlist(lapply(otherVars, is.list))
    if (any(anyList)) {
        otherVarsLists <- unlist(unname(otherVars), recursive = FALSE)
        otherVars[anyList] <- NULL
        otherVars <- append(otherVars, otherVarsLists)
    }
    if (is.function(stopRule)) {
        id <- TRUE
        stopRuleObjs <- names(formals(stopRule))
        if (!quick) {
            if (any(is.na(match(stopRuleObjs, c("id", "landscape", 
                "cells", names(otherVars)))))) {
                stop("Arguments in stopRule not valid.\n", "The function definition must be a function of built-in options,", 
                  " (id, landscape, or cells) or user supplied variables.", 
                  " If user supplied, the variables", " must be passed as named vectors, or lists or data.frames.", 
                  " See examples.")
            }
        }
        landRasNeeded <- any(stopRuleObjs == "landscape")
        colNamesPotentials <- c("id", "landscape"[landRasNeeded], 
            "cells", "prev")
        argNames <- c(colNamesPotentials, names(otherVars))
        whArgs <- match(names(formals(stopRule)), argNames)
        rasters <- unlist(lapply(otherVars[names(otherVars)], 
            function(x) is(x, "Raster")))
        if (any(rasters)) {
            for (i in 1:which(rasters)) {
                otherVars[[names(rasters[i])]] <- otherVars[[names(rasters[i])]][]
            }
        }
        landRas <- landscape[]
    }
    if (!allowOverlap && !returnDistances) {
        if (id | returnIndices > 0 | relativeSpreadProb) {
            if (!spreadStateExists) {
                set(spreadsDT, loci, "spreads", 1L:length(loci))
            }
        }
        else {
            spreadsDT$spreads[loci] <- n
        }
        spreadsIndices <- unname(loci)
        length(spreadsIndices) <- length(loci) * 100
        prevSpreadIndicesActiveLen <- length(loci)
        prevSpreadIndicesFullLen <- length(spreadsIndices)
    }
    if (is(spreadProb, "Raster")) {
    }
    else if (is.numeric(spreadProb)) {
        if (is(mask, "Raster")) {
            spreadProb <- raster(extent(landscape), res = res(landscape), 
                vals = spreadProb)
        }
    }
    if (is(spreadProbLater, "Raster")) {
    }
    else if (is.numeric(spreadProbLater)) {
        if (is(mask, "Raster")) {
            spreadProbLater <- raster(extent(landscape), res = res(landscape), 
                vals = spreadProbLater)
        }
    }
    if (is(mask, "Raster")) {
        spreadProbLater[mask[] == 1L] <- 0L
        spreadProb[mask[] == 1L] <- 0L
    }
    if (spreadStateExists) {
        if (allowOverlapOrReturnDistances) {
            stop("Using spreadState with either allowOverlap = TRUE", 
                " or returnDistances = TRUE is not implemented")
        }
        else {
            if (sum(colnames(spreadState) %fin% c("indices", 
                "id", "active", "initialLocus")) != 4) {
                stop("spreadState must have at least columns: ", 
                  "indices, id, active, and initialLocus.")
            }
        }
    }
    if (!quick) {
        if (any(loci > ncells)) 
            stop("loci indices are not on landscape")
    }
    if (any(!is.na(maxSize))) {
        if (!is.integer(maxSize)) 
            maxSize <- floor(maxSize)
        if (spreadStateExists) {
            sizeAll <- spreadState[, list(len = .N), by = id]
            size <- c(sizeAll[, len])
        }
        else {
            maxSize <- rep_len(maxSize, length(loci))
            size <- rep_len(1L, length(loci))
        }
    }
    else {
        maxSize <- ncells
        size <- length(loci)
    }
    noMaxSize <- all(maxSize >= ncells)
    if (is.null(neighProbs)) {
        numNeighs <- NULL
    }
    if (!exists("numRetries", envir = .pkgEnv)) {
        assign("numRetries", rep(0, lenInitialLoci), envir = .pkgEnv)
    }
    toColumn <- c("to", "indices")
    while (length(loci) & (n <= iterations)) {
        if (!is.null(neighProbs)) {
            numNeighs <- if (is.list(neighProbs)) {
                unlist(lapply(neighProbs, function(x) {
                  sample.int(length(x), size = 1, replace = TRUE, 
                    prob = x)
                }))
            }
            else {
                sample.int(length(neighProbs), size = length(loci), 
                  replace = TRUE, prob = neighProbs)
            }
        }
        if (useMatrixVersionSpreads) {
            whActive <- spreads[, "active"] == 1
            potentials <- adj(landscape, loci, directions, pairs = TRUE, 
                id = spreads[whActive, "id"])
            spreads[whActive, "active"] <- 0
            potentials <- cbind(potentials, active = 1)
        }
        else {
            if (id | returnIndices > 0 | circle | relativeSpreadProb | 
                !is.null(neighProbs)) {
                potentials <- adj(landscape, loci, directions, 
                  pairs = TRUE)
            }
            else {
                newAdj <- adj(landscape, loci, directions, pairs = FALSE)
                potentials <- cbind(NA_integer_, newAdj)
            }
        }
        if (circle) {
            potentials <- cbind(potentials, dists = 0)
        }
        if (useMatrixVersionSpreads) {
            if (NROW(potentials) > 2000) {
                spreadsDT <- as.data.table(spreads)
                potentialsDT <- as.data.table(potentials)
                potentialsDT[, `:=`(initialLocus, initialLoci[potentialsDT$id])]
                colnamesPot <- colnames(potentialsDT)
                whIL <- which(colnamesPot == "initialLocus")
                whFrom <- which(colnamesPot == "from")
                setcolorder(potentialsDT, c(colnamesPot[whIL], 
                  colnamesPot[-c(whIL, whFrom)], colnamesPot[whFrom]))
                setnames(potentialsDT, old = "to", new = "indices")
                newPot <- potentialsDT[!spreadsDT, on = c("id", 
                  "indices")]
                potentials <- as.matrix(newPot)
            }
            else {
                potentials <- cbind(initialLocus = initialLoci[potentials[, 
                  "id"]], potentials)
                colnames(potentials)[which(colnames(potentials) == 
                  "to")] <- "indices"
                colnamesPot <- colnames(potentials)
                whIL <- which(colnamesPot == "initialLocus")
                whFrom <- which(colnamesPot == "from")
                potentials <- potentials[, c(colnamesPot[whIL], 
                  colnamesPot[-c(whIL, whFrom)], colnamesPot[whFrom])]
                seq2 <- sequenceInitialLoci[sequenceInitialLoci %in% 
                  potentials[, "id"]]
                out <- lapply(seq2, function(ind) {
                  hasID <- potentials[, "id"] == ind
                  po <- potentials[hasID, ]
                  hasID2 <- spreads[, "id"] == ind
                  inds <- spreads[hasID2, "indices"]
                  vals <- po[, 2L] %in% inds
                  po[!vals, ]
                })
                potentials <- do.call(rbind, out)
            }
        }
        else {
            keep <- spreadsDT$spreads[potentials[, 2L]] == 0L
            potentials <- potentials[keep, , drop = FALSE]
        }
        if (n == 2) {
            spreadProb <- spreadProbLater
        }
        if (is.numeric(spreadProb)) {
            if (!(length(spreadProb) == 1 || length(spreadProb) == 
                ncell(landscape))) 
                stop("spreadProb must be length 1 or length ncell(landscape), or a raster")
            if (n == 1 & spreadProbLaterExists) {
                spreadProbs <- rep(spreadProb, NROW(potentials))
                spreadProb <- spreadProbLater
            }
            else {
                if (length(spreadProb) > 1) {
                  spreadProbs <- spreadProb[potentials[, 2L]]
                }
                else {
                  spreadProbs <- rep(spreadProb, NROW(potentials))
                }
            }
        }
        else {
            if (n == 1 & spreadProbLaterExists) {
                spreadProbs <- spreadProb[][potentials[, 2L]]
                spreadProb <- spreadProbLater
            }
            else {
                spreadProbs <- spreadProb[][potentials[, 2L]]
            }
        }
        if (anyNA(spreadProbs)) 
            spreadProbs[is.na(spreadProbs)] <- 0
        if (!is.na(asymmetry)) {
            if (allowOverlapOrReturnDistances) {
                a <- cbind(id = potentials[, 3L], to = potentials[, 
                  2L], xyFromCell(landscape, potentials[, 2L]))
            }
            else {
                if (useMatrixVersionSpreads) {
                  a <- cbind(id = spreads[potentials[, 1L]], 
                    to = potentials[, 2L], xyFromCell(landscape, 
                      potentials[, 2L]))
                }
                else {
                  a <- cbind(id = spreadsDT$spreads[potentials[, 
                    1L]], to = potentials[, 2L], xyFromCell(landscape, 
                    potentials[, 2L]))
                }
            }
            d <- directionFromEachPoint(from = initialLociXY, 
                to = a)
            newSpreadProbExtremes <- (spreadProb[] * 2)/(asymmetry + 
                1) * c(1, asymmetry)
            angleQuality <- (cos(d[, "angles"] - rad(asymmetryAngle)) + 
                1)/2
            spreadProbs <- newSpreadProbExtremes[1] + (angleQuality * 
                diff(newSpreadProbExtremes))
            spreadProbs <- spreadProbs - diff(c(spreadProb[], 
                mean(spreadProbs)))
        }
        if (!is.null(neighProbs) | relativeSpreadProb) {
            aaa <- split(seq_along(potentials[, toColumn[spreadStateExists + 
                1]]), potentials[, "from"])
            if (length(aaa) != length(numNeighs)) {
                activeCellContinue <- loci %in% unique(potentials[, 
                  "from"])
                numNeighs <- numNeighs[activeCellContinue]
            }
            tmpA <- unlist(lapply(aaa, length))
            tmpB <- which(tmpA < numNeighs)
            if (length(tmpB) > 0) 
                numNeighs[tmpB] <- unname(tmpA[tmpB])
            if (relativeSpreadProb) {
                rescaledProbs <- tapply(spreadProbs, potentials[, 
                  "from"], function(x) {
                  x/sum(x, na.rm = TRUE)
                }, simplify = FALSE)
                neighIndexToKeep <- unlist(lapply(seq_along(aaa), 
                  function(x) resample(aaa[[x]], size = numNeighs[x], 
                    prob = rescaledProbs[[x]])))
            }
            else {
                neighIndexToKeep <- unlist(lapply(seq_along(aaa), 
                  function(x) resample(aaa[[x]], size = numNeighs[x])))
            }
            potentials <- potentials[neighIndexToKeep, , drop = FALSE]
            spreadProbs <- spreadProbs[neighIndexToKeep]
            spreadProbs[spreadProbs > 0] <- 1
        }
        randomSuccesses <- runifC(NROW(potentials)) <= spreadProbs
        potentials <- potentials[randomSuccesses, , drop = FALSE]
        lenPot <- NROW(potentials)
        if (lenPot) {
            reorderVals <- samInt(lenPot)
            potentials <- potentials[reorderVals, , drop = FALSE]
        }
        if (!allowOverlap) {
            potentials <- potentials[!duplicated(potentials[, 
                2L]), , drop = FALSE]
        }
        else {
            pots <- potentials[, c("id", "indices"), drop = FALSE]
            potentials <- potentials[!duplicated(pots), , drop = FALSE]
        }
        n <- n + 1L
        if (length(potentials) > 0) {
            if (!missing(circle)) {
                if (circle) {
                  if (allowOverlapOrReturnDistances) {
                    a <- cbind(potentials, xyFromCell(landscape, 
                      potentials[, 2L]))
                  }
                  else {
                    if (useMatrixVersionSpreads) {
                      a <- cbind(potentials, id = spreads[potentials[, 
                        "from"]], xyFromCell(landscape, potentials[, 
                        "to"]))
                    }
                    else {
                      a <- cbind(potentials, id = spreadsDT$spreads[potentials[, 
                        "from"]], xyFromCell(landscape, potentials[, 
                        "to"]))
                    }
                  }
                  a <- a[, !(colnames(a) %fin% c("dists")), drop = FALSE]
                  d <- distanceFromEachPoint(initialLociXY, a, 
                    angles = asymmetry)
                  cMR <- (n - 1) * res(landscape)[1]
                  if (!any(is.na(circleMaxRadius))) {
                    if (any(circleMaxRadius <= ((n - 1) * res(landscape)[1]))) {
                      if (length(circleMaxRadius) > 1) {
                        cMR <- circleMaxRadius[d[, "id"]]
                      }
                      else {
                        cMR <- circleMaxRadius
                      }
                    }
                  }
                  potentials <- d[, !(colnames(d) %fin% c("x", 
                    "y")), drop = FALSE]
                  potentials <- potentials[(d[, "dists"] %<=% 
                    cMR), , drop = FALSE]
                }
            }
            events <- if (!is.integer(potentials)) 
                as.integer(potentials[, 2L])
            else potentials[, 2L]
            if (!noMaxSize) {
                if (useMatrixVersionSpreads) {
                  len <- tabulate(potentials[, 3L], length(maxSize))
                }
                else {
                  len <- tabulate(spreadsDT$spreads[potentials[, 
                    1L]], length(maxSize))
                }
                if (any((size + len) > maxSize & size <= maxSize)) {
                  whichID <- which(size + len > maxSize)
                  toRm <- (size + len)[whichID] - maxSize[whichID]
                  for (i in 1:length(whichID)) {
                    if (useMatrixVersionSpreads) {
                      thisID <- which(potentials[, 3L] == whichID[i])
                    }
                    else {
                      thisID <- which(spreadsDT$spreads[potentials[, 
                        1L]] == whichID[i])
                    }
                    if (length(thisID)) 
                      potentials <- potentials[-resample(thisID, 
                        toRm[i]), , drop = FALSE]
                  }
                  events <- as.integer(potentials[, 2L])
                }
                size <- pmin(size + len, maxSize)
            }
            if (is.function(stopRule) & length(events) > 0) {
                if (allowOverlapOrReturnDistances) {
                  prevCells <- cbind(id = spreads[, "id"], landscape = if (landRasNeeded) 
                    landRas[spreads[, "indices"]]
                  else NULL, cells = spreads[, "indices"], prev = 1)
                  eventCells <- cbind(id = potentials[, "id"], 
                    landscape = if (landRasNeeded) 
                      landRas[events]
                    else NULL, cells = events, prev = 0)
                }
                else {
                  whgtZero <- spreadsIndices
                  if (useMatrixVersionSpreads) {
                    prevCells <- cbind(id = spreads[whgtZero], 
                      landscape = if (landRasNeeded) 
                        landRas[whgtZero]
                      else NULL, cells = whgtZero, prev = 1)
                    eventCells <- cbind(id = spreads[potentials[, 
                      1L]], landscape = if (landRasNeeded) 
                      landRas[potentials[, 2L]]
                    else NULL, cells = potentials[, 2L], prev = 0)
                  }
                  else {
                    prevCells <- cbind(id = spreadsDT$spreads[whgtZero], 
                      landscape = if (landRasNeeded) 
                        landRas[whgtZero]
                      else NULL, cells = whgtZero, prev = 1)
                    eventCells <- cbind(id = spreadsDT$spreads[potentials[, 
                      1L]], landscape = if (landRasNeeded) 
                      landRas[potentials[, 2L]]
                    else NULL, cells = potentials[, 2L], prev = 0)
                  }
                }
                if (circle) {
                  prevCells <- cbind(prevCells, dist = NA)
                  eventCells <- cbind(eventCells, dist = potentials[, 
                    "dists"])
                }
                tmp <- rbind(prevCells[prevCells[, "id"] %fin% 
                  unique(eventCells[, "id"]), ], eventCells)
                ids <- unique(tmp[, "id"])
                shouldStopList <- lapply(ids, function(id) {
                  shortTmp <- tmp[tmp[, "id"] == id, ]
                  args <- append(list(id = id), lapply(colNamesPotentials[-1], 
                    function(j) shortTmp[, j]))
                  names(args) <- colNamesPotentials
                  args <- append(args, otherVars)
                  do.call(stopRule, args[whArgs])
                })
                if (any(lapply(shouldStopList, length) > 1)) 
                  stop("stopRule does not return a length-one logical.", 
                    " Perhaps stopRule need indexing by cells or id?")
                shouldStop <- unlist(shouldStopList)
                names(shouldStop) <- ids
                if (any(shouldStop)) {
                  if (stopRuleBehavior != "includeRing") {
                    if (stopRuleBehavior != "excludeRing") {
                      whStop <- as.numeric(names(shouldStop)[shouldStop])
                      whStopAll <- tmp[, "id"] %fin% whStop
                      tmp2 <- tmp[whStopAll, ]
                      whStopEvents <- eventCells[, "id"] %fin% 
                        whStop
                      out <- lapply(whStop, function(id) {
                        tmp3 <- tmp2[tmp2[, "id"] == id, ]
                        newOnes <- tmp3[, "prev"] == 0
                        ord <- seq_along(newOnes)
                        if (sum(newOnes) > 1) {
                          ord[newOnes] <- sample(ord[newOnes])
                          if (circle) 
                            ord[newOnes] <- ord[newOnes][order(tmp3[ord[newOnes], 
                              "dist"])]
                          tmp3 <- tmp3[ord, ]
                        }
                        startLen <- sum(!newOnes)
                        addIncr <- 1
                        done <- FALSE
                        args <- append(list(id = id), lapply(colNamesPotentials[-1], 
                          function(j) {
                            tmp3[1:startLen, j]
                          }))
                        names(args) <- colNamesPotentials
                        args <- append(args, otherVars)
                        argsSeq <- seq_along(colNamesPotentials[-1]) + 
                          1
                        while (!done) {
                          args[argsSeq] <- lapply(colNamesPotentials[-1], 
                            function(j) {
                              unname(c(args[[j]], tmp3[(startLen + 
                                addIncr), j]))
                            })
                          done <- do.call(stopRule, args[whArgs])
                          addIncr <- addIncr + 1
                        }
                        if (stopRuleBehavior == "excludePixel") 
                          addIncr <- addIncr - 1
                        firstInd <- startLen + addIncr
                        lastInd <- NROW(tmp3)
                        sequ <- if (firstInd > lastInd) 
                          0
                        else firstInd:lastInd
                        tmp3[sequ, , drop = FALSE]
                      })
                      eventRm <- do.call(rbind, out)[, "cells"]
                      cellsKeep <- !(potentials[, 2L] %fin% eventRm)
                    }
                    else {
                      cellsKeep <- rep(FALSE, NROW(potentials))
                    }
                    potentials <- potentials[cellsKeep, , drop = FALSE]
                    events <- as.integer(potentials[, 2L])
                    eventCells <- eventCells[cellsKeep, , drop = FALSE]
                  }
                  toKeepSR <- !(eventCells[, "id"] %fin% as.numeric(names(which((shouldStop)))))
                }
            }
            if (length(events) > 0) {
                if (useMatrixVersionSpreads) {
                  fromCol <- colnames(potentials) == "from"
                  spreads <- rbind(spreads, potentials[, !fromCol])
                  if ((returnDistances | spreadStateExists) & 
                    !allowOverlap) {
                    notDups <- !duplicated(spreads[, "indices"])
                    nrSpreads <- NROW(spreads)
                    nrPotentials <- NROW(potentials)
                    notDupsEvents <- notDups[-(1:(nrSpreads - 
                      nrPotentials))]
                    spreads <- spreads[notDups, , drop = FALSE]
                    events <- events[notDupsEvents]
                  }
                }
                else {
                  if (id | returnIndices > 0 | relativeSpreadProb) {
                    set(spreadsDT, events, "spreads", spreadsDT$spreads[potentials[, 
                      1L]])
                  }
                  else {
                    set(spreadsDT, events, "spreads", n)
                  }
                  curEventsLen <- length(events)
                  addedIndices <- prevSpreadIndicesActiveLen + 
                    1:curEventsLen
                  if (sum(curEventsLen, prevSpreadIndicesActiveLen) > 
                    prevSpreadIndicesFullLen) {
                    length(spreadsIndices) <- (prevSpreadIndicesActiveLen + 
                      curEventsLen) * 2
                    prevSpreadIndicesFullLen <- length(spreadsIndices)
                  }
                  spreadsIndices[addedIndices] <- events
                  prevSpreadIndicesActiveLen <- prevSpreadIndicesActiveLen + 
                    curEventsLen
                }
            }
            if (length(maxSize) > 1L) {
                if (exists("whichID", inherits = FALSE)) {
                  if (exists("toKeepSR", inherits = FALSE)) {
                    if (allowOverlapOrReturnDistances) {
                      maxSizeKeep <- !(spreads[spreads[, "active"] == 
                        1, "id"] %fin% whichID)
                      spreads <- spreads[c(rep(TRUE, sum(spreads[, 
                        "active"] == 0)), maxSizeKeep), ]
                    }
                    else {
                      if (useMatrixVersionSpreads) {
                        maxSizeKeep <- !spreads[events] %fin% 
                          whichID
                      }
                      else {
                        maxSizeKeep <- !spreadsDT$spreads[events] %fin% 
                          whichID
                      }
                    }
                    events <- events[maxSizeKeep]
                    toKeepSR <- toKeepSR[maxSizeKeep]
                  }
                  rm(whichID)
                }
            }
            else {
                if (all(size >= maxSize)) {
                  potentials <- potentials[0L, ]
                  events <- NULL
                }
            }
            if (is.function(stopRule)) {
                if (exists("toKeepSR", inherits = FALSE)) {
                  events <- events[toKeepSR]
                  if (allowOverlapOrReturnDistances) {
                    spreads[c(rep(TRUE, sum(spreads[, "active"] == 
                      0)), !toKeepSR), "active"] <- 0
                  }
                  rm(toKeepSR)
                }
            }
        }
        else {
            events <- NULL
        }
        if (exactSizes) {
            if (all(get("numRetries", inherits = FALSE, envir = .pkgEnv) < 
                10)) {
                if (spreadStateExists) {
                  tooSmall <- tabulate(spreads[, "id"], length(maxSize)) < 
                    maxSize
                  inactive <- tabulate(spreads[spreads[, "active"] == 
                    1, "id"], length(maxSize)) == 0
                }
                else {
                  if (useMatrixVersionSpreads) {
                    tooSmall <- tabulate(spreads, length(maxSize)) < 
                      maxSize
                    inactive <- tabulate(spreads[events], length(maxSize)) == 
                      0
                  }
                  else {
                    tooSmall <- tabulate(spreadsDT$spreads, length(maxSize)) < 
                      maxSize
                    inactive <- tabulate(spreadsDT$spreads[events], 
                      length(maxSize)) == 0
                  }
                }
                needPersist <- tooSmall & inactive
                needPersistJump <- TRUE
                if (any(needPersist)) {
                  assign("numRetries", envir = .pkgEnv, get("numRetries", 
                    inherits = FALSE, envir = .pkgEnv) + needPersist)
                  if (spreadStateExists) {
                    whSmallInactive <- which(tooSmall & inactive)
                    spreadsSmallInactive <- spreads[spreads[, 
                      "id"] %in% whSmallInactive, , drop = FALSE]
                    if (needPersistJump) {
                      message("Jumping to new active location, up to 1000 m away")
                      mmm <- rings(landscape, loci = spreadsSmallInactive[, 
                        "indices"], maxRadius = 1000, minRadius = 1, 
                        returnIndices = TRUE)
                      wh <- mmm[, list(whKeepLoci = resample(.I, 
                        1)), by = id]$whKeepLoci
                    }
                    else {
                      for (whSI in whSmallInactive) {
                        wh <- which(spreads[, "id"] == whSI)
                        wh <- tail(wh, 2)
                        keepLoci <- spreads[wh, "indices"]
                        events <- c(keepLoci, events)
                        spreads[wh, "active"] <- 1
                      }
                    }
                  }
                  else {
                    keepLoci <- spreads[loci] %fin% which(tooSmall & 
                      inactive)
                    events <- c(loci[keepLoci], events)
                  }
                }
            }
        }
        if (is.na(persistence) | persistence == 0L) {
            loci <- NULL
        }
        else {
            if (inRange(persistence)) {
                loci <- loci[runif(length(loci)) <= persistence]
            }
            else {
                stop("Unsupported type: persistence")
            }
        }
        if (plot.it) {
            if (n == 2 & !spreadStateExists) 
                clearPlot()
            if (allowOverlapOrReturnDistances) {
                spreadsDT <- data.table(spreads)
                hab2 <- landscape
                hab2[] <- 0
                pixVal <- spreadsDT[, sum(id), by = indices]
                hab2[pixVal$indices] <- pixVal$V1
                Plot(hab2, legendRange = c(0, sum(seq_along(initialLoci))))
            }
            else {
                plotCur <- raster(landscape)
                plotCur <- setValues(plotCur, spreads)
                Plot(plotCur)
            }
        }
        loci <- c(loci, events)
    }
    if (requireNamespace("dqrng", quietly = TRUE)) 
        set.seed(dqrng::dqsample.int(1e+09, 1) + sample.int(1e+09, 
            1))
    if (!allowOverlap & !returnDistances) {
        spreadsIndices <- spreadsIndices[1:prevSpreadIndicesActiveLen]
    }
    if (!allowOverlap & !returnDistances & !spreadStateExists) {
        wh <- if (spreadStateExists) {
            c(spreadState[!keepers]$indices, spreadsIndices)
        }
        else {
            spreadsIndices
        }
        if (returnIndices > 0) {
            wh <- wh[!(wh %in% potentials[, 2L])]
            completed <- wh %>% data.table(indices = ., id = spreadsDT$spreads[.], 
                active = FALSE)
            if (NROW(potentials) > 0) {
                active <- data.table(indices = as.integer(potentials[, 
                  2L]), id = spreadsDT$spreads[potentials[, 1L]], 
                  active = TRUE)
            }
            else {
                active <- data.table(indices = integer(0), id = integer(0), 
                  active = logical(0))
            }
        }
    }
    if (returnIndices == 1) {
        if (useMatrixVersionSpreads) {
            keepCols <- c(3, 1, 2, 4)
            if (circle) 
                keepCols <- c(keepCols, 5)
            allCells <- as.data.table(spreads[, keepCols, drop = FALSE])
            set(allCells, NULL, j = "active", as.logical(allCells$active))
        }
        else {
            allCells <- rbindlist(list(completed, active))
            if (spreadStateExists) {
                initEventID <- unique(spreadState$id)
            }
            else {
                initEventID <- allCells[indices %fin% initialLoci, 
                  id]
            }
            if (!all(is.na(initialLoci))) {
                attr(initialLoci, ".match.hash") <- NULL
                dtToJoin <- data.table(id = sort(initEventID), 
                  initialLocus = initialLoci)
            }
            else {
                dtToJoin <- data.table(id = numeric(0), initialLocus = numeric(0))
            }
            setkeyv(dtToJoin, "id")
            setkeyv(allCells, "id")
            allCells <- dtToJoin[allCells]
        }
        allCells[]
        if (exactSizes) 
            if (exists("numRetries", envir = .pkgEnv)) {
                if (sum(allCells$active) == 0) 
                  rm("numRetries", envir = .pkgEnv)
            }
        if (!(useMatrixVersionSpreads)) {
            set(spreadsDT, allCells$indices, "spreads", 0L)
            on.exit()
        }
        return(allCells)
    }
    if (returnIndices == 2) {
        return(wh)
    }
    landscape[] <- 0
    landscape@legend@colortable <- logical(0)
    if (allowOverlapOrReturnDistances) {
        if (returnDistances & !allowOverlap) {
            landscape[spreads[, "indices"]] <- spreads[, "dists"]
        }
        else {
            spreadsDTFinal <- data.table(spreads)
            if (returnDistances & allowOverlap) {
                pixVal <- spreadsDTFinal[, min(dists), by = indices]
                message("returnDistances is TRUE, allowOverlap is TRUE, but returnIndices is FALSE; ", 
                  "returning minimum distance raster.")
            }
            else {
                pixVal <- spreadsDTFinal[, sum(id), by = indices]
            }
            landscape[pixVal$indices] <- pixVal$V1
        }
    }
    else {
        landscape[wh] <- spreadsDT$spreads[wh]
        if (exists("potentials")) {
            if (NROW(potentials) > 0) {
                landscape[potentials[, 1L]] <- spreadsDT$spreads[potentials[, 
                  2L]]
                set(spreadsDT, as.integer(potentials[, 1L]), 
                  "spreads", 0L)
            }
        }
        set(spreadsDT, wh, "spreads", 0L)
    }
    return(landscape)
}
S4 Method spread:SpaDES.tools defined in namespace SpaDES.tools with signature RasterLayer has this body.
Warning in .local(x, i, j = j, ..., value) :
  restarting interrupted promise evaluation
> a[a >= 320] <- 1
> suppressWarnings(clumped <- clump(a)) # warning sometimes occurs, but not important
> aHist <- hist(table(getValues(clumped)), plot = FALSE)
> if (interactive()) {
+   clearPlot()
+   Plot(a)
+   Plot(aHist)
+ }
> 
> library(raster)
> b <- SpatialPoints(cbind(-110, 59))
> crs(b) <- sp::CRS("+init=epsg:4326")
> a <- randomPolygon(b, area = 1e6)
Warning in showSRID(uprojargs, format = "PROJ", multiline = "NO", prefer_proj = prefer_proj) :
  Discarded datum Unknown based on WGS84 ellipsoid in Proj4 definition
The CRS provided is not in meters; . Converting internally to UTM so area will be approximately correct
> if (interactive()) {
+   plot(a)
+   points(b, pch = 19)
+ }
> 
> 
> 
> 
> cleanEx()

detaching ‘package:raster’, ‘package:sp’, ‘package:quickPlot’

> nameEx("rasterizeReduced")
> ### * rasterizeReduced
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rasterizeReduced
> ### Title: Convert reduced representation to full raster
> ### Aliases: rasterizeReduced
> 
> ### ** Examples
> 
> library(data.table)
> library(raster)
Loading required package: sp
> library(quickPlot)
> 
> ras <- raster(extent(0, 15, 0, 15), res = 1)
> fullRas <- randomPolygons(ras, numTypes = 2)
> names(fullRas) <- "mapcodeAll"
> uniqueComms <- unique(fullRas)
> reducedDT <- data.table(mapcodeAll = uniqueComms,
+                         communities = sample(1:1000, length(uniqueComms)),
+                         biomass = rnbinom(length(uniqueComms), mu = 4000, 0.4))
> biomass <- rasterizeReduced(reducedDT, fullRas, "biomass")
> 
> # The default key is the layer name of the fullRas, so rekey incase of miskey
> setkey(reducedDT, biomass)
> 
> communities <- rasterizeReduced(reducedDT, fullRas, "communities")
> setColors(communities) <- c("blue", "orange", "red")
> if (interactive()) {
+   clearPlot()
+   Plot(biomass, communities, fullRas)
+ }
> 
> 
> 
> cleanEx()

detaching ‘package:quickPlot’, ‘package:raster’, ‘package:sp’,
  ‘package:data.table’

> nameEx("rings")
> ### * rings
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rings
> ### Title: Identifies all cells within a ring around the focal cells
> ### Aliases: rings rings,RasterLayer-method
> 
> ### ** Examples
> 
> library(raster)
Loading required package: sp
> library(quickPlot)
> 
> # Make random forest cover map
> emptyRas <- raster(extent(0, 1e2, 0, 1e2), res = 1)
> 
> # start from two cells near middle
> loci <- (ncell(emptyRas) / 2 - ncol(emptyRas)) / 2 + c(-3, 3)
> 
> # Allow overlap
> ## TODO: need to fix a bug when allowOverlap = TRUE
> # emptyRas[] <- 0
> # rngs <- rings(emptyRas, loci = loci, allowOverlap = TRUE, returnIndices = TRUE)
> # # Make a raster that adds together all id in a cell
> # wOverlap <- rngs[, list(sumEventID = sum(id)), by = "indices"]
> # emptyRas[wOverlap$indices] <- wOverlap$sumEventID
> # if (interactive()) {
> #  clearPlot()
> #  Plot(emptyRas)
> # }
> 
> # No overlap is default, occurs randomly
> emptyRas[] <- 0
> rngs <- rings(emptyRas, loci = loci, minRadius = 7, maxRadius = 9, returnIndices = TRUE)
> emptyRas[rngs$indices] <- rngs$id
> if (interactive()) {
+   clearPlot()
+   Plot(emptyRas)
+ }
> 
> # Variable ring widths, including centre cell for smaller one
> emptyRas[] <- 0
> rngs <- rings(emptyRas, loci = loci, minRadius = c(0, 7), maxRadius = c(8, 18),
+               returnIndices = TRUE)
> emptyRas[rngs$indices] <- rngs$id
> if (interactive()) {
+   clearPlot()
+   Plot(emptyRas)
+ }
> 
> 
> 
> cleanEx()

detaching ‘package:quickPlot’, ‘package:raster’, ‘package:sp’

> nameEx("specnumperpatch-probs")
> ### * specnumperpatch-probs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: specificNumPerPatch
> ### Title: Initiate a specific number of agents in a map of patches
> ### Aliases: specificNumPerPatch
> 
> ### ** Examples
> 
> library(data.table)
> library(raster)
Loading required package: sp
> library(quickPlot)
> 
> set.seed(1234)
> Ntypes <- 4
> ras <- randomPolygons(numTypes = Ntypes)
> if (interactive()) {
+   clearPlot()
+   Plot(ras)
+ }
> 
> # Use numPerPatchTable
> patchDT <- data.table(pops = 1:Ntypes, num.in.pop = c(1, 3, 5, 7))
> rasAgents <- specificNumPerPatch(ras, patchDT)
> rasAgents[is.na(rasAgents)] <- 0
> 
> if (require(testthat))
+   expect_true(all(unname(table(ras[rasAgents])) == patchDT$num.in.pop))
Loading required package: testthat
> 
> # Use numPerPatchMap
> rasPatches <- ras
> for (i in 1:Ntypes) {
+   rasPatches[rasPatches==i] <- patchDT$num.in.pop[i]
+ }
> if (interactive()) {
+   clearPlot()
+   Plot(ras, rasPatches)
+ }
> rasAgents <- specificNumPerPatch(ras, numPerPatchMap = rasPatches)
> rasAgents[is.na(rasAgents)] <- 0
> if (interactive()) {
+   clearPlot()
+   Plot(rasAgents)
+ }
> 
> 
> 
> 
> cleanEx()

detaching ‘package:testthat’, ‘package:quickPlot’, ‘package:raster’,
  ‘package:sp’, ‘package:data.table’

> nameEx("splitRaster")
> ### * splitRaster
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mergeRaster
> ### Title: Split and re-merge 'RasterLayer'(s)
> ### Aliases: mergeRaster mergeRaster,list-method splitRaster
> ###   splitRaster,RasterLayer-method
> 
> ### ** Examples
> 
> library(raster)
Loading required package: sp
> library(Require)
> 
> # an example with dimensions:
> # nrow: 77
> # ncol: 101
> # nlayers: 3
> b <- brick(system.file("external/rlogo.grd", package = "raster"))
> r <- b[[1]] # use first layer only
> nx <- 1
> ny <- 2
> 
> tmpdir <- checkPath(file.path(tempdir(), "splitRaster-example"), create = TRUE)
> 
> y0 <- splitRaster(r, nx, ny, path = file.path(tmpdir, "y0")) # no buffer
> 
> # buffer: 10 pixels along both axes
> y1 <- splitRaster(r, nx, ny, c(10, 10), path = file.path(tmpdir, "y1"))
> 
> # buffer: half the width and length of each tile
> y2 <- splitRaster(r, nx, ny, c(0.5, 0.5), path = file.path(tmpdir, "y2"))
> 
> # parallel cropping
> if (interactive()) {
+   n <- pmin(parallel::detectCores(), 4) # use up to 4 cores
+   beginCluster(n)
+   y3 <- splitRaster(r, nx, ny, c(0.7, 0.7), path = file.path(tmpdir, "y3"))
+   endCluster()
+ }
> 
> # the original raster:
> if (interactive()) plot(r) # may require a call to `dev()` if using RStudio
> 
> # the split raster:
> layout(mat = matrix(seq_len(nx * ny), ncol = nx, nrow = ny))
> plotOrder <- c(4, 8, 12, 3, 7, 11, 2, 6, 10, 1, 5, 9)
> if (interactive()) invisible(lapply(y0[plotOrder], plot))
> 
> # can be recombined using `raster::merge`
> m0 <- do.call(merge, y0)
> all.equal(m0, r) ## TRUE
[1] TRUE
> 
> m1 <- do.call(merge, y1)
> all.equal(m1, r) ## TRUE
[1] TRUE
> 
> m2 <- do.call(merge, y2)
> all.equal(m2, r) ## TRUE
[1] TRUE
> 
> # or recombine using mergeRaster
> n0 <- mergeRaster(y0)
> all.equal(n0, r) ## TRUE
[1] TRUE
> 
> n1 <- mergeRaster(y1)
> all.equal(n1, r) ## TRUE
[1] TRUE
> 
> n2 <- mergeRaster(y2)
> all.equal(n2, r) ## TRUE
[1] TRUE
> 
> unlink(tmpdir, recursive = TRUE)
> 
> 
> 
> cleanEx()

detaching ‘package:Require’, ‘package:raster’, ‘package:sp’

> nameEx("spokes")
> ### * spokes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: spokes
> ### Title: Identify outward radiating spokes from initial points
> ### Aliases: spokes spokes,RasterLayer,SpatialPoints,missing-method
> 
> ### ** Examples
> 
> library(sp)
> library(raster)
> library(quickPlot)
> 
> set.seed(1234)
> 
> ras <- raster(extent(0, 10, 0, 10), res = 1, val = 0)
> rp <- randomPolygons(ras, numTypes = 10)
> 
> clearPlot()
> Plot(rp)
> 
> angles <- seq(0, pi * 2, length.out = 17)
> angles <- angles[-length(angles)]
> n <- 2
> loci <- sample(ncell(rp), n)
> coords <- SpatialPoints(xyFromCell(rp, loci))
> stopRule <- function(landscape) landscape < 3
> d2 <- spokes(rp, coords = coords, stopRule = stopRule,
+              minRadius = 0, maxRadius = 50,
+              returnAngles = TRUE, returnDistances = TRUE,
+              allowOverlap = TRUE, angles = angles, returnIndices = TRUE)
> 
> # Assign values to the "patches" that were in the viewshed of a ray
> rasB <- raster(ras)
> rasB[] <- 0
> rasB[d2[d2[, "stop"] == 1, "indices"]] <- 1
> 
> Plot(rasB, addTo = "rp", zero.color = "transparent", cols = "red")
> 
> if (NROW(d2) > 0) {
+   sp1 <- SpatialPoints(d2[, c("x", "y")])
+   Plot(sp1, addTo = "rp", pch = 19, size = 5, speedup = 0.1)
+ }
> Plot(coords, addTo = "rp", pch = 19, size = 6, cols = "blue", speedup = 0.1)
> 
> clearPlot()
> 
> 
> 
> cleanEx()

detaching ‘package:quickPlot’, ‘package:raster’, ‘package:sp’

> nameEx("spread")
> ### * spread
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: spread
> ### Title: Simulate a spread process on a landscape.
> ### Aliases: spread spread,RasterLayer-method
> 
> ### ** Examples
> 
> library(raster)
Loading required package: sp
> library(RColorBrewer)
> library(quickPlot)
> 
> # Make random forest cover map
> set.seed(123)
> emptyRas <- raster(extent(0, 1e2, 0, 1e2), res = 1)
> hab <- randomPolygons(emptyRas, numTypes = 40)
> names(hab) <- "hab"
> mask <- raster(emptyRas)
> mask <- setValues(mask, 0)
> mask[1:5000] <- 1
> numCol <- ncol(emptyRas)
> numCell <- ncell(emptyRas)
> directions <- 8
> 
> # Can use transparent as a colour
> setColors(hab) <- paste(c("transparent", brewer.pal(8, "Greys")))
> 
> # note speedup is equivalent to making pyramids, so, some details are lost
> clearPlot()
> Plot(hab, speedup = 3)
> 
> # initiate 10 fires
> startCells <- as.integer(sample(1:ncell(emptyRas), 100))
> fires <- spread(hab, loci = startCells, 0.235, persistence = 0, numNeighs = 2,
+                 mask = NULL, maxSize = 1e8, directions = 8, iterations = 1e6, id = TRUE)
> 
> #set colours of raster, including a transparent layer for zeros
> setColors(fires, 10) <- c("transparent", brewer.pal(8, "Reds")[5:8])
> Plot(fires)
> Plot(fires, addTo = "hab")
> 
> #alternatively, set colours using cols= in the Plot function
> clearPlot()
> Plot(hab)
> Plot(fires) # default colour range makes zero transparent.
> 
> # Instead, to give a colour to the zero values, use \code{zero.color=}
> Plot(fires, addTo = "hab",
+      cols = colorRampPalette(c("orange", "darkred"))(10), zero.color = "transparent")
> 
> hab2 <- hab
> Plot(hab2)
> Plot(fires, addTo = "hab2", zero.color = "transparent",
+    cols = colorRampPalette(c("orange", "darkred"))(10))
> # or overplot the original (NOTE: legend stays at original values)
> Plot(fires, cols = topo.colors(10), new = TRUE, zero.color = "white")
> 
> ##------------------------------------------------------------------------------
> ## Continue event by passing interrupted object into spreadState
> ##------------------------------------------------------------------------------
> 
> ## Interrupt a spread event using iterations - need `returnIndices = TRUE` to
> ##  use outputs as new inputs in next iteration
> fires <- spread(hab, loci = as.integer(sample(1:ncell(hab), 10)),
+                 returnIndices = TRUE, 0.235, 0, NULL, 1e8, 8, iterations = 3, id = TRUE)
> fires[, list(size = length(initialLocus)), by = id]  # See sizes of fires
    id size
 1:  1    1
 2:  2    4
 3:  3    6
 4:  4    2
 5:  5    9
 6:  6   11
 7:  7    6
 8:  8   11
 9:  9   11
10: 10    9
> 
> fires2 <- spread(hab, loci = NA_real_, returnIndices = TRUE, 0.235, 0, NULL,
+                  1e8, 8, iterations = 2, id = TRUE, spreadState = fires)
> # NOTE events are assigned arbitrary IDs, starting at 1
> 
> ## Add new fires to the already burning fires
> fires3 <- spread(hab, loci = as.integer(sample(1:ncell(hab), 10)),
+                  returnIndices = TRUE, 0.235, 0, NULL, 1e8, 8, iterations = 1,
+                  id = TRUE, spreadState = fires)
> fires3[, list(size = length(initialLocus)), by = id]  # See sizes of fires
    id size
 1:  1    1
 2:  2    4
 3:  3   14
 4:  4    2
 5:  5   12
 6:  6   16
 7:  7   10
 8:  8   14
 9:  9   16
10: 10   13
> # NOTE old ids are maintained, new events get ids begining above previous
> # maximum (e.g., new fires 11 to 20 here)
> 
> ## Use data.table and loci...
> fires <- spread(hab, loci = as.integer(sample(1:ncell(hab), 10)),
+                 returnIndices = TRUE, 0.235, 0, NULL, 1e8, 8, iterations = 2, id = TRUE)
> fullRas <- raster(hab)
> fullRas[] <- 1:ncell(hab)
> burned <- fires[active == FALSE]
> burnedMap <- rasterizeReduced(burned, fullRas, "id", "indices")
> 
> clearPlot()
> Plot(burnedMap, new = TRUE)
> 
> ####################
> ## stopRule examples
> ####################
> 
> # examples with stopRule, which means that the eventual size is driven by the values on the raster
> #  passed in to the landscape argument
> set.seed(1234)
> stopRule1 <- function(landscape) sum(landscape) > 50
> stopRuleA <- spread(hab, loci = as.integer(sample(1:ncell(hab), 10)), 1, 0, NULL,
+                     maxSize = 1e6, 8, 1e6, id = TRUE, circle = TRUE, stopRule = stopRule1)
> 
> set.seed(1234)
> stopRule2 <- function(landscape) sum(landscape) > 100
> # using stopRuleBehavior = "excludePixel"
> stopRuleB <- spread(hab, loci = as.integer(sample(1:ncell(hab), 10)), 1, 0, NULL,
+                     maxSize = 1e6, 8, 1e6, id = TRUE, circle = TRUE, stopRule = stopRule2,
+                     stopRuleBehavior = "excludePixel")
> 
> # using stopRuleBehavior = "includeRing", means that end result is slightly larger patches, as a
> #  complete "iteration" of the spread algorithm is used.
> set.seed(1234)
> stopRuleBNotExact <- spread(hab, loci = as.integer(sample(1:ncell(hab), 10)), 1, 0,
+                              NULL, maxSize = 1e6, 8, 1e6, id = TRUE, circle = TRUE,
+                              stopRule = stopRule2)
> clearPlot()
> Plot(stopRuleA, stopRuleB, stopRuleBNotExact)
> 
> # Test that the stopRules work
> # stopRuleA was not exact, so each value will "overshoot" the stopRule, here it was hab>50
> foo <- cbind(vals = hab[stopRuleA], id = stopRuleA[stopRuleA > 0]);
> tapply(foo[, "vals"], foo[, "id"], sum) # Correct ... all are above 50
  1   2   3   4   5   6   7   8   9  10 
185  55  95  95 135 130 165 150 125  90 
> 
> # stopRuleB was exact, so each value will be as close as possible while rule still is TRUE
> #  Because we have discrete cells, these numbers will always slightly under the rule
> foo <- cbind(vals = hab[stopRuleB], id = stopRuleB[stopRuleB > 0]);
> tapply(foo[, "vals"], foo[, "id"], sum) # Correct ... all are above 50
  1   2   3   4   5   6   7   8   9  10 
 74  99  95  95  81 100  99  90  79  90 
> 
> # stopRuleB_notExact will overshoot
> foo <- cbind(vals = hab[stopRuleBNotExact], id = stopRuleBNotExact[stopRuleBNotExact > 0]);
> tapply(foo[, "vals"], foo[, "id"], sum) # Correct ... all are above 50
  1   2   3   4   5   6   7   8   9  10 
185 137 247 247 135 130 165 150 125 234 
> 
> # Cellular automata shapes
> # Diamonds - can make them with: a boolean raster, directions = 4,
> #    stopRule in place, spreadProb = 1
> diamonds <- spread(hab > 0, spreadProb = 1, directions = 4, id = TRUE, stopRule = stopRule2)
> 
> clearPlot()
> Plot(diamonds)
> 
> # Squares - can make them with: a boolean raster, directions = 8,
> #    stopRule in place, spreadProb = 1
> squares <- spread(hab > 0, spreadProb = 1, directions = 8, id = TRUE, stopRule = stopRule2)
> Plot(squares)
> 
> # Interference shapes - can make them with: a boolean raster, directions = 8,
> #    stopRule in place, spreadProb = 1
> stopRule2 <- function(landscape) sum(landscape) > 200
> squashedDiamonds <- spread(hab > 0, spreadProb = 1,
+                            loci = (ncell(hab) - ncol(hab)) / 2 + c(4, -4),
+                            directions = 4, id = TRUE, stopRule = stopRule2)
> clearPlot()
> Plot(squashedDiamonds)
> 
> # Circles with spreadProb < 1 will give "more" circular shapes, but definitely not circles
> stopRule2 <- function(landscape) sum(landscape) > 200
> seed <- sample(1e4, 1)
> set.seed(seed)
> circlish <- spread(hab > 0, spreadProb = 0.23,
+                    loci = (ncell(hab) - ncol(hab)) / 2 + c(4, -4),
+                    directions = 8, id = TRUE, circle = TRUE)#, stopRule = stopRule2)
> set.seed(seed)
> regularCA <- spread(hab > 0, spreadProb = 0.23,
+                     loci = (ncell(hab) - ncol(hab)) / 2 + c(4, -4),
+                     directions = 8, id = TRUE)#, stopRule = stopRule2)
> 
> clearPlot()
> Plot(circlish, regularCA)
> 
> ####################
> # complex stopRule
> ####################
> 
> initialLoci <- sample(seq_len(ncell(hab)), 2)
> endSizes <- seq_along(initialLoci) * 200
> 
> # Can be a function of landscape, id, and/or any other named
> #   variable passed into spread
> stopRule3 <- function(landscape, id, endSizes) sum(landscape) > endSizes[id]
> 
> twoCirclesDiffSize <- spread(hab, spreadProb = 1, loci = initialLoci, circle = TRUE,
+                              directions = 8, id = TRUE, stopRule = stopRule3,
+                              endSizes = endSizes, stopRuleBehavior = "excludePixel")
> 
> # or using named list of named elements:
> twoCirclesDiffSize2 <- spread(hab, spreadProb = 1, loci = initialLoci, circle = TRUE,
+                              directions = 8, id = TRUE, stopRule = stopRule3,
+                              vars = list(endSizes = endSizes), stopRuleBehavior = "excludePixel")
> 
> identical(twoCirclesDiffSize, twoCirclesDiffSize2) ## TRUE
[1] FALSE
> 
> clearPlot()
> Plot(twoCirclesDiffSize)
> 
> cirs <- getValues(twoCirclesDiffSize)
> vals <- tapply(hab[twoCirclesDiffSize], cirs[cirs > 0], sum)
> 
> # Stop if sum of landscape is big or mean of quality is too small
> quality <- raster(hab)
> quality[] <- runif(ncell(quality), 0, 1)
> stopRule4 <- function(landscape, quality, cells) {
+   (sum(landscape) > 20) | (mean(quality[cells]) < 0.3)
+ }
> 
> twoCirclesDiffSize <- spread(hab, spreadProb = 1, loci = initialLoci, circle = TRUE,
+                              directions = 8, id = TRUE, stopRule = stopRule4,
+                              quality = quality, stopRuleBehavior = "excludePixel")
> 
> ##############
> # allowOverlap
> ##############
> ## TODO: fix error when allowOverlap = TRUE
> # set.seed(3113)
> # initialLoci <- as.integer(sample(1:ncell(hab), 10))
> #
> # # using "landscape", "id", and a variable passed in
> # maxVal <- rep(500, length(initialLoci))
> #
> # # define stopRule
> # stopRule2 <- function(landscape, id, maxVal) sum(landscape) > maxVal[id]
> # circs <- spread(hab, spreadProb = 1, circle = TRUE, loci = initialLoci, stopRule = stopRule2,
> #                 id = TRUE, allowOverlap = TRUE, stopRuleBehavior = "includeRing",
> #                 maxVal = maxVal, returnIndices = TRUE)
> # (vals <- tapply(hab[circs$indices], circs$id, sum))
> # vals <= maxVal ## all TRUE
> # overlapEvents <- raster(hab)
> # overlapEvents[] <- 0
> # toMap <- circs[, sum(id), by = indices]
> # overlapEvents[toMap$indices] <- toMap$V1
> #
> # clearPlot()
> # Plot(overlapEvents)
> 
> ## Using alternative algorithm, not probabilistic diffusion
> ## Will give exactly correct sizes, yet still with variability
> ## within the spreading (i.e., cells with and without successes)
> seed <- sample(1e6, 1)
> set.seed(seed)
> startCells <- startCells[1:4]
> maxSizes <- rexp(length(startCells), rate = 1 / 500)
> fires <- spread(hab, loci = startCells, 1, persistence = 0,
+                 neighProbs = c(0.5, 0.5, 0.5) / 1.5,
+                 mask = NULL, maxSize = maxSizes, directions = 8,
+                 iterations = 1e6, id = TRUE, plot.it = FALSE, exactSizes = TRUE);
> all(table(fires[fires > 0][]) == floor(maxSizes))
[1] TRUE
> 
> dev()
> clearPlot()
> Plot(fires, new = TRUE, cols = c("red", "yellow"), zero.color = "white")
> Plot(hist(table(fires[][fires[] > 0])), title = "fire size distribution")
> 
> ## Example with relativeSpreadProb ... i.e., a relative probability spreadProb
> ##  (shown here because because spreadProb raster is not a probability).
> ##  Here, we force the events to grow, choosing always 2 neighbours,
> ##  according to the relative probabilities contained on hab layer.
> ##
> ## Note: `neighProbs = c(0,1)` forces each active pixel to move to 2 new pixels
> ## (`prob = 0` for 1 neighbour, `prob = 1` for 2 neighbours)
> ##
> ## Note: set hab3 to be very distinct probability differences, to detect spread
> ##  differences
> hab3 <- (hab < 20) * 200 + 1
> seed <- 643503
> set.seed(seed)
> sam <- sample(which(hab3[] == 1), 1)
> set.seed(seed)
> events1 <- spread(hab3, spreadProb = hab3, loci = sam, directions = 8,
+              neighProbs = c(0, 1), maxSize = c(70), exactSizes = TRUE)
> 
> # Compare to absolute probability version
> set.seed(seed)
> events2 <- spread(hab3, id = TRUE, loci = sam, directions = 8,
+                  neighProbs = c(0, 1), maxSize = c(70), exactSizes = TRUE)
> 
> clearPlot()
> Plot(events1, new = TRUE, cols = c("red", "yellow"), zero.color = "white")
> Plot(events2, new = TRUE, cols = c("red", "yellow"), zero.color = "white")
> Plot(hist(table(events1[][events1[] > 0]), breaks = 30), title = "Event size distribution")
> # Check that events1 resulted in higher hab3 pixels overall
> 
> # Compare outputs -- should be more high value hab pixels spread to in event1
> #  (randomness may prevent this in all cases)
> hab3[events1[] > 0]
 [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
[39] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
> hab3[events2[] > 0]
 [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
[39] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
> 
> sum(hab3[events1[] > 0]) >= sum(hab3[events2[] > 0]) ## should be usually TRUE
[1] TRUE
> 
> 
> 
> cleanEx()

detaching ‘package:quickPlot’, ‘package:RColorBrewer’,
  ‘package:raster’, ‘package:sp’

> nameEx("spread2")
> ### * spread2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: spread2
> ### Title: Simulate a contagious spread process on a landscape, with
> ###   data.table internals
> ### Aliases: spread2
> 
> ### ** Examples
> 
> library(data.table)
> library(raster)
Loading required package: sp
> library(quickPlot)
> 
> data.table::setDTthreads(1)
> 
> a <- raster(extent(0, 10, 0, 10), res = 1)
> sams <- sort(sample(ncell(a), 3))
> 
> # Simple use -- similar to spread(...)
> out <- spread2(a, start = sams, 0.225)
> if (interactive()) {
+   clearPlot()
+   Plot(out)
+ }
> 
> # Use maxSize -- this gives an upper limit
> maxSizes <- sort(sample(1:10, size = length(sams)))
> out <- spread2(a, start = sams, 0.225, maxSize = maxSizes, asRaster = FALSE)
> # check TRUE using data.table .N
> out[, .N, by = "initialPixels"]$N <= maxSizes
[1] TRUE TRUE TRUE
> 
> # Use exactSize -- gives an exact size, if there is enough space on the Raster
> exactSizes <- maxSizes
> out <- spread2(a, start = sams, spreadProb = 0.225,
+                exactSize = exactSizes, asRaster = FALSE)
> out[, .N, by = "initialPixels"]$N == maxSizes # should be TRUE TRUE TRUE
[1] TRUE TRUE TRUE
> 
> # Use exactSize -- but where it can't be achieved
> exactSizes <- sort(sample(100:110, size = length(sams)))
> out <- spread2(a, start = sams, 1, exactSize = exactSizes)
> 
> # Iterative calling -- create a function with a high escape probability
> spreadWithEscape <- function(ras, start, escapeProb, spreadProb) {
+   out <- spread2(ras, start = sams, spreadProb = escapeProb, asRaster = FALSE)
+   while (any(out$state == "sourceActive")) {
+     # pass in previous output as start
+     out <- spread2(ras, start = out, spreadProb = spreadProb,
+                     asRaster = FALSE, skipChecks = TRUE) # skipChecks for speed
+   }
+   out
+ }
> 
> set.seed(421)
> out1 <- spreadWithEscape(a, sams, escapeProb = 0.25, spreadProb = 0.225)
> set.seed(421)
> out2 <- spread2(a, sams, 0.225, asRaster = FALSE)
> # The one with high escape probability is larger (most of the time)
> NROW(out1) > NROW(out2)
[1] FALSE
> 
> ## Use neighProbs, with a spreadProb that is a RasterLayer
> # Create a raster of different values, which will be the relative probabilities
> #   i.e., they are rescaled to relative probabilities within the 8 neighbour choices.
> #   The neighProbs below means 70% of the time, 1 neighbour will be chosen,
> #   30% of the time 2 neighbours.
> #   The cells with spreadProb of 5 are 5 times more likely than cells with 1 to be chosen,
> #   when they are both within the 8 neighbours
> sp <- raster(extent(0, 3, 0, 3), res = 1, vals = 1:9) #small raster, simple values
> # Check neighProbs worked
> out <- list()
> 
> # enough replicates to see stabilized probabilities
> for (i in 1:100) {
+   out[[i]] <- spread2(sp, spreadProbRel = sp, spreadProb = 1,
+                       start = 5, iterations = 1,
+                       neighProbs = c(1), asRaster = FALSE)
+ }
> out <- data.table::rbindlist(out)[pixels != 5] # remove starting cell
> table(sp[out$pixels])

 1  2  3  4  6  7  8  9 
 3  5  8  8 17 13 26 20 
> # should be non-significant -- note no 5 because that was the starting cell
> #  This tests whether the null model is true ... there should be proportions
> #  equivalent to 1:2:3:4:6:7:8:9 ... i.e,. cell 9 should have 9x as many events
> #  spread to it as cell 1. This comes from sp object above which is providing
> #  the relative spread probabilities
> keep <- c(1:4, 6:9)
> chisq.test(keep, unname(tabulate(sp[out$pixels], 9)[keep]), simulate.p.value = TRUE)

	Pearson's Chi-squared test with simulated p-value (based on 2000
	replicates)

data:  keep and unname(tabulate(sp[out$pixels], 9)[keep])
X-squared = 48, df = NA, p-value = 1

> 
> ## Example showing asymmetry
> sams <- ncell(a) / 4 - ncol(a) / 4 * 3
> circs <- spread2(a, spreadProb = 0.213, start = sams,
+                  asymmetry = 2, asymmetryAngle = 135,
+                  asRaster = TRUE)
> 
> ## ADVANCED: Estimate spreadProb when using asymmetry, such that the expected
> ##   event size is the same as without using asymmetry
> ## Not run: 
> ##D   if (interactive()) {
> ##D     ras <- raster(a)
> ##D     ras[] <- 1
> ##D 
> ##D     n <- 100
> ##D     sizes <- integer(n)
> ##D     for (i in 1:n) {
> ##D       circs <- spread2(ras, spreadProb = 0.225,
> ##D                        start = round(ncell(ras) / 4 - ncol(ras) / 4 * 3),
> ##D                        asRaster = FALSE)
> ##D       sizes[i] <- circs[, .N]
> ##D     }
> ##D     goalSize <- mean(sizes)
> ##D 
> ##D     library(parallel)
> ##D     library(DEoptim)
> ##D     cl <- makeCluster(pmin(10, detectCores() - 2)) # need 10 cores for 10 populations in DEoptim
> ##D     parallel::clusterEvalQ(cl, {
> ##D       library(SpaDES.tools)
> ##D       library(raster)
> ##D       library(fpCompare)
> ##D     })
> ##D 
> ##D     objFn <- function(sp, n = 20, ras, goalSize) {
> ##D       sizes <- integer(n)
> ##D       for (i in 1:n) {
> ##D         circs <- spread2(ras, spreadProb = sp, start = ncell(ras) / 4 - ncol(ras) / 4 * 3,
> ##D                          asymmetry = 2, asymmetryAngle = 135,
> ##D                          asRaster = FALSE)
> ##D         sizes[i] <- circs[, .N]
> ##D       }
> ##D       abs(mean(sizes) - goalSize)
> ##D     }
> ##D     aa <- DEoptim(objFn, lower = 0.2, upper = 0.23,
> ##D                   control = DEoptim.control(cluster = cl, NP = 10, VTR = 0.02,
> ##D                                             initialpop = as.matrix(rnorm(10, 0.213, 0.001))),
> ##D                   ras = a, goalSize = goalSize)
> ##D 
> ##D     # The value of spreadProb that will give the same expected event sizes to spreadProb = 0.225 is:
> ##D     sp <- aa$optim$bestmem
> ##D     circs <- spread2(ras, spreadProb = sp, start = ncell(ras) / 4 - ncol(ras) / 4 * 3,
> ##D                       asymmetry = 2, asymmetryAngle = 135, asRaster = FALSE)
> ##D 
> ##D     stopCluster(cl)
> ##D   }
> ## End(Not run)
> 
> 
> 
> cleanEx()

detaching ‘package:quickPlot’, ‘package:raster’, ‘package:sp’,
  ‘package:data.table’

> nameEx("spread3")
> ### * spread3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: spread3
> ### Title: An alternative spread function, conceived for insects
> ### Aliases: spread3
> 
> ### ** Examples
> 
> ## these tests are fairly heavy, so don't run during automated tests
> if (interactive() && require("RandomFields")) {
+   #########################################################
+   # Simple case, no variation in rasQuality, numeric advectionDir and advectionMag
+   #########################################################
+   library(raster)
+   library(quickPlot)
+   maxDim <- 10000
+   ras <- raster::raster(extent(c(0, maxDim, 0, maxDim)), res = 100, vals = 0)
+   rasQuality <- raster(ras)
+   rasQuality[] <- 1
+   rasAbundance <- raster(rasQuality)
+   rasAbundance[] <- 0
+   # startPixel <- middlePixel(rasAbundance)
+   startPixel <- sample(seq(ncell(rasAbundance)), 30)
+   rasAbundance[startPixel] <- 1000
+   advectionDir <- 70
+   advectionMag <- 4 * res(rasAbundance)[1]
+   meanDist <- 2600
+ 
+    if (interactive()) {
+      # Test the dispersal kernel -- create a function
+      plotDispersalKernel <- function(out, meanAdvectionMag) {
+        out[, disGroup := round(distance / 100) * 100]
+        freqs <- out[, .N, by = "disGroup"]
+        freqs[, `:=`(cumSum = cumsum(N), N = N)]
+        Plot(freqs$disGroup, freqs$cumSum, addTo = "CumulativeNumberSettled",
+             title = "Cumulative Number Settled") # can plot the distance X number
+        abline(v = meanAdvectionMag + meanDist)
+        newTitle <- "Number Settled By Distance"
+        Plot(freqs$disGroup, freqs$N, addTo = gsub(" ", "", newTitle),
+             title = newTitle) # can plot the distance X number
+        abline(v = meanAdvectionMag + meanDist)
+        # should be 0.63:
+        freqs[disGroup == meanAdvectionMag + meanDist, cumSum] / tail(freqs,1)[, cumSum]
+        mtext(side = 3, paste("Average habitat quality: ",
+              round(mean(rasQuality[], na.rm = TRUE), 2)),
+              outer = TRUE, line = -2, cex = 2)
+     }
+     dev() # don't use Rstudio windows, which is very slow
+     clearPlot()
+     out <- spread3(rasAbundance = rasAbundance,
+                    rasQuality = rasQuality,
+                    advectionDir = advectionDir,
+                    advectionMag = advectionMag,
+                    meanDist = meanDist, verbose = 2,
+                    plot.it = 2)
+ 
+     plotDispersalKernel(out, advectionMag)
+   }
+ 
+   #########################################################
+   ### The case of variable quality raster
+   #########################################################
+   if (require(sf) && require(fasterize)) {
+     library(SpaDES.tools) # for gaussMap
+     a <- randomStudyArea(size = 1e9)
+     ras <- raster(extent(a), res = 100)
+     mask <- fasterize(st_as_sf(a), ras) # faster than raster::rasterize
+     rasQuality <- gaussMap(ras)
+     crs(rasQuality) <- crs(a)
+     rasQuality[is.na(mask)] <- NA
+     # rescale so min is 0.75 and max is 1
+     rasQuality[] <- rasQuality[] / (maxValue(rasQuality) * 4 ) + 1/4
+     rasAbundance <- raster(rasQuality)
+     rasAbundance[] <- 0
+     startPixel <- sample(seq(ncell(rasAbundance)), 300)
+     rasAbundance[startPixel] <- 1000
+     advectionDir <- 75
+     advectionMag <- 4 * res(rasAbundance)[1]
+     meanDist <- 2600
+     clearPlot()
+     out <- spread3(rasAbundance = rasAbundance,
+                    rasQuality = rasQuality,
+                    advectionDir = advectionDir,
+                    advectionMag = advectionMag,
+                    meanDist = meanDist, verbose = 2,
+                    plot.it = 1)
+     if (interactive()) {
+       plotDispersalKernel(out, advectionMag)
+     }
+   }
+ 
+   ###############################################################################
+   ### The case of variable quality raster, raster for advectionDir & advectionMag
+   ###############################################################################
+   library(raster)
+   library(quickPlot)
+   library(SpaDES.tools)
+   maxDim <- 10000
+   ras <- raster(extent(c(0, maxDim, 0, maxDim)), res = 100, vals = 0)
+   rasQuality <- raster(ras)
+   rasQuality[] <- 1
+   rasAbundance <- raster(rasQuality)
+   rasAbundance[] <- NA
+   # startPixel <- middlePixel(rasAbundance)
+   startPixel <- sample(seq(ncell(rasAbundance)), 25)
+   rasAbundance[startPixel] <- 1000
+ 
+   # raster for advectionDir
+   advectionDir <- gaussMap(ras)
+   crs(advectionDir) <- crs(rasQuality)
+   # rescale so min is 0.75 and max is 1
+   advectionDir[] <- advectionDir[] / (maxValue(advectionDir)) * 180
+ 
+   # raster for advectionMag
+   advectionMag <- gaussMap(ras)
+   crs(advectionMag) <- crs(rasQuality)
+   # rescale so min is 0.75 and max is 1
+   advectionMag[] <- advectionMag[] / (maxValue(advectionMag)) * 600
+ 
+   out <- spread3(rasAbundance = rasAbundance,
+                  rasQuality = rasQuality,
+                  advectionDir = advectionDir,
+                  advectionMag = advectionMag,
+                  meanDist = meanDist, verbose = 2,
+                  plot.it = 1)
+ 
+   if (interactive()) {
+     dev() # don't use Rstudio windows, which is very slow
+     clearPlot()
+     Plot(advectionDir, title = "Wind direction", cols = "Reds")
+     Plot(advectionMag, title = "Wind speed", cols = "Blues")
+     plotDispersalKernel(out, mean(advectionMag[]))
+     Plot(rasAbundance, addTo = "rasAbundance", cols = "black", title = "")
+   }
+ 
+   #########################################
+   # save iterations to a stack to make animated GIF
+   ########################################
+   tmpStack <- raster::rasterTmpFile("stackToAnimate")
+   out <- spread3(rasAbundance = rasAbundance,
+                  rasQuality = rasQuality,
+                  advectionDir = advectionDir,
+                  advectionMag = advectionMag,
+                  meanDist = 2600, verbose = 2,
+                  plot.it = 0, saveStack = tmpStack)
+ 
+   ## This animates the series of images into an animated GIF
+   if (require(animation, quietly = TRUE)) {
+     out2 <- raster::stack(tmpStack)
+     gifName <- file.path(tempdir(), "animation.gif")
+     saveGIF(interval = 0.1, movie.name = gifName, expr = {
+       for (i in seq(numLayers(out2))) plot(out2[[i]])
+     })
+   }
+ }
> 
> 
> 
> cleanEx()
> nameEx("wrap")
> ### * wrap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: wrap
> ### Title: Wrap coordinates or pixels in a torus-like fashion
> ### Aliases: wrap wrap,matrix,Extent,missing-method
> ###   wrap,SpatialPoints,ANY,missing-method
> ###   wrap,matrix,Raster,missing-method wrap,matrix,matrix,missing-method
> ###   wrap,SpatialPointsDataFrame,Extent,logical-method
> ###   wrap,SpatialPointsDataFrame,Raster,logical-method
> ###   wrap,SpatialPointsDataFrame,matrix,logical-method
> 
> ### ** Examples
> 
> library(raster)
Loading required package: sp
> library(quickPlot)
> 
> xrange <- yrange <- c(-50, 50)
> hab <- raster(extent(c(xrange, yrange)))
> hab[] <- 0
> 
> # initialize agents
> N <- 10
> 
> # previous points
> x1 <- rep(0, N)
> y1 <- rep(0, N)
> # initial points
> starts <- cbind(x = stats::runif(N, xrange[1], xrange[2]),
+                 y = stats::runif(N, yrange[1], yrange[2]))
> 
> # create the agent object
> agent <- SpatialPointsDataFrame(coords = starts, data = data.frame(x1, y1))
> 
> 
> ln <- rlnorm(N, 1, 0.02) # log normal step length
> sd <- 30 # could be specified globally in params
> 
> if (interactive()) {
+   clearPlot()
+   Plot(hab, zero.color = "white", axes = "L")
+ }
> for (i in 1:10) {
+   agent <- crw(agent = agent, extent = extent(hab), stepLength = ln,
+                stddev = sd, lonlat = FALSE, torus = TRUE)
+   if (interactive()) Plot(agent, addTo = "hab", axes = TRUE)
+ }
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()

detaching ‘package:quickPlot’, ‘package:raster’, ‘package:sp’

> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  162.393 5.951 173.136 0.223 0.401 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
