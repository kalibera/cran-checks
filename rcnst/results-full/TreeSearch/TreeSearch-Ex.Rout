
R Under development (unstable) (2025-05-30 r88253) -- "Unsuffered Consequences"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "TreeSearch"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('TreeSearch')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("AdditionTree")
> ### * AdditionTree
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: AdditionTree
> ### Title: Addition tree
> ### Aliases: AdditionTree
> 
> ### ** Examples
> 
> data("inapplicable.phyData", package = "TreeSearch")
> AdditionTree(inapplicable.phyData[["Longrich2010"]], concavity = 10)

Phylogenetic tree with 20 tips and 19 internal nodes.

Tip labels:
  Psittacosaurus_spp, Stegoceras_validum, Sphaerotholus_brevis, Thescelosaurus_neglectus, Colepiocephale_lambei, Prenocephale_prenes, ...

Rooted; no branch length.
> 
> 
> 
> cleanEx()
> nameEx("Carter1")
> ### * Carter1
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Carter1
> ### Title: Number of trees with _m_ steps
> ### Aliases: Carter1 Log2Carter1 LogCarter1
> 
> ### ** Examples
> 
> # The character `0 0 0 1 1 1`
> Carter1(1, 3, 3) # Exactly one step
[1] 9
> Carter1(2, 3, 3) # Two steps (one extra step)
[1] 54
> 
> # Number of trees that the character can map onto with exactly _m_ steps
> # if non-parsimonious reconstructions are permitted:
> cumsum(sapply(1:3, Carter1, 3, 3))
[1]   9  63 105
> 
> # Three steps allow the character to map onto any of the 105 six-leaf trees.
> 
> 
> 
> 
> cleanEx()
> nameEx("CharacterLength")
> ### * CharacterLength
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CharacterLength
> ### Title: Character length
> ### Aliases: CharacterLength FitchSteps FastCharacterLength
> 
> ### ** Examples
> 
> data("inapplicable.datasets")
> dataset <- inapplicable.phyData[[12]]
> tree <- TreeTools::NJTree(dataset)
> CharacterLength(tree, dataset)
  [1]  1  1  2  2  3  4  4  5  1  6  1  1  2  1  2  4  2  5  2  4  1  1  2  1  1
 [26]  2  2  2  5  1  1  1  2  1  4  3  6  5  5  1  2  1  2  1  1  1  1  1  1  1
 [51]  2  1  1  8  3  7  3  3  2  5  2  1  2  2  2  9 10  5  5  2  4  3  5  1  1
 [76]  5  6  3  5  5  3  3  2  7  2  1  9  5  7  5  1  7  1  5  2  2  8  1  2  2
[101]  1  1  3  2  3  4 12  6  8  4  5  8  7  1  1  2  2  1  1  4  6  2  3  6  6
[126]  1  1  1  1  2  1  1  1  2  1  1  6
> CharacterLength(tree, dataset, compress = TRUE)
  [1]  1  1  2  2  3  4  4  5  1  6  1  1  2  1  2  4  2  5  2  4  1  2  1  1  2
 [26]  2  2  5  1  1  1  2  4  3  6  5  5  1  2  2  2  1  8  3  7  3  3  2  5  2
 [51]  1  2  2  9 10  5  5  2  4  3  5  1  1  5  6  3  5  5  3  3  2  7  2  1  9
 [76]  5  7  5  1  7  1  5  2  2  8  1  2  2  1  3  2  3  4 12  6  8  4  5  8  7
[101]  1  2  2  1  4  6  2  3  6  6  1  1  1  1  2  1  2  6
> 
> 
> 
> cleanEx()
> nameEx("ClusterStrings")
> ### * ClusterStrings
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ClusterStrings
> ### Title: Cluster similar strings
> ### Aliases: ClusterStrings
> 
> ### ** Examples
> 
> ClusterStrings(c(paste0("FirstCluster ", 1:5),
+                  paste0("SecondCluster.", 8:12),
+                  paste0("AnotherCluster_", letters[1:6])))
 [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 3
attr(,"silhouette")
[1] 0.911867
attr(,"med")
[1] "FirstCluster 1"   "SecondCluster.10" "AnotherCluster_a"
> 
> 
> 
> cleanEx()
> nameEx("ConcordantInformation")
> ### * ConcordantInformation
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ConcordantInformation
> ### Title: Evaluate the concordance of information between a tree and a
> ###   dataset
> ### Aliases: ConcordantInformation Evaluate ConcordantInfo
> 
> ### ** Examples
> 
> data(congreveLamsdellMatrices)
> myMatrix <- congreveLamsdellMatrices[[10]]
> ConcordantInformation(TreeTools::NJTree(myMatrix), myMatrix)
dataset contains 821.038 bits, of which 280.813 signal, 540.226 noise, 78.0817 needed.  S:N = 0.519806

informationContent             signal              noise      signalToNoise 
       821.0383923        280.8125010        540.2258914          0.5198057 
   treeInformation       matrixToTree            ignored 
        78.0816559         10.5151253          0.0000000 
> 
> 
> 
> cleanEx()
> nameEx("Consistency")
> ### * Consistency
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Consistency
> ### Title: Consistency / retention "indices"
> ### Aliases: Consistency
> 
> ### ** Examples
> 
> data(inapplicable.datasets)
> dataset <- inapplicable.phyData[[4]]
> head(Consistency(dataset, TreeTools::NJTree(dataset)))
            ci        ri        rc
[1,] 0.2500000 0.6250000 0.1562500
[2,] 0.3333333 0.3333333 0.1111111
[3,] 0.3333333 0.6000000 0.2000000
[4,] 0.2500000 0.2500000 0.0625000
[5,] 0.5000000 0.8333333 0.4166667
[6,] 0.2500000 0.2500000 0.0625000
> 
> 
> 
> cleanEx()
> nameEx("GapHandler")
> ### * GapHandler
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: GapHandler
> ### Title: Read how a Morphy Object handles the inapplicable token
> ### Aliases: GapHandler
> 
> ### ** Examples
> 
> morphyObj <- SingleCharMorphy("-0-0", "Extra")
> GapHandler(morphyObj)
[1] "Extra state"
> morphyObj <- UnloadMorphy(morphyObj)
> 
> 
> 
> cleanEx()
> nameEx("JackLabels")
> ### * JackLabels
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: JackLabels
> ### Title: Label nodes with jackknife support values
> ### Aliases: JackLabels
> 
> ### ** Examples
> 
> library("TreeTools", quietly = TRUE) # for as.phylo
> 
> # jackTrees will usually be generated with Jackknife(), but for simplicity:
> jackTrees <- as.phylo(1:100, 8)
> 
> tree <- as.phylo(0, 8)
> JackLabels(tree, jackTrees)
  11   12   13   14   15 
0.13 0.08 0.14 1.00 1.00 
> 
> tree$node.label <- JackLabels(tree, jackTrees, plot = FALSE)
> 
> # Write the labelled tree to screen
> ape::write.tree(tree)
[1] "(t1,((((((t2,t8)1,t7)1,t6)0.14,t5)0.08,t4)0.13,t3));"
> 
> # Write labelled trees to a nexus file:
> # write.nexus(tree, file = filename)
> 
> 
> 
> cleanEx()

detaching ‘package:TreeTools’, ‘package:ape’

> nameEx("LengthAdded")
> ### * LengthAdded
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LengthAdded
> ### Title: Contribution of character to leaf instability
> ### Aliases: LengthAdded PolEscapa
> 
> ### ** Examples
> 
> trees <- inapplicable.trees[["Vinther2008"]]
> dataset <- inapplicable.phyData[["Vinther2008"]]
> char <- dataset[, 11]
> added <- LengthAdded(trees, char)
> 
> PlotCharacter(
+   tree = trees[[1]], 
+   dataset = char,
+   tip.color = 1 + added[trees[[1]]$tip.label] # Colour by added steps
+ ) -> XX # Suppress return value; display plot only
> 
> 
> 
> 
> cleanEx()
> nameEx("MaximizeParsimony")
> ### * MaximizeParsimony
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MaximizeParsimony
> ### Title: Find most parsimonious trees
> ### Aliases: MaximizeParsimony Resample EasyTrees EasyTreesy
> 
> ### ** Examples
> 
> ## Only run examples in interactive R sessions
> if (interactive()) {
+   # launch "shiny" point-and-click interface
+   EasyTrees()
+   
+   # Here too, use the "continue search" function to ensure that tree score
+   # has stabilized and a global optimum has been found
+ }
> 
> 
> # Load data for analysis in R
> library("TreeTools")
Loading required package: ape
> data("congreveLamsdellMatrices", package = "TreeSearch")
> dataset <- congreveLamsdellMatrices[[42]]
> 
> # A very quick run for demonstration purposes
> trees <- MaximizeParsimony(dataset, ratchIter = 0, startIter = 0,
+                            tbrIter = 1, maxHits = 4, maxTime = 1/100,
+                            concavity = 10, verbosity = 4)

── BEGIN TREE SEARCH (k = 10) ──────────────────────────────────────────────────
→ Initial score: 12.6988 

── Sample local optimum ────────────────────────────────────────────────────────
→ TBR depth 1; keeping 4 trees; k = 10
ℹ 2025-06-01 10:51:56: Score: 12.6988
Final search ■                                  0% | D0, score 12.0038, hit 1. …
  - TBR rearrangement at depth 1 found score 11.9697 1 time.

✔ 2025-06-01 10:51:58: Tree search terminated with score 11.9697
> names(trees)
[1] "final_1"
> 
> # In actual use, be sure to check that the score has converged on a global
> # optimum, conducting additional iterations and runs as necessary.
>  
> if (interactive()) {
+ # Jackknife resampling
+ nReplicates <- 10
+ jackTrees <- replicate(nReplicates,
+   #c() ensures that each replicate returns a list of trees
+   c(Resample(dataset, trees, ratchIter = 0, tbrIter = 2, startIter = 1,
+              maxHits = 5, maxTime = 1 / 10,
+              concavity = 10, verbosity = 0))
+  )
+ 
+ # In a serious analysis, more replicates would be conducted, and each
+ # search would undergo more iterations.
+ 
+ # Now we must decide what to do with the multiple optimal trees from
+ # each replicate.
+ 
+ # Treat each tree equally
+ JackLabels(ape::consensus(trees), unlist(jackTrees, recursive = FALSE))
+ 
+ # Take the strict consensus of all trees for each replicate
+ JackLabels(ape::consensus(trees), lapply(jackTrees, ape::consensus))
+ 
+ # Take a single tree from each replicate (the first; order's irrelevant)
+ JackLabels(ape::consensus(trees), lapply(jackTrees, `[[`, 1))
+ }
> 
> # Tree search with a constraint
> constraint <- MatrixToPhyDat(c(a = 1, b = 1, c = 0, d = 0, e = 0, f = 0))
> characters <- MatrixToPhyDat(matrix(
+   c(0, 1, 1, 1, 0, 0,
+     1, 1, 1, 0, 0, 0), ncol = 2,
+   dimnames = list(letters[1:6], NULL)))
> MaximizeParsimony(characters, constraint = constraint, verbosity = 0)
✔ Initialized 1 distinct constraints.
1 phylogenetic tree
> 
> 
> 
> 
> cleanEx()

detaching ‘package:TreeTools’, ‘package:ape’

> nameEx("MinimumLength")
> ### * MinimumLength
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MinimumLength
> ### Title: Minimum and Maximum lengths possible for a character
> ### Aliases: MinimumLength MinimumLength.phyDat MinimumLength.numeric
> ###   MinimumLength.character MaximumLength.character MinimumSteps
> ###   MaximumLength MaximumLength.numeric
> 
> ### ** Examples
> 
> data("inapplicable.datasets")
> myPhyDat <- inapplicable.phyData[[4]]
> 
> # load your own data with
> # my.PhyDat <- as.phyDat(read.nexus.data("filepath"))
> # or Windows users can select a file interactively using:
> # my.PhyDat <- as.phyDat(read.nexus.data(choose.files()))
> 
> class(myPhyDat) # phyDat object
[1] "phyDat"
> 
> # Minimum length of each character in turn
> MinimumLength(myPhyDat)
  [1] 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 2 1 1 1 1 1 1 1
 [38] 1 1 1 1 1 2 1 1 1 1 1 1 1 1 2 1 1 1 1 1 2 1 1 2 1 1 2 1 1 4 3 1 1 1 1 2 1
 [75] 1 1 1 1 1 1 2 4 1 1 1 1 1 1 1 2 2 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1
[112] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
> 
> # Collapse duplicate characters, per phyDat compression
> MinimumLength(myPhyDat, compress = TRUE)
  [1] 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 2 1 1 1 1 1 1 1
 [38] 1 1 1 1 1 2 1 1 1 1 1 1 1 1 2 1 1 1 1 1 2 1 1 2 1 1 2 1 1 4 3 1 1 1 1 2 1
 [75] 1 1 1 1 1 1 2 4 1 1 1 1 1 1 1 2 2 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1
[112] 1 1 1 1 1 1 1 1 1 1 1 1 1 1
> 
> # Calculate length of a single character from its textual representation
> MinimumLength("-{-1}{-2}{-3}2233")
[1] 2
> MaximumLength("----0011")
[1] 3
> 
> 
> 
> cleanEx()
> nameEx("MorphyWeights")
> ### * MorphyWeights
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MorphyWeights
> ### Title: Set and get the character weightings associated with a Morphy
> ###   object.
> ### Aliases: MorphyWeights SetMorphyWeights
> 
> ### ** Examples
> 
> tokens <- matrix(c(
+   0, 0, 0, 1, 1, 2,
+   0, 0, 0, 0, 0, 0), byrow = TRUE, nrow = 2L,
+   dimnames = list(letters[1:2], NULL))
> pd <- TreeTools::MatrixToPhyDat(tokens)
> morphyObj <- PhyDat2Morphy(pd)
> MorphyWeights(morphyObj)
       [,1] [,2] [,3]
approx 3    2    1   
exact  3    2    1   
> if (SetMorphyWeights(c(1, 1.5, 2/3), morphyObj) != 0L) message("Errored")
> MorphyWeights(morphyObj)
       [,1] [,2] [,3]     
approx 6    9    4        
exact  1    1.5  0.6666667
> morphyObj <- UnloadMorphy(morphyObj)
> 
> 
> 
> cleanEx()
> nameEx("NNI")
> ### * NNI
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NNI
> ### Title: Nearest neighbour interchange (NNI)
> ### Aliases: NNI cNNI NNISwap RootedNNI RootedNNISwap
> 
> ### ** Examples
> 
> tree <- TreeTools::BalancedTree(8)
> # A random rearrangement
> NNI(tree)

Phylogenetic tree with 8 tips and 7 internal nodes.

Tip labels:
  t1, t2, t3, t4, t5, t6, ...

Rooted; no branch length.
> cNNI(tree)

Phylogenetic tree with 8 tips and 7 internal nodes.

Tip labels:
  t1, t2, t3, t4, t5, t6, ...

Rooted; no branch length.
> 
> # All trees one NNI rearrangement away
> NNI(tree, edgeToBreak = -1)
12 phylogenetic trees
> 
> # Manual random sampling
> cNNI(tree, sample.int(14 - 8 - 1, 1), sample.int(2, 1))

Phylogenetic tree with 8 tips and 7 internal nodes.

Tip labels:
  t1, t2, t3, t4, t5, t6, ...

Rooted; no branch length.
> 
> # A specified rearrangement
> cNNI(tree, 0, 0)

Phylogenetic tree with 8 tips and 7 internal nodes.

Tip labels:
  t1, t2, t3, t4, t5, t6, ...

Rooted; no branch length.
> 
> # If a tree may not be binary, collapse nodes with
> tree <- TreeTools::MakeTreeBinary(tree)
> 
> # If a tree may be improperly rooted, use
> tree <- TreeTools::RootTree(tree, 1)
> 
> # If a tree may exhibit unusual node ordering, this can be addressed with
> tree <- TreeTools::Preorder(tree)
> 
> 
> 
> cleanEx()
> nameEx("PhyDat2Morphy")
> ### * PhyDat2Morphy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PhyDat2Morphy
> ### Title: Initialize a Morphy object from a 'phyDat' object
> ### Aliases: PhyDat2Morphy
> 
> ### ** Examples
> 
> data("Lobo", package="TreeTools")
> morphyObj <- PhyDat2Morphy(Lobo.phy)
> # Set object to be destroyed at end of session or closure of function
> # on.exit(morphyObj <- UnloadMorphy(morphyObj), add = TRUE)
> 
> # Do something with pointer
> # ....
> 
> # Or, instead of on.exit, manually destroy morphy object and free memory:
> morphyObj <- UnloadMorphy(morphyObj)
> 
> 
> 
> cleanEx()
> nameEx("PlotCharacter")
> ### * PlotCharacter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PlotCharacter
> ### Title: Plot the distribution of a character on a tree
> ### Aliases: PlotCharacter PlotCharacter.phylo PlotCharacter.multiPhylo
> ###   PlotCharacter.list
> 
> ### ** Examples
> 
> # Set up plotting area
> oPar <- par(mar = rep(0, 4))
> 
> tree <- ape::read.tree(text = 
+   "((((((a, b), c), d), e), f), (g, (h, (i, (j, (k, l))))));")
> ## A character with inapplicable data
> dataset <- TreeTools::StringToPhyDat("23--1??--032", tips = tree)
> plotted <- PlotCharacter(tree, dataset)
> plotted
          -     0     1     2     3
 [1,] FALSE FALSE FALSE  TRUE FALSE
 [2,] FALSE FALSE FALSE FALSE  TRUE
 [3,]  TRUE FALSE FALSE FALSE FALSE
 [4,]  TRUE FALSE FALSE FALSE FALSE
 [5,] FALSE FALSE  TRUE FALSE FALSE
 [6,]  TRUE  TRUE  TRUE  TRUE  TRUE
 [7,]  TRUE  TRUE  TRUE  TRUE  TRUE
 [8,]  TRUE FALSE FALSE FALSE FALSE
 [9,]  TRUE FALSE FALSE FALSE FALSE
[10,] FALSE  TRUE FALSE FALSE FALSE
[11,] FALSE FALSE FALSE FALSE  TRUE
[12,] FALSE FALSE FALSE  TRUE FALSE
[13,]  TRUE FALSE FALSE FALSE FALSE
[14,]  TRUE FALSE FALSE FALSE FALSE
[15,]  TRUE FALSE FALSE FALSE FALSE
[16,]  TRUE FALSE FALSE FALSE FALSE
[17,]  TRUE FALSE FALSE FALSE FALSE
[18,] FALSE FALSE FALSE  TRUE  TRUE
[19,]  TRUE FALSE FALSE FALSE FALSE
[20,]  TRUE FALSE FALSE FALSE FALSE
[21,]  TRUE FALSE FALSE FALSE FALSE
[22,] FALSE  TRUE FALSE  TRUE  TRUE
[23,] FALSE  TRUE FALSE  TRUE  TRUE
> 
> # Character from a real dataset 
> data("Lobo", package = "TreeTools")
> dataset <- Lobo.phy
> tree <- TreeTools::NJTree(dataset)
> PlotCharacter(tree, dataset, 14)
> par(oPar)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("PrepareDataProfile")
> ### * PrepareDataProfile
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PrepareDataProfile
> ### Title: Prepare data for Profile Parsimony
> ### Aliases: PrepareDataProfile PrepareDataIW
> 
> ### ** Examples
> 
> data("congreveLamsdellMatrices")
> dataset <- congreveLamsdellMatrices[[42]]
> PrepareDataProfile(dataset)
$`1`
 [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
[39] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1

$`2`
 [1] 1 2 2 1 2 2 2 2 2 1 1 1 2 1 1 2 1 1 2 1 1 1 2 2 2 2 1 1 1 1 2 2 2 1 2 2 2 2
[39] 1 2 1 1 2 1 1 2 1 1 2 2 2 2 2 1 1

$`3`
 [1] 1 1 2 1 2 2 1 2 1 1 1 1 2 1 1 2 2 1 2 1 2 1 2 2 2 2 2 1 1 1 2 1 2 1 1 2 2 2
[39] 1 2 1 1 2 2 2 2 1 1 2 2 2 2 2 1 1

$`4`
 [1] 1 1 2 1 2 2 1 2 1 1 2 1 2 1 1 1 2 1 2 1 1 1 2 2 2 2 1 1 1 1 2 1 2 1 1 2 2 2
[39] 1 2 1 1 2 2 2 2 1 1 2 1 1 2 2 2 1

$`5`
 [1] 2 1 2 1 2 1 1 2 1 1 2 2 2 1 1 2 2 2 2 1 1 1 2 2 2 2 2 2 2 1 2 1 2 1 2 2 2 2
[39] 1 2 1 2 2 2 2 2 1 1 1 1 1 2 2 1 1

$`6`
 [1] 1 1 1 1 2 1 2 2 2 1 1 2 2 1 1 2 1 2 2 1 2 1 1 1 2 2 2 1 2 1 2 2 2 1 2 2 2 1
[39] 1 1 1 2 1 2 1 2 2 1 2 1 1 2 2 1 2

$`7`
 [1] 1 1 2 1 2 2 1 1 2 2 1 2 1 1 1 2 2 2 2 2 1 1 1 1 2 2 2 1 2 1 2 1 2 1 1 1 2 1
[39] 1 2 1 2 2 1 1 2 2 1 2 1 1 2 2 1 1

$`8`
 [1] 1 2 2 1 2 2 1 2 1 1 1 2 2 1 2 2 1 2 2 1 1 1 2 2 2 1 2 2 1 1 1 1 1 2 2 2 2 1
[39] 2 1 1 2 1 2 2 2 2 1 2 2 1 2 2 1 1

$`9`
 [1] 1 1 1 1 2 1 2 2 1 1 2 2 1 1 1 2 1 2 2 1 1 1 1 1 1 1 2 1 2 1 1 2 1 1 2 2 2 1
[39] 2 1 1 1 1 2 1 2 1 2 2 1 1 2 1 1 1

$`10`
 [1] 1 1 1 1 2 2 2 1 1 1 2 2 1 1 2 2 1 2 2 1 2 1 1 1 1 2 2 2 2 2 1 1 1 2 1 1 2 2
[39] 1 1 2 1 1 2 1 2 1 1 2 1 1 2 2 1 1

$`11`
 [1] 1 1 1 2 2 2 2 1 2 1 2 2 2 1 1 2 1 2 2 1 2 2 2 2 1 1 1 1 2 2 1 2 1 1 2 1 2 1
[39] 1 2 1 1 1 2 2 2 1 1 2 1 1 1 1 1 1

$`12`
 [1] 1 1 2 1 2 2 2 1 1 1 1 1 2 1 1 2 1 2 1 1 2 1 1 1 1 1 2 2 2 2 1 2 1 1 2 1 2 2
[39] 1 2 2 1 1 2 1 2 1 1 1 1 1 1 1 1 1

$`19`
 [1] 1 1 1 1 2 2 2 2 1 1 1 1 1 1 2 2 1 1 1 1 2 1 2 2 1 2 1 1 1 2 2 2 1 1 1 1 1 2
[39] 1 2 2 2 1 2 1 2 1 1 2 1 1 2 1 1 1

$`18`
 [1] 1 1 1 2 2 1 2 1 1 1 2 2 2 1 1 2 1 1 1 1 2 2 2 1 1 1 1 1 2 2 1 2 1 1 1 1 2 2
[39] 1 2 1 2 1 1 1 1 2 1 2 1 1 1 2 2 1

$`17`
 [1] 1 2 1 2 1 2 2 2 1 1 2 2 1 1 1 2 1 2 1 1 2 2 2 2 1 1 1 1 1 2 1 1 1 2 1 1 2 1
[39] 1 2 1 2 1 1 2 2 1 2 2 1 1 2 1 2 2

$`15`
 [1] 2 2 1 1 2 1 2 2 1 2 2 2 1 1 1 2 1 2 1 1 2 2 2 1 1 2 2 1 1 2 1 1 1 1 2 1 2 2
[39] 2 2 1 2 1 1 2 2 2 1 1 2 1 1 2 2 1

$`16`
 [1] 1 1 1 1 1 1 2 1 1 2 1 2 1 1 2 2 1 2 1 1 2 2 1 1 1 2 1 1 1 2 2 1 1 1 2 1 2 1
[39] 1 2 2 2 1 1 2 2 2 1 2 2 1 1 2 2 2

$`13`
 [1] 1 2 2 1 2 1 1 2 1 1 2 2 1 1 1 1 1 1 1 1 1 1 2 1 2 1 1 1 2 2 2 1 1 2 1 1 2 2
[39] 2 2 1 2 1 2 2 1 2 1 1 1 1 1 2 1 2

$`14`
 [1] 2 1 2 1 2 1 1 1 2 2 1 2 1 1 1 1 1 1 1 1 2 1 2 1 2 1 1 1 2 2 1 1 1 2 1 1 2 2
[39] 2 2 1 2 1 1 1 1 2 1 2 2 1 1 2 1 2

$`20`
 [1] 1 1 2 1 2 1 2 1 1 1 2 1 1 2 1 1 1 2 2 1 1 1 1 1 1 2 1 1 2 1 1 2 1 1 1 1 1 2
[39] 1 2 2 1 1 2 1 1 1 1 2 1 1 2 1 1 1

$`21`
 [1] 1 1 2 1 2 2 2 2 1 1 2 1 1 2 1 2 1 2 1 2 1 1 1 1 1 1 1 1 2 1 1 2 2 1 1 1 1 2
[39] 1 2 2 1 1 2 2 2 1 1 1 1 1 2 1 1 2

$`22`
 [1] 2 1 2 1 2 2 2 2 1 1 2 1 1 2 1 2 1 2 1 2 1 1 1 2 1 1 1 1 2 1 1 2 2 1 1 1 1 1
[39] 1 2 1 2 2 2 2 2 1 1 2 1 1 2 1 1 2

attr(,"class")
[1] "phyDat"
attr(,"weight")
 [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
[39] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
attr(,"nr")
[1] 55
attr(,"nc")
[1] 2
attr(,"index")
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
[51] 51 52 53 54 55
attr(,"levels")
[1] "0" "1"
attr(,"allLevels")
[1] "0" "1" "?"
attr(,"type")
[1] "USER"
attr(,"contrast")
     0 1
[1,] 1 0
[2,] 0 1
[3,] 1 1
attr(,"info.amounts")
        [,1]      [,2]      [,3]     [,4]     [,5]      [,6]      [,7]
1   0.000000  0.000000  0.000000 0.000000 0.000000  0.000000  0.000000
2   5.285402  5.285402  5.285402 5.285402 5.285402  5.285402  5.285402
3   9.150901  9.241099  9.345992 8.909893 8.909893  9.345992  9.330469
4  11.717248 12.160268 12.570623 0.000000 0.000000 12.570623 12.515059
5   0.000000 13.954287 15.099350 0.000000 0.000000 15.099350 14.964820
6   0.000000  0.000000 16.993755 0.000000 0.000000 16.993755 16.718906
7   0.000000  0.000000 18.287328 0.000000 0.000000 18.287328 17.781620
8   0.000000  0.000000 19.024174 0.000000 0.000000 19.024174 18.191556
9   0.000000  0.000000 19.314029 0.000000 0.000000 19.314029  0.000000
10  0.000000  0.000000 19.364620 0.000000 0.000000 19.364620  0.000000
11  0.000000  0.000000  0.000000 0.000000 0.000000  0.000000  0.000000
        [,8]      [,9]     [,10]     [,11]     [,12]     [,13]    [,14]
1   0.000000  0.000000  0.000000  0.000000  0.000000  0.000000 0.000000
2   5.285402  5.285402  5.285402  5.285402  5.285402  5.285402 5.285402
3   9.340527  9.241099  9.150901  9.345992  9.340527  9.340527 8.909893
4  12.551238 12.160268 11.717248 12.570623 12.551238 12.551238 0.000000
5  15.052965 13.954287  0.000000 15.099350 15.052965 15.052965 0.000000
6  16.900419  0.000000  0.000000 16.993755 16.900419 16.900419 0.000000
7  18.118578  0.000000  0.000000 18.287328 18.118578 18.118578 0.000000
8  18.748741  0.000000  0.000000 19.024174 18.748741 18.748741 0.000000
9  18.928521  0.000000  0.000000 19.314029 18.928521 18.928521 0.000000
10  0.000000  0.000000  0.000000 19.364620  0.000000  0.000000 0.000000
11  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000 0.000000
       [,15]     [,16]     [,17]     [,18]     [,19]    [,20]     [,21]
1   0.000000  0.000000  0.000000  0.000000  0.000000 0.000000  0.000000
2   5.285402  5.285402  5.285402  5.285402  5.285402 5.285402  5.285402
3   9.150901  9.241099  9.150901  9.330469  9.347729 8.909893  9.347729
4  11.717248 12.160268 11.717248 12.515059 12.576744 0.000000 12.576744
5   0.000000 13.954287  0.000000 14.964820 15.113879 0.000000 15.113879
6   0.000000  0.000000  0.000000 16.718906 17.022695 0.000000 17.022695
7   0.000000  0.000000  0.000000 17.781620 18.339056 0.000000 18.339056
8   0.000000  0.000000  0.000000 18.191556 19.107959 0.000000 19.107959
9   0.000000  0.000000  0.000000  0.000000 19.432730 0.000000 19.432730
10  0.000000  0.000000  0.000000  0.000000 19.504816 0.000000 19.504816
11  0.000000  0.000000  0.000000  0.000000 19.509010 0.000000 19.509010
       [,22]     [,23]     [,24]     [,25]     [,26]     [,27]     [,28]
1   0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000
2   5.285402  5.285402  5.285402  5.285402  5.285402  5.285402  5.285402
3   9.241099  9.345992  9.340527  9.340527  9.347729  9.340527  9.150901
4  12.160268 12.570623 12.551238 12.551238 12.576744 12.551238 11.717248
5  13.954287 15.099350 15.052965 15.052965 15.113879 15.052965  0.000000
6   0.000000 16.993755 16.900419 16.900419 17.022695 16.900419  0.000000
7   0.000000 18.287328 18.118578 18.118578 18.339056 18.118578  0.000000
8   0.000000 19.024174 18.748741 18.748741 19.107959 18.748741  0.000000
9   0.000000 19.314029 18.928521 18.928521 19.432730 18.928521  0.000000
10  0.000000 19.364620  0.000000  0.000000 19.504816  0.000000  0.000000
11  0.000000  0.000000  0.000000  0.000000 19.509010  0.000000  0.000000
       [,29]     [,30]     [,31]     [,32]     [,33]     [,34]     [,35]
1   0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000
2   5.285402  5.285402  5.285402  5.285402  5.285402  5.285402  5.285402
3   9.340527  9.345992  9.340527  9.345992  9.330469  9.241099  9.340527
4  12.551238 12.570623 12.551238 12.570623 12.515059 12.160268 12.551238
5  15.052965 15.099350 15.052965 15.099350 14.964820 13.954287 15.052965
6  16.900419 16.993755 16.900419 16.993755 16.718906  0.000000 16.900419
7  18.118578 18.287328 18.118578 18.287328 17.781620  0.000000 18.118578
8  18.748741 19.024174 18.748741 19.024174 18.191556  0.000000 18.748741
9  18.928521 19.314029 18.928521 19.314029  0.000000  0.000000 18.928521
10  0.000000 19.364620  0.000000 19.364620  0.000000  0.000000  0.000000
11  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000
       [,36]     [,37]     [,38]     [,39]     [,40]     [,41]     [,42]
1   0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000
2   5.285402  5.285402  5.285402  5.285402  5.285402  5.285402  5.285402
3   9.313959  9.241099  9.340527  9.241099  9.241099  9.287129  9.345992
4  12.454214 12.160268 12.551238 12.160268 12.160268 12.351120 12.570623
5  14.811609 13.954287 15.052965 13.954287 13.954287 14.535765 15.099350
6  16.389045  0.000000 16.900419  0.000000  0.000000 15.738559 16.993755
7  17.137108  0.000000 18.118578  0.000000  0.000000  0.000000 18.287328
8   0.000000  0.000000 18.748741  0.000000  0.000000  0.000000 19.024174
9   0.000000  0.000000 18.928521  0.000000  0.000000  0.000000 19.314029
10  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000 19.364620
11  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000
       [,43]     [,44]     [,45]     [,46]     [,47]    [,48]     [,49]
1   0.000000  0.000000  0.000000  0.000000  0.000000 0.000000  0.000000
2   5.285402  5.285402  5.285402  5.285402  5.285402 5.285402  5.285402
3   9.287129  9.330469  9.347729  9.241099  9.330469 0.000000  9.287129
4  12.351120 12.515059 12.576744 12.160268 12.515059 0.000000 12.351120
5  14.535765 14.964820 15.113879 13.954287 14.964820 0.000000 14.535765
6  15.738559 16.718906 17.022695  0.000000 16.718906 0.000000 15.738559
7   0.000000 17.781620 18.339056  0.000000 17.781620 0.000000  0.000000
8   0.000000 18.191556 19.107959  0.000000 18.191556 0.000000  0.000000
9   0.000000  0.000000 19.432730  0.000000  0.000000 0.000000  0.000000
10  0.000000  0.000000 19.504816  0.000000  0.000000 0.000000  0.000000
11  0.000000  0.000000 19.509010  0.000000  0.000000 0.000000  0.000000
       [,50]    [,51]     [,52]     [,53]     [,54]     [,55]
1   0.000000 0.000000  0.000000  0.000000  0.000000  0.000000
2   5.285402 5.285402  5.285402  5.285402  5.285402  5.285402
3   9.287129 0.000000  9.330469  9.340527  9.241099  9.313959
4  12.351120 0.000000 12.515059 12.551238 12.160268 12.454214
5  14.535765 0.000000 14.964820 15.052965 13.954287 14.811609
6  15.738559 0.000000 16.718906 16.900419  0.000000 16.389045
7   0.000000 0.000000 17.781620 18.118578  0.000000 17.137108
8   0.000000 0.000000 18.191556 18.748741  0.000000  0.000000
9   0.000000 0.000000  0.000000 18.928521  0.000000  0.000000
10  0.000000 0.000000  0.000000  0.000000  0.000000  0.000000
11  0.000000 0.000000  0.000000  0.000000  0.000000  0.000000
attr(,"informative")
 [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
[16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
[31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
[46] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
attr(,"bootstrap")
[1] "info.amounts"
> 
> 
> 
> cleanEx()
> nameEx("QuartetResolution")
> ### * QuartetResolution
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: QuartetResolution
> ### Title: Relationship between four taxa
> ### Aliases: QuartetResolution
> 
> ### ** Examples
> 
> trees <- inapplicable.trees[["Vinther2008"]]
> tips <- c("Lingula", "Halkieria", "Wiwaxia", "Acaenoplax")
> QuartetResolution(trees, tips)
 [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 3 2 3 3 2 1 3 3 3 2 3 2 2 2
[39] 3 3 2 2 1 2 3 2 1 1 2 1 3 2 3 3 2 1 1 1 3 1 2 1 2 1 3 3 2 1 2 1 2 2 3
> 
> 
> 
> cleanEx()
> nameEx("RandomTreeScore")
> ### * RandomTreeScore
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: RandomTreeScore
> ### Title: Parsimony score of random postorder tree
> ### Aliases: RandomTreeScore
> 
> ### ** Examples
> 
> tokens <- matrix(c(
+   0, "-", "-", 1, 1, 2,
+   0, 1, 0, 1, 2, 2,
+   0, "-", "-", 0, 0, 0), byrow = TRUE, nrow = 3L,
+   dimnames = list(letters[1:3], NULL))
> pd <- TreeTools::MatrixToPhyDat(tokens)
> morphyObj <- PhyDat2Morphy(pd)
> 
> RandomTreeScore(morphyObj)
[1] 4
> 
> morphyObj <- UnloadMorphy(morphyObj)
> 
> 
> 
> cleanEx()
> nameEx("Ratchet")
> ### * Ratchet
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MorphyBootstrap
> ### Title: Parsimony Ratchet
> ### Aliases: MorphyBootstrap Ratchet MultiRatchet RatchetConsensus
> 
> ### ** Examples
> 
> data("Lobo", package = "TreeTools")
> njtree <- TreeTools::NJTree(Lobo.phy)
> # Increase value of ratchIter and searchHits to do a proper search
> quickResult <- Ratchet(njtree, Lobo.phy, ratchIter = 2, searchHits = 3)
* Beginning Parsimony Ratchet, with initial score 231
Completed parsimony ratchet after 2 iterations with score 213

> 
> # Plot result (legibly)
> oldPar <- par(mar = rep(0, 4), cex = 0.75)
> plot(quickResult)
> par(oldPar)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("RearrangeEdges")
> ### * RearrangeEdges
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: RearrangeEdges
> ### Title: Rearrange edges of a phylogenetic tree
> ### Aliases: RearrangeEdges
> 
> ### ** Examples
> 
> data("Lobo", package="TreeTools")
> tree <- TreeTools::NJTree(Lobo.phy)
> edge <- tree$edge
> parent <- edge[, 1]
> child <- edge[, 2]
> dataset <- PhyDat2Morphy(Lobo.phy)
> RearrangeEdges(parent, child, dataset, EdgeSwapper = RootedNNISwap)
[[1]]
 [1] 49 49 50 50 51 52 53 54 55 56 56 55 57 58 58 57 59 60 60 59 61 62 62 63 64
[26] 64 63 65 66 66 65 67 67 61 68 69 70 71 71 70 69 72 72 68 54 73 73 74 75 75
[51] 74 53 76 76 77 77 78 79 79 78 80 81 82 82 81 80 83 83 84 85 86 86 85 87 87
[76] 84 52 88 88 51 89 90 91 92 92 91 93 93 94 94 95 95 90 89

[[2]]
 [1]  1 50  2 51 52 53 54 55 56  3  4 57 58 31 32 59 60 34 35 61 62 36 63 64 43
[26] 44 65 66 45 46 67 47 48 68 69 70 71 37 41 42 72 38 39 40 73  5 74 75 28 29
[51] 30 76  6 77  9 78 79 10 11 80 81 82 12 13 22 83 14 84 85 86 15 18 87 16 17
[76] 19 88  7  8 89 90 91 92 20 21 93 24 94 25 95 26 27 23 33

[[3]]
[1] 232

[[4]]
[1] 0

> # Remember to free memory:
> dataset <- UnloadMorphy(dataset)
> 
> 
> 
> cleanEx()
> nameEx("SPR")
> ### * SPR
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SPR
> ### Title: Subtree pruning and rearrangement (SPR)
> ### Aliases: SPR SPRMoves SPRMoves.phylo SPRMoves.matrix SPRSwap RootedSPR
> ###   RootedSPRSwap
> 
> ### ** Examples
> 
> {
+ tree <- ape::rtree(20, br=FALSE)
+ SPR(tree)
+ }

Phylogenetic tree with 20 tips and 19 internal nodes.

Tip labels:
  t10, t14, t20, t7, t9, t15, ...

Rooted; includes branch length(s).
> 
> 
> 
> cleanEx()
> nameEx("SingleCharMorphy")
> ### * SingleCharMorphy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SingleCharMorphy
> ### Title: Morphy object from single character
> ### Aliases: SingleCharMorphy
> 
> ### ** Examples
> 
> morphyObj <- SingleCharMorphy("-0-0", gap = "Extra")
> RandomTreeScore(morphyObj)
[1] 2
> morphyObj <- UnloadMorphy(morphyObj)
> 
> 
> 
> cleanEx()
> nameEx("SiteConcordance")
> ### * SiteConcordance
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SiteConcordance
> ### Title: Calculate site concordance factor
> ### Aliases: SiteConcordance QuartetConcordance ClusteringConcordance
> ###   PhylogeneticConcordance MutualClusteringConcordance
> ###   SharedPhylogeneticConcordance
> 
> ### ** Examples
> 
> data("congreveLamsdellMatrices", package = "TreeSearch")
> dataset <- congreveLamsdellMatrices[[1]][, 1:20]
> tree <- referenceTree
> qc <- QuartetConcordance(tree, dataset)
> cc <- ClusteringConcordance(tree, dataset)
> pc <- PhylogeneticConcordance(tree, dataset)
> spc <- SharedPhylogeneticConcordance(tree, dataset)
> mcc <- MutualClusteringConcordance(tree, dataset)
> 
> oPar <- par(mar = rep(0, 4), cex = 0.8) # Set plotting parameters
> plot(tree)
> TreeTools::LabelSplits(tree, signif(qc, 3), cex = 0.8)
> plot(tree)
> TreeTools::LabelSplits(tree, signif(cc, 3), cex = 0.8)
> par(oPar) # Restore plotting parameters
> 
> # Write concordance factors to file
> labels <- paste0(qc, "/", cc, "/", pc) # "/" is a valid delimiter
> # Identify the node that corresponds to each label
> whichNode <- match(TreeTools::NTip(tree) + 1:tree$Nnode, names(qc))
> 
> # The contents of tree$node.label will be written at each node
> tree$node.label <- labels[whichNode]
> 
> ape::write.tree(tree) # or write.nexus(tree, file = "mytree.nex")
[1] "(((((((((((((2,3)0.794157608695652/0.0840869199349208/0.8,4)0.796019900497512/0.106844441779741/0.7,5)0.745984310795667/0.125579285095439/0.5,6)0.744573765335011/0.157227405925398/0.45,7)0.726778007130794/0.158079354442316/0.45,8)0.72615039281706/0.161803744635535/0.45,9)0.736253135249855/0.164460425292521/0.45,10)0.713525905547914/0.152606841335018/0.35,11)0.693087173792338/0.139772020193245/0.35,12)0.663097646420289/0.119374128613331/0.35,(19,((18,(17,(15,16)0.575/0.0480987344280996/0.75)0.62020202020202/0.0630658263101711/0.65)0.606779661016949/0.0675277845468592/0.5,(13,14)0.6825/0.0463478996057617/0.85)0.628180398640581/0.0893831815805849/0.45)0.649913605288859/0.0972690748771144/0.4)0.665/0.0733038953664147/0.5,(20,(21,22)0.631908237747654/0.0498507296733025/0.8)0.60419091967404/0.0567591383942297/0.65)NA,1)NA;"
> 
> # Display correlation between concordance factors
> pairs(cbind(qc, cc, pc, spc, mcc), asp = 1)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("StepInformation")
> ### * StepInformation
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: StepInformation
> ### Title: Information content of a character known to contain _e_ steps
> ### Aliases: StepInformation
> 
> ### ** Examples
> 
> character <- rep(c(0:3, "?", "-"), c(8, 5, 1, 1, 2, 2))
> StepInformation(character)
        3         4         5         6         7 
9.9203529 5.5280354 2.5784492 0.7618403 0.0000000 
> 
> 
> 
> cleanEx()
> nameEx("TBR")
> ### * TBR
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: TBR
> ### Title: Tree bisection and reconnection (TBR)
> ### Aliases: TBR TBRMoves TBRMoves.phylo TBRMoves.matrix TBRSwap RootedTBR
> ###   RootedTBRSwap
> 
> ### ** Examples
> 
> library("ape")
> tree <- rtree(20, br=NULL)
> TBR(tree)

Phylogenetic tree with 20 tips and 19 internal nodes.

Tip labels:
  t10, t14, t20, t7, t9, t15, ...

Rooted; no branch length.
> 
> 
> 
> cleanEx()

detaching ‘package:ape’

> nameEx("TBRWarning")
> ### * TBRWarning
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SPRWarning
> ### Title: TBR Warning Print a warning and return given tree
> ### Aliases: SPRWarning TBRWarning
> ### Keywords: internal
> 
> ### ** Examples
> 
> suppressWarnings(TBRWarning(0, 0, "Message text")) # will trigger warning
[[1]]
[1] 0

[[2]]
[1] 0

> 
> 
> 
> 
> cleanEx()
> nameEx("TaxonInfluence")
> ### * TaxonInfluence
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: TaxonInfluence
> ### Title: Rank taxa by their influence on phylogenetic results
> ### Aliases: TaxonInfluence
> 
> ### ** Examples
> 
> #' # Load data for analysis in R
> library("TreeTools")
Loading required package: ape
> data("congreveLamsdellMatrices", package = "TreeSearch")
> 
> # Small dataset for demonstration purposes
> dataset <- congreveLamsdellMatrices[[42]][1:8, ]
> bestTree <- MaximizeParsimony(dataset, verbosity = 0)[[1]]
> 
> # Calculate tip influence
> influence <- TaxonInfluence(dataset, ratchIt = 0, startIt = 0, verbos = 0)

── BEGIN TREE SEARCH (k = Inf) ─────────────────────────────────────────────────
→ Initial score: 84 

── Sample local optimum ────────────────────────────────────────────────────────
→ TBR depth 2; keeping 14.4 trees; k = Inf
ℹ 2025-06-01 10:52:06: Score: 84
✔ 2025-06-01 10:52:06: Tree search terminated with score 82
> 
> # Colour tip labels according to their influence
> upperBound <- 2 * TreeDist::ClusteringEntropy(
+   PectinateTree(NTip(dataset) - 1))
> nBin <- 128
> bin <- cut(
+   influence["max", ],
+   breaks = seq(0, upperBound, length.out = nBin),
+   include.lowest = TRUE
+ )
> palette <- hcl.colors(nBin, "inferno")
> 
> plot(bestTree, tip.color = palette[bin])
> PlotTools::SpectrumLegend(
+   "bottomleft",
+   palette = palette,
+   title = "Tip influence / bits",
+   legend = signif(seq(upperBound, 0, length.out = 4), 3),
+   bty = "n"
+ )
> 
> 
> 
> cleanEx()

detaching ‘package:TreeTools’, ‘package:ape’

> nameEx("TreeLength")
> ### * TreeLength
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: IWScore
> ### Title: Calculate the parsimony score of a tree given a dataset
> ### Aliases: IWScore TreeLength TreeLength.phylo TreeLength.numeric
> ###   TreeLength.list TreeLength.multiPhylo Fitch
> 
> ### ** Examples
> 
> data("inapplicable.datasets")
> tree <- TreeTools::BalancedTree(inapplicable.phyData[[1]])
> TreeLength(tree, inapplicable.phyData[[1]])
[1] 1117
> TreeLength(tree, inapplicable.phyData[[1]], concavity = 10)
[1] 52.75785
> TreeLength(tree, inapplicable.phyData[[1]], concavity = "profile")
→ Inapplicable tokens treated as ambiguous for profile parsimony
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
[1] 3941.387
> TreeLength(5, inapplicable.phyData[[1]])
[1] 1920 1972 1976 1960 1889
> 
> 
> 
> cleanEx()
> nameEx("TreeSearch")
> ### * TreeSearch
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: EdgeListSearch
> ### Title: Search for most parsimonious trees
> ### Aliases: EdgeListSearch TreeSearch IWTreeSearch EmptyPhyDat DoNothing
> ### Keywords: internal
> 
> ### ** Examples
> 
> data("Lobo", package="TreeTools")
> njtree <- TreeTools::NJTree(Lobo.phy)
> 
> ## Only run examples in interactive R sessions
> if (interactive()) {
+   TreeSearch(njtree, Lobo.phy, maxIter = 20, EdgeSwapper = NNISwap)
+   TreeSearch(njtree, Lobo.phy, maxIter = 20, EdgeSwapper = RootedSPRSwap)
+   TreeSearch(njtree, Lobo.phy, maxIter = 20, EdgeSwapper = TBRSwap)
+ }
> 
> 
> 
> cleanEx()
> nameEx("WhenFirstHit")
> ### * WhenFirstHit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: WhenFirstHit
> ### Title: When was a tree topology first hit?
> ### Aliases: WhenFirstHit
> 
> ### ** Examples
> 
> library("TreeTools", quietly = TRUE)
> trees <- list(
+    seed_00 = as.phylo(1, 8),
+    ratch1_01 = as.phylo(2, 8),
+    ratch1_02 = as.phylo(3, 8),
+    ratch4_44 = as.phylo(4, 8),
+    final_99 = as.phylo(5, 8)
+ )
> attr(WhenFirstHit(trees), "firstHit")
whenHit
  seed ratch1 ratch4  final 
     1      2      1      1 
> 
> 
> 
> cleanEx()

detaching ‘package:TreeTools’, ‘package:ape’

> nameEx("WithOneExtraStep")
> ### * WithOneExtraStep
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: WithOneExtraStep
> ### Title: Number of trees with one extra step
> ### Aliases: WithOneExtraStep
> 
> ### ** Examples
> 
> WithOneExtraStep(1, 2, 3)
[1] 84
> 
> 
> 
> cleanEx()
> nameEx("cSPR")
> ### * cSPR
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cSPR
> ### Title: 'cSPR()' expects a tree rooted on a single tip.
> ### Aliases: cSPR
> 
> ### ** Examples
> 
> tree <- TreeTools::BalancedTree(8)
> 
> # Tree must be rooted on leaf
> tree <- TreeTools::RootTree(tree, 1)
> 
> # Random rearrangement
> cSPR(tree)

Phylogenetic tree with 8 tips and 7 internal nodes.

Tip labels:
  t1, t2, t3, t4, t5, t6, ...

Rooted; no branch length.
> 
> # Specific rearrangement
> cSPR(tree, 9)

Phylogenetic tree with 8 tips and 7 internal nodes.

Tip labels:
  t1, t2, t3, t4, t5, t6, ...

Rooted; no branch length.
> 
> 
> 
> cleanEx()
> nameEx("congreveLamsdellMatrices")
> ### * congreveLamsdellMatrices
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: congreveLamsdellMatrices
> ### Title: 100 simulated data matrices
> ### Aliases: congreveLamsdellMatrices
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data("referenceTree")
> data("congreveLamsdellMatrices")
> TreeLength(referenceTree, congreveLamsdellMatrices[[17]], "profile")
[1] 549.6488
> 
> 
> 
> 
> cleanEx()
> nameEx("dot-NonDuplicateRoot")
> ### * dot-NonDuplicateRoot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: .NonDuplicateRoot
> ### Title: Non-duplicate root
> ### Aliases: .NonDuplicateRoot
> ### Keywords: internal
> 
> ### ** Examples
> 
> tree <- TreeTools::Preorder(TreeTools::BalancedTree(8))
> edge <- tree$edge
> parent <- edge[, 1]
> child <- edge[, 2]
> 
> which(!.NonDuplicateRoot(parent, child))
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("inapplicable.datasets")
> ### * inapplicable.datasets
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: inapplicable.datasets
> ### Title: Thirty datasets with inapplicable data
> ### Aliases: inapplicable.datasets inapplicable.phyData inapplicable.trees
> ###   inapplicable.citations
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data("inapplicable.datasets", package = "TreeSearch")
> names(inapplicable.datasets)
 [1] "Agnarsson2004" "Aguado2009"    "Aria2015"      "Asher2005"    
 [5] "Capa2011"      "Conrad2008"    "DeAssis2011"   "Dikow2009"    
 [9] "Eklund2004"    "Geisler2001"   "Giles2015"     "Griswold1999" 
[13] "Liljeblad2008" "Loconte1991"   "Longrich2010"  "OLeary1999"   
[17] "OMeara2014"    "Rougier2012"   "Rousset2004"   "Sano2011"     
[21] "Sansom2010"    "Schulze2007"   "Shultz2007"    "Vinther2008"  
[25] "Wetterer2000"  "Wills2012"     "Wilson2003"    "Wortley2006"  
[29] "Zanol2014"     "Zhu2013"      
> 
> 
> 
> cleanEx()
> nameEx("mpl_new_Morphy")
> ### * mpl_new_Morphy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mpl_new_Morphy
> ### Title: Creates a new instance of a Morphy object
> ### Aliases: mpl_new_Morphy
> ### Keywords: internal
> 
> ### ** Examples
> 
> morphyObj <- mpl_new_Morphy() # Create new object
> ## Do some stuff ... ##
> mpl_delete_Morphy(morphyObj) # Delete when done
[1] 0
> 
> 
> 
> 
> cleanEx()
> nameEx("mpl_translate_error")
> ### * mpl_translate_error
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mpl_translate_error
> ### Title: Converts a numeric error code to human-readable format
> ### Aliases: mpl_translate_error
> ### Keywords: internal
> 
> ### ** Examples
> 
> mpl_translate_error(-1) # "ERR_INVALID_SYMBOL"
[1] "ERR_INVALID_SYMBOL"
> 
> 
> 
> 
> cleanEx()
> nameEx("profiles")
> ### * profiles
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: profiles
> ### Title: Empirically counted profiles for small trees
> ### Aliases: profiles
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(profiles)
> 
> # Load profile for a character of the structure 0 0 0 1 1 1 1 1
> profile3.5 <- profiles[[8]][[2]][[3]]
> 
> # Number of trees with _s_ or fewer steps on that character
> TreeTools::NUnrooted(8) * 2 ^ profile3.5
    1     2     3     4 
  225  2475  8019 10395 
> 
> 
> 
> cleanEx()
> nameEx("referenceTree")
> ### * referenceTree
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: referenceTree
> ### Title: Tree topology for matrix simulation
> ### Aliases: referenceTree
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(referenceTree)
> plot(referenceTree)
> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  24.482 0.847 26.113 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
