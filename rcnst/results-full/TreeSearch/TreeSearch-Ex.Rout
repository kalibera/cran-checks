
R Under development (unstable) (2023-03-18 r84003) -- "Unsuffered Consequences"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "TreeSearch"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('TreeSearch')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("AdditionTree")
> ### * AdditionTree
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: AdditionTree
> ### Title: Addition tree
> ### Aliases: AdditionTree
> 
> ### ** Examples
> 
> data("Lobo", package = "TreeTools")
> AdditionTree(Lobo.phy, concavity = 10)
Addition tree ■                                  2% | ETA:  1m
Addition tree ■■■■■                             14% | ETA: 20s
Addition tree ■■■■■■■■■■■■■                     40% | ETA:  9s
Addition tree ■■■■■■■■■■■■■■■■■■                58% | ETA:  6s
Addition tree ■■■■■■■■■■■■■■■■■■■■■■■■■         79% | ETA:  3s
Addition tree ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■  100% | ETA:  0s

Phylogenetic tree with 48 tips and 47 internal nodes.

Tip labels:
  Tubiluchus_Priapulida, Onychodictyon_ferox, Aegirocassis_benmoulae, Cricocosmia, Pambdelurion, Helenodora, ...

Rooted; no branch lengths.
> 
> 
> 
> cleanEx()
> nameEx("Carter1")
> ### * Carter1
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Carter1
> ### Title: Number of trees with _m_ steps
> ### Aliases: Carter1 Log2Carter1 LogCarter1
> 
> ### ** Examples
> 
> # The character `0 0 0 1 1 1`
> Carter1(1, 3, 3) # Exactly one step
[1] 9
> Carter1(2, 3, 3) # Two steps (one extra step)
[1] 54
> 
> # Number of trees that the character can map onto with exactly _m_ steps
> # if non-parsimonious reconstructions are permitted:
> cumsum(sapply(1:3, Carter1, 3, 3))
[1]   9  63 105
> 
> # Three steps allow the character to map onto any of the 105 six-leaf trees.
> 
> 
> 
> 
> cleanEx()
> nameEx("CharacterLength")
> ### * CharacterLength
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CharacterLength
> ### Title: Character length
> ### Aliases: CharacterLength FitchSteps FastCharacterLength
> 
> ### ** Examples
> 
> data("inapplicable.datasets")
> dataset <- inapplicable.phyData[[12]]
> tree <- TreeTools::NJTree(dataset)
> CharacterLength(tree, dataset)
  [1]  1  1  2  2  3  4  4  5  1  6  1  1  2  1  2  4  2  5  2  4  1  1  2  1  1
 [26]  2  2  2  5  1  1  1  2  1  4  3  6  5  5  1  2  1  2  1  1  1  1  1  1  1
 [51]  2  1  1  8  3  7  3  3  2  5  2  1  2  2  2  9 10  5  5  2  4  3  5  1  1
 [76]  5  6  3  5  5  3  3  2  7  2  1  9  5  7  5  1  7  1  5  2  2  8  1  2  2
[101]  1  1  3  2  3  4 12  6  8  4  5  8  7  1  1  2  2  1  1  4  6  2  3  6  6
[126]  1  1  1  1  2  1  1  1  2  1  1  6
> CharacterLength(tree, dataset, compress = TRUE)
  [1]  1  1  2  2  3  4  4  5  1  6  1  1  2  1  2  4  2  5  2  4  1  2  1  1  2
 [26]  2  2  5  1  1  1  2  4  3  6  5  5  1  2  2  2  1  8  3  7  3  3  2  5  2
 [51]  1  2  2  9 10  5  5  2  4  3  5  1  1  5  6  3  5  5  3  3  2  7  2  1  9
 [76]  5  7  5  1  7  1  5  2  2  8  1  2  2  1  3  2  3  4 12  6  8  4  5  8  7
[101]  1  2  2  1  4  6  2  3  6  6  1  1  1  1  2  1  2  6
> 
> 
> 
> cleanEx()
> nameEx("ClusterStrings")
> ### * ClusterStrings
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ClusterStrings
> ### Title: Cluster similar strings
> ### Aliases: ClusterStrings
> 
> ### ** Examples
> 
> ClusterStrings(c(paste0("FirstCluster ", 1:5),
+                  paste0("SecondCluster.", 8:12),
+                  paste0("AnotherCluster_", letters[1:6])))
 [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 3
attr(,"silhouette")
[1] 0.911867
attr(,"med")
[1] "FirstCluster 1"   "SecondCluster.10" "AnotherCluster_a"
> 
> 
> 
> cleanEx()
> nameEx("ConcordantInformation")
> ### * ConcordantInformation
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ConcordantInformation
> ### Title: Evaluate the concordance of information between a tree and a
> ###   dataset
> ### Aliases: ConcordantInformation Evaluate ConcordantInfo
> 
> ### ** Examples
> 
> data(congreveLamsdellMatrices)
> myMatrix <- congreveLamsdellMatrices[[10]]
> ConcordantInformation(TreeTools::NJTree(myMatrix), myMatrix)
dataset contains 821.038 bits, of which 280.813 signal, 540.226 noise, 78.0817 needed.  S:N = 0.519806

informationContent             signal              noise      signalToNoise 
       821.0383923        280.8125010        540.2258914          0.5198057 
   treeInformation       matrixToTree            ignored 
        78.0816559         10.5151253          0.0000000 
> 
> 
> 
> cleanEx()
> nameEx("Consistency")
> ### * Consistency
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Consistency
> ### Title: Consistency / retention "indices"
> ### Aliases: Consistency
> 
> ### ** Examples
> 
> data(inapplicable.datasets)
> dataset <- inapplicable.phyData[[4]]
> Consistency(dataset, TreeTools::NJTree(dataset))
  [1] 0.2500000 0.3333333 0.3333333 0.2500000 0.5000000 0.2500000 0.5000000
  [8] 0.3333333 0.3333333       NaN 0.3333333 1.0000000 0.3333333 0.3333333
 [15] 1.0000000 0.5000000 0.5000000 0.2000000 1.0000000 1.0000000 0.5000000
 [22] 0.2500000 0.3333333 0.2500000 0.5000000 0.5000000 0.5000000 1.0000000
 [29] 0.5000000 0.6666667 0.2500000 0.3333333 0.5000000 0.3333333 0.5000000
 [36] 0.2500000 1.0000000 0.1666667 0.5000000 0.3333333 1.0000000 0.5000000
 [43] 0.4000000 0.5000000 1.0000000 0.5000000 0.3333333 0.2500000 0.3333333
 [50] 1.0000000 0.3333333 0.6666667 0.5000000 0.5000000 0.3333333 0.5000000
 [57] 1.0000000 0.3333333 0.5000000 0.2500000 0.5000000 0.5000000 0.1428571
 [64] 0.6666667 0.5000000 0.2500000 0.8000000 0.7500000 0.2500000 0.1666667
 [71] 0.5000000 1.0000000 1.0000000 0.3333333 0.5000000 0.2500000 0.2000000
 [78] 0.2500000 0.5000000 0.5000000 0.2500000 0.6666667 0.2500000 0.2500000
 [85] 0.5000000 1.0000000 0.5000000 1.0000000 0.5000000 0.4000000 0.4000000
 [92] 0.2000000 1.0000000 0.3333333 1.0000000 0.2500000 0.5000000 1.0000000
 [99] 0.3333333 0.5000000 1.0000000 0.5000000 0.5000000 0.5000000 0.5000000
[106] 1.0000000 0.3333333 0.3333333 1.0000000 0.2500000 1.0000000 0.2500000
[113] 1.0000000 0.5000000 0.5000000 0.2000000 0.5000000 0.3333333 1.0000000
[120] 0.5000000 0.3333333 0.3333333 0.2500000 1.0000000 0.5000000 0.5000000
> 
> 
> 
> cleanEx()
> nameEx("GapHandler")
> ### * GapHandler
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: GapHandler
> ### Title: Read how a Morphy Object handles the inapplicable token
> ### Aliases: GapHandler
> 
> ### ** Examples
> 
> morphyObj <- SingleCharMorphy("-0-0", "Extra")
> GapHandler(morphyObj)
[1] "Extra state"
> morphyObj <- UnloadMorphy(morphyObj)
> 
> 
> 
> cleanEx()
> nameEx("JackLabels")
> ### * JackLabels
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: JackLabels
> ### Title: Label nodes with jackknife support values
> ### Aliases: JackLabels
> 
> ### ** Examples
> 
> library("TreeTools", quietly = TRUE) # for as.phylo
> 
> # jackTrees will usually be generated with Jackknife(), but for simplicity:
> jackTrees <- as.phylo(1:100, 8)
> 
> tree <- as.phylo(0, 8)
> JackLabels(tree, jackTrees)
  11   12   13   14   15 
0.13 0.08 0.14 1.00 1.00 
> 
> tree$node.label <- JackLabels(tree, jackTrees, plot = FALSE)
> 
> 
> 
> cleanEx()

detaching ‘package:TreeTools’, ‘package:ape’

> nameEx("LengthAdded")
> ### * LengthAdded
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LengthAdded
> ### Title: Contribution of character to leaf instability
> ### Aliases: LengthAdded PolEscapa
> 
> ### ** Examples
> 
> trees <- inapplicable.trees[["Vinther2008"]]
> dataset <- inapplicable.phyData[["Vinther2008"]]
> char <- dataset[, 11]
> added <- LengthAdded(trees, char)
> 
> PlotCharacter(
+   tree = trees[[1]], 
+   dataset = char,
+   tip.color = 1 + added[trees[[1]]$tip.label] # Colour by added steps
+ ) -> XX # Suppress return value; display plot only
Error in postorder_order(edge) : 
  Not compatible with requested type: [type=NULL; target=integer].
Calls: PlotCharacter ... PostorderOrder -> PostorderOrder.phylo -> postorder_order
Execution halted
