
R Under development (unstable) (2024-04-11 r86401) -- "Unsuffered Consequences"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "TreeSearch"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('TreeSearch')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("AdditionTree")
> ### * AdditionTree
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: AdditionTree
> ### Title: Addition tree
> ### Aliases: AdditionTree
> 
> ### ** Examples
> 
> data("inapplicable.phyData", package = "TreeSearch")
> AdditionTree(inapplicable.phyData[["Longrich2010"]], concavity = 10)

Phylogenetic tree with 20 tips and 19 internal nodes.

Tip labels:
  Psittacosaurus_spp, Stegoceras_validum, Sphaerotholus_brevis, Thescelosaurus_neglectus, Colepiocephale_lambei, Prenocephale_prenes, ...

Rooted; no branch lengths.
> 
> 
> 
> cleanEx()
> nameEx("Carter1")
> ### * Carter1
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Carter1
> ### Title: Number of trees with _m_ steps
> ### Aliases: Carter1 Log2Carter1 LogCarter1
> 
> ### ** Examples
> 
> # The character `0 0 0 1 1 1`
> Carter1(1, 3, 3) # Exactly one step
[1] 9
> Carter1(2, 3, 3) # Two steps (one extra step)
[1] 54
> 
> # Number of trees that the character can map onto with exactly _m_ steps
> # if non-parsimonious reconstructions are permitted:
> cumsum(sapply(1:3, Carter1, 3, 3))
[1]   9  63 105
> 
> # Three steps allow the character to map onto any of the 105 six-leaf trees.
> 
> 
> 
> 
> cleanEx()
> nameEx("CharacterLength")
> ### * CharacterLength
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CharacterLength
> ### Title: Character length
> ### Aliases: CharacterLength FitchSteps FastCharacterLength
> 
> ### ** Examples
> 
> data("inapplicable.datasets")
> dataset <- inapplicable.phyData[[12]]
> tree <- TreeTools::NJTree(dataset)
> CharacterLength(tree, dataset)
  [1]  1  1  2  2  3  4  4  5  1  6  1  1  2  1  2  4  2  5  2  4  1  1  2  1  1
 [26]  2  2  2  5  1  1  1  2  1  4  3  6  5  5  1  2  1  2  1  1  1  1  1  1  1
 [51]  2  1  1  8  3  7  3  3  2  5  2  1  2  2  2  9 10  5  5  2  4  3  5  1  1
 [76]  5  6  3  5  5  3  3  2  7  2  1  9  5  7  5  1  7  1  5  2  2  8  1  2  2
[101]  1  1  3  2  3  4 12  6  8  4  5  8  7  1  1  2  2  1  1  4  6  2  3  6  6
[126]  1  1  1  1  2  1  1  1  2  1  1  6
> CharacterLength(tree, dataset, compress = TRUE)
  [1]  1  1  2  2  3  4  4  5  1  6  1  1  2  1  2  4  2  5  2  4  1  2  1  1  2
 [26]  2  2  5  1  1  1  2  4  3  6  5  5  1  2  2  2  1  8  3  7  3  3  2  5  2
 [51]  1  2  2  9 10  5  5  2  4  3  5  1  1  5  6  3  5  5  3  3  2  7  2  1  9
 [76]  5  7  5  1  7  1  5  2  2  8  1  2  2  1  3  2  3  4 12  6  8  4  5  8  7
[101]  1  2  2  1  4  6  2  3  6  6  1  1  1  1  2  1  2  6
> 
> 
> 
> cleanEx()
> nameEx("ClusterStrings")
> ### * ClusterStrings
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ClusterStrings
> ### Title: Cluster similar strings
> ### Aliases: ClusterStrings
> 
> ### ** Examples
> 
> ClusterStrings(c(paste0("FirstCluster ", 1:5),
+                  paste0("SecondCluster.", 8:12),
+                  paste0("AnotherCluster_", letters[1:6])))
 [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 3
attr(,"silhouette")
[1] 0.911867
attr(,"med")
[1] "FirstCluster 1"   "SecondCluster.10" "AnotherCluster_a"
> 
> 
> 
> cleanEx()
> nameEx("ConcordantInformation")
> ### * ConcordantInformation
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ConcordantInformation
> ### Title: Evaluate the concordance of information between a tree and a
> ###   dataset
> ### Aliases: ConcordantInformation Evaluate ConcordantInfo
> 
> ### ** Examples
> 
> data(congreveLamsdellMatrices)
> myMatrix <- congreveLamsdellMatrices[[10]]
> ConcordantInformation(TreeTools::NJTree(myMatrix), myMatrix)
dataset contains 821.038 bits, of which 280.813 signal, 540.226 noise, 78.0817 needed.  S:N = 0.519806

informationContent             signal              noise      signalToNoise 
       821.0383923        280.8125010        540.2258914          0.5198057 
   treeInformation       matrixToTree            ignored 
        78.0816559         10.5151253          0.0000000 
> 
> 
> 
> cleanEx()
> nameEx("Consistency")
> ### * Consistency
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Consistency
> ### Title: Consistency / retention "indices"
> ### Aliases: Consistency
> 
> ### ** Examples
> 
> data(inapplicable.datasets)
> dataset <- inapplicable.phyData[[4]]
> head(Consistency(dataset, TreeTools::NJTree(dataset)))
            ci        ri        rc
[1,] 0.2500000 0.6250000 0.1562500
[2,] 0.3333333 0.3333333 0.1111111
[3,] 0.3333333 0.6000000 0.2000000
[4,] 0.2500000 0.2500000 0.0625000
[5,] 0.5000000 0.8333333 0.4166667
[6,] 0.2500000 0.2500000 0.0625000
> 
> 
> 
> cleanEx()
> nameEx("GapHandler")
> ### * GapHandler
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: GapHandler
> ### Title: Read how a Morphy Object handles the inapplicable token
> ### Aliases: GapHandler
> 
> ### ** Examples
> 
> morphyObj <- SingleCharMorphy("-0-0", "Extra")
> GapHandler(morphyObj)
[1] "Extra state"
> morphyObj <- UnloadMorphy(morphyObj)
> 
> 
> 
> cleanEx()
> nameEx("JackLabels")
> ### * JackLabels
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: JackLabels
> ### Title: Label nodes with jackknife support values
> ### Aliases: JackLabels
> 
> ### ** Examples
> 
> library("TreeTools", quietly = TRUE) # for as.phylo
> 
> # jackTrees will usually be generated with Jackknife(), but for simplicity:
> jackTrees <- as.phylo(1:100, 8)
> 
> tree <- as.phylo(0, 8)
> JackLabels(tree, jackTrees)
  11   12   13   14   15 
0.13 0.08 0.14 1.00 1.00 
> 
> tree$node.label <- JackLabels(tree, jackTrees, plot = FALSE)
> 
> 
> 
> cleanEx()

detaching ‘package:TreeTools’, ‘package:ape’

> nameEx("LengthAdded")
> ### * LengthAdded
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LengthAdded
> ### Title: Contribution of character to leaf instability
> ### Aliases: LengthAdded PolEscapa
> 
> ### ** Examples
> 
> trees <- inapplicable.trees[["Vinther2008"]]
> dataset <- inapplicable.phyData[["Vinther2008"]]
> char <- dataset[, 11]
> added <- LengthAdded(trees, char)
> 
> PlotCharacter(
+   tree = trees[[1]], 
+   dataset = char,
+   tip.color = 1 + added[trees[[1]]$tip.label] # Colour by added steps
+ ) -> XX # Suppress return value; display plot only
> 
> 
> 
> 
> cleanEx()
> nameEx("MaximizeParsimony")
> ### * MaximizeParsimony
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MaximizeParsimony
> ### Title: Find most parsimonious trees
> ### Aliases: MaximizeParsimony Resample EasyTrees EasyTreesy
> 
> ### ** Examples
> 
> ## Only run examples in interactive R sessions
> if (interactive()) {
+   # launch "shiny" point-and-click interface
+   EasyTrees()
+   
+   # Here too, use the "continue search" function to ensure that tree score
+   # has stabilized and a global optimum has been found
+ }
> 
> 
> # Load data for analysis in R
> library("TreeTools")
Loading required package: ape
> data("congreveLamsdellMatrices", package = "TreeSearch")
> dataset <- congreveLamsdellMatrices[[42]]
> 
> # A very quick run for demonstration purposes
> trees <- MaximizeParsimony(dataset, ratchIter = 0, startIter = 0,
+                            tbrIter = 1, maxHits = 4, maxTime = 1/100,
+                            concavity = 10, verbosity = 4)

── BEGIN TREE SEARCH (k = 10) ──────────────────────────────────────────────────
→ Initial score: 12.6988 

── Sample local optimum ────────────────────────────────────────────────────────
→ TBR depth 1; keeping 4 trees; k = 10
ℹ 2024-04-11 09:21:51: Score: 12.6988
Final search ■                                  0% | D0, score 12.0038, hit 1. …
  - TBR rearrangement at depth 1 found score 11.9697 1 time.

✔ 2024-04-11 09:21:54: Tree search terminated with score 11.9697
> names(trees)
[1] "final_1"
> 
> # In actual use, be sure to check that the score has converged on a global
> # optimum, conducting additional iterations and runs as necessary.
>  
> if (interactive()) {
+ # Jackknife resampling
+ nReplicates <- 10
+ jackTrees <- replicate(nReplicates,
+   #c() ensures that each replicate returns a list of trees
+   c(Resample(dataset, trees, ratchIter = 0, tbrIter = 2, startIter = 1,
+              maxHits = 5, maxTime = 1 / 10,
+              concavity = 10, verbosity = 0))
+  )
+ 
+ # In a serious analysis, more replicates would be conducted, and each
+ # search would undergo more iterations.
+ 
+ # Now we must decide what to do with the multiple optimal trees from
+ # each replicate.
+ 
+ # Treat each tree equally
+ JackLabels(ape::consensus(trees), unlist(jackTrees, recursive = FALSE))
+ 
+ # Take the strict consensus of all trees for each replicate
+ JackLabels(ape::consensus(trees), lapply(jackTrees, ape::consensus))
+ 
+ # Take a single tree from each replicate (the first; order's irrelevant)
+ JackLabels(ape::consensus(trees), lapply(jackTrees, `[[`, 1))
+ }
> 
> # Tree search with a constraint
> constraint <- MatrixToPhyDat(c(a = 1, b = 1, c = 0, d = 0, e = 0, f = 0))
> characters <- MatrixToPhyDat(matrix(
+   c(0, 1, 1, 1, 0, 0,
+     1, 1, 1, 0, 0, 0), ncol = 2,
+   dimnames = list(letters[1:6], NULL)))
> MaximizeParsimony(characters, constraint = constraint, verbosity = 0)
✔ Initialized 1 distinct constraints.
1 phylogenetic tree
> 
> 
> 
> 
> cleanEx()

detaching ‘package:TreeTools’, ‘package:ape’

> nameEx("MinimumLength")
> ### * MinimumLength
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MinimumLength
> ### Title: Minimum and Maximum lengths possible for a character
> ### Aliases: MinimumLength MinimumLength.phyDat MinimumLength.numeric
> ###   MinimumLength.character MaximumLength.character MinimumSteps
> ###   MaximumLength MaximumLength.numeric
> 
> ### ** Examples
> 
> data("inapplicable.datasets")
> myPhyDat <- inapplicable.phyData[[4]]
> 
> # load your own data with
> # my.PhyDat <- as.phyDat(read.nexus.data("filepath"))
> # or Windows users can select a file interactively using:
> # my.PhyDat <- as.phyDat(read.nexus.data(choose.files()))
> 
> class(myPhyDat) # phyDat object
[1] "phyDat"
> 
> # Minimum length of each character in turn
> MinimumLength(myPhyDat)
  [1] 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 2 1 1 1 1 1 1 1
 [38] 1 1 1 1 1 2 1 1 1 1 1 1 1 1 2 1 1 1 1 1 2 1 1 2 1 1 2 1 1 4 3 1 1 1 1 2 1
 [75] 1 1 1 1 1 1 2 4 1 1 1 1 1 1 1 2 2 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1
[112] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
> 
> # Collapse duplicate characters, per phyDat compression
> MinimumLength(myPhyDat, compress = TRUE)
  [1] 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 2 1 1 1 1 1 1 1
 [38] 1 1 1 1 1 2 1 1 1 1 1 1 1 1 2 1 1 1 1 1 2 1 1 2 1 1 2 1 1 4 3 1 1 1 1 2 1
 [75] 1 1 1 1 1 1 2 4 1 1 1 1 1 1 1 2 2 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1
[112] 1 1 1 1 1 1 1 1 1 1 1 1 1 1
> 
> # Calculate length of a single character from its textual representation
> MinimumLength("-{-1}{-2}{-3}2233")
[1] 2
> MaximumLength("----0011")
[1] 3
> 
> 
> 
> cleanEx()
> nameEx("MorphyWeights")
> ### * MorphyWeights
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MorphyWeights
> ### Title: Set and get the character weightings associated with a Morphy
> ###   object.
> ### Aliases: MorphyWeights SetMorphyWeights
> 
> ### ** Examples
> 
> tokens <- matrix(c(
+   0, 0, 0, 1, 1, 2,
+   0, 0, 0, 0, 0, 0), byrow = TRUE, nrow = 2L,
+   dimnames = list(letters[1:2], NULL))
> pd <- TreeTools::MatrixToPhyDat(tokens)
> morphyObj <- PhyDat2Morphy(pd)
> MorphyWeights(morphyObj)
       [,1] [,2] [,3]
approx 3    2    1   
exact  3    2    1   
> if (SetMorphyWeights(c(1, 1.5, 2/3), morphyObj) != 0L) message("Errored")
> MorphyWeights(morphyObj)
       [,1] [,2] [,3]     
approx 6    9    4        
exact  1    1.5  0.6666667
> morphyObj <- UnloadMorphy(morphyObj)
> 
> 
> 
> cleanEx()
> nameEx("NNI")
> ### * NNI
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NNI
> ### Title: Nearest neighbour interchange (NNI)
> ### Aliases: NNI cNNI NNISwap RootedNNI RootedNNISwap
> 
> ### ** Examples
> 
> tree <- TreeTools::BalancedTree(8)
> # A random rearrangement
> NNI(tree)

Phylogenetic tree with 8 tips and 7 internal nodes.

Tip labels:
  t1, t2, t3, t4, t5, t6, ...

Rooted; no branch lengths.
> cNNI(tree)

Phylogenetic tree with 8 tips and 7 internal nodes.

Tip labels:
  t1, t2, t3, t4, t5, t6, ...

Rooted; no branch lengths.
> 
> # All trees one NNI rearrangement away
> NNI(tree, edgeToBreak = -1)
12 phylogenetic trees
> 
> # Manual random sampling
> cNNI(tree, sample.int(14 - 8 - 1, 1), sample.int(2, 1))

Phylogenetic tree with 8 tips and 7 internal nodes.

Tip labels:
  t1, t2, t3, t4, t5, t6, ...

Rooted; no branch lengths.
> 
> # A specified rearrangement
> cNNI(tree, 0, 0)

Phylogenetic tree with 8 tips and 7 internal nodes.

Tip labels:
  t1, t2, t3, t4, t5, t6, ...

Rooted; no branch lengths.
> 
> # If a tree may not be binary, collapse nodes with
> tree <- TreeTools::MakeTreeBinary(tree)
> 
> # If a tree may be improperly rooted, use
> tree <- TreeTools::RootTree(tree, 1)
> 
> # If a tree may exhibit unusual node ordering, this can be addressed with
> tree <- TreeTools::Preorder(tree)
> 
> 
> 
> cleanEx()
> nameEx("PhyDat2Morphy")
> ### * PhyDat2Morphy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PhyDat2Morphy
> ### Title: Initialize a Morphy object from a 'phyDat' object
> ### Aliases: PhyDat2Morphy
> 
> ### ** Examples
> 
> data("Lobo", package="TreeTools")
> morphyObj <- PhyDat2Morphy(Lobo.phy)
> # Set object to be destroyed at end of session or closure of function
> # on.exit(morphyObj <- UnloadMorphy(morphyObj), add = TRUE)
> 
> # Do something with pointer
> # ....
> 
> # Or, instead of on.exit, manually destroy morphy object and free memory:
> morphyObj <- UnloadMorphy(morphyObj)
> 
> 
> 
> cleanEx()
> nameEx("PlotCharacter")
> ### * PlotCharacter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PlotCharacter
> ### Title: Plot the distribution of a character on a tree
> ### Aliases: PlotCharacter
> 
> ### ** Examples
> 
> # Set up plotting area
> oPar <- par(mar = rep(0, 4))
> 
> tree <- ape::read.tree(text = 
+   "((((((a, b), c), d), e), f), (g, (h, (i, (j, (k, l))))));")
> ## A character with inapplicable data
> dataset <- TreeTools::StringToPhyDat("23--1??--032", tips = tree)
> plotted <- PlotCharacter(tree, dataset)
> plotted
          -     0     1     2     3
 [1,] FALSE FALSE FALSE  TRUE FALSE
 [2,] FALSE FALSE FALSE FALSE  TRUE
 [3,]  TRUE FALSE FALSE FALSE FALSE
 [4,]  TRUE FALSE FALSE FALSE FALSE
 [5,] FALSE FALSE  TRUE FALSE FALSE
 [6,]  TRUE  TRUE  TRUE  TRUE  TRUE
 [7,]  TRUE  TRUE  TRUE  TRUE  TRUE
 [8,]  TRUE FALSE FALSE FALSE FALSE
 [9,]  TRUE FALSE FALSE FALSE FALSE
[10,] FALSE  TRUE FALSE FALSE FALSE
[11,] FALSE FALSE FALSE FALSE  TRUE
[12,] FALSE FALSE FALSE  TRUE FALSE
[13,]  TRUE FALSE FALSE FALSE FALSE
[14,]  TRUE FALSE FALSE FALSE FALSE
[15,]  TRUE FALSE FALSE FALSE FALSE
[16,]  TRUE FALSE FALSE FALSE FALSE
[17,]  TRUE FALSE FALSE FALSE FALSE
[18,] FALSE FALSE FALSE  TRUE  TRUE
[19,]  TRUE FALSE FALSE FALSE FALSE
[20,]  TRUE FALSE FALSE FALSE FALSE
[21,]  TRUE FALSE FALSE FALSE FALSE
[22,] FALSE  TRUE FALSE  TRUE  TRUE
[23,] FALSE  TRUE FALSE  TRUE  TRUE
> 
> # Character from a real dataset 
> data("Lobo", package = "TreeTools")
> dataset <- Lobo.phy
> tree <- TreeTools::NJTree(dataset)
> PlotCharacter(tree, dataset, 14)
> par(oPar)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("PrepareDataProfile")
> ### * PrepareDataProfile
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PrepareDataProfile
> ### Title: Prepare data for Profile Parsimony
> ### Aliases: PrepareDataProfile PrepareDataIW
> 
> ### ** Examples
> 
> data("congreveLamsdellMatrices")
> dataset <- congreveLamsdellMatrices[[42]]
> PrepareDataProfile(dataset)
22 sequences with 55 character and 55 different site patterns.
The states are 0 1 
> 
> 
> 
> cleanEx()
> nameEx("QuartetResolution")
> ### * QuartetResolution
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: QuartetResolution
> ### Title: Relationship between four taxa
> ### Aliases: QuartetResolution
> 
> ### ** Examples
> 
> trees <- inapplicable.trees[["Vinther2008"]]
> tips <- c("Lingula", "Halkieria", "Wiwaxia", "Acaenoplax")
> QuartetResolution(trees, tips)
 [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 3 2 3 3 2 1 3 3 3 2 3 2 2 2
[39] 3 3 2 2 1 2 3 2 1 1 2 1 3 2 3 3 2 1 1 1 3 1 2 1 2 1 3 3 2 1 2 1 2 2 3
> 
> 
> 
> cleanEx()
> nameEx("RandomTreeScore")
> ### * RandomTreeScore
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: RandomTreeScore
> ### Title: Parsimony score of random postorder tree
> ### Aliases: RandomTreeScore
> 
> ### ** Examples
> 
> tokens <- matrix(c(
+   0, "-", "-", 1, 1, 2,
+   0, 1, 0, 1, 2, 2,
+   0, "-", "-", 0, 0, 0), byrow = TRUE, nrow = 3L,
+   dimnames = list(letters[1:3], NULL))
> pd <- TreeTools::MatrixToPhyDat(tokens)
> morphyObj <- PhyDat2Morphy(pd)
> 
> RandomTreeScore(morphyObj)
[1] 4
> 
> morphyObj <- UnloadMorphy(morphyObj)
> 
> 
> 
> cleanEx()
> nameEx("Ratchet")
> ### * Ratchet
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MorphyBootstrap
> ### Title: Parsimony Ratchet
> ### Aliases: MorphyBootstrap Ratchet MultiRatchet RatchetConsensus
> 
> ### ** Examples
> 
> data("Lobo", package = "TreeTools")
> njtree <- TreeTools::NJTree(Lobo.phy)
> # Increase value of ratchIter and searchHits to do a proper search
> quickResult <- Ratchet(njtree, Lobo.phy, ratchIter = 2, searchHits = 3)
* Beginning Parsimony Ratchet, with initial score 231
Completed parsimony ratchet after 2 iterations with score 213

> 
> # Plot result (legibly)
> oldPar <- par(mar = rep(0, 4), cex = 0.75)
> plot(quickResult)
> par(oldPar)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("RearrangeEdges")
> ### * RearrangeEdges
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: RearrangeEdges
> ### Title: Rearrange edges of a phylogenetic tree
> ### Aliases: RearrangeEdges
> 
> ### ** Examples
> 
> data("Lobo", package="TreeTools")
> tree <- TreeTools::NJTree(Lobo.phy)
> edge <- tree$edge
> parent <- edge[, 1]
> child <- edge[, 2]
> dataset <- PhyDat2Morphy(Lobo.phy)
> RearrangeEdges(parent, child, dataset, EdgeSwapper = RootedNNISwap)
[[1]]
 [1] 49 49 50 50 51 52 53 54 55 56 56 55 57 58 58 57 59 60 60 59 61 62 62 63 64
[26] 64 63 65 66 66 65 67 67 61 68 69 70 71 71 70 69 72 72 68 54 73 73 74 75 75
[51] 74 53 76 76 77 77 78 79 79 78 80 81 82 82 81 80 83 83 84 85 86 86 85 87 87
[76] 84 52 88 88 51 89 90 91 92 92 91 93 93 94 94 95 95 90 89

[[2]]
 [1]  1 50  2 51 52 53 54 55 56  3  4 57 58 31 32 59 60 34 35 61 62 36 63 64 43
[26] 44 65 66 45 46 67 47 48 68 69 70 71 37 41 42 72 38 39 40 73  5 74 75 28 29
[51] 30 76  6 77  9 78 79 10 11 80 81 82 12 13 22 83 14 84 85 86 15 18 87 16 17
[76] 19 88  7  8 89 90 91 92 20 21 93 24 94 25 95 26 27 23 33

[[3]]
[1] 232

[[4]]
[1] 0

> # Remember to free memory:
> dataset <- UnloadMorphy(dataset)
> 
> 
> 
> cleanEx()
> nameEx("SPR")
> ### * SPR
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SPR
> ### Title: Subtree pruning and rearrangement (SPR)
> ### Aliases: SPR SPRMoves SPRMoves.phylo SPRMoves.matrix SPRSwap RootedSPR
> ###   RootedSPRSwap
> 
> ### ** Examples
> 
> {
+ tree <- ape::rtree(20, br=FALSE)
+ SPR(tree)
+ }

Phylogenetic tree with 20 tips and 19 internal nodes.

Tip labels:
  t10, t14, t20, t7, t9, t15, ...

Rooted; includes branch lengths.
> 
> 
> 
> cleanEx()
> nameEx("SingleCharMorphy")
> ### * SingleCharMorphy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SingleCharMorphy
> ### Title: Morphy object from single character
> ### Aliases: SingleCharMorphy
> 
> ### ** Examples
> 
> morphyObj <- SingleCharMorphy("-0-0", gap = "Extra")
> RandomTreeScore(morphyObj)
[1] 2
> morphyObj <- UnloadMorphy(morphyObj)
> 
> 
> 
> cleanEx()
> nameEx("SiteConcordance")
> ### * SiteConcordance
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SiteConcordance
> ### Title: Calculate site concordance factor
> ### Aliases: SiteConcordance QuartetConcordance ClusteringConcordance
> ###   PhylogeneticConcordance MutualClusteringConcordance
> ###   SharedPhylogeneticConcordance
> 
> ### ** Examples
> 
> data("congreveLamsdellMatrices", package = "TreeSearch")
> dataset <- congreveLamsdellMatrices[[1]][, 1:20]
> tree <- referenceTree
> qc <- QuartetConcordance(tree, dataset)
> cc <- ClusteringConcordance(tree, dataset)
> pc <- PhylogeneticConcordance(tree, dataset)
> spc <- SharedPhylogeneticConcordance(tree, dataset)
> mcc <- MutualClusteringConcordance(tree, dataset)
> 
> oPar <- par(mar = rep(0, 4), cex = 0.8)
> plot(tree)
> TreeTools::LabelSplits(tree, signif(qc, 3))
> TreeTools::LabelSplits(tree, signif(cc, 3))
> TreeTools::LabelSplits(tree, signif(pc, 3))
> par(oPar)
> 
> pairs(cbind(qc, cc, pc, spc, mcc))
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("StepInformation")
> ### * StepInformation
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: StepInformation
> ### Title: Information content of a character known to contain _e_ steps
> ### Aliases: StepInformation
> 
> ### ** Examples
> 
> character <- rep(c(0:3, "?", "-"), c(8, 5, 1, 1, 2, 2))
> StepInformation(character)
        3         4         5         6         7 
9.9203529 5.5280354 2.5784492 0.7618403 0.0000000 
> 
> 
> 
> cleanEx()
> nameEx("TBR")
> ### * TBR
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: TBR
> ### Title: Tree bisection and reconnection (TBR)
> ### Aliases: TBR TBRMoves TBRMoves.phylo TBRMoves.matrix TBRSwap RootedTBR
> ###   RootedTBRSwap
> 
> ### ** Examples
> 
> library("ape")
> tree <- rtree(20, br=NULL)
> TBR(tree)

Phylogenetic tree with 20 tips and 19 internal nodes.

Tip labels:
  t10, t14, t20, t7, t9, t15, ...

Rooted; no branch lengths.
> 
> 
> 
> cleanEx()

detaching ‘package:ape’

> nameEx("TBRWarning")
> ### * TBRWarning
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SPRWarning
> ### Title: TBR Warning Print a warning and return given tree
> ### Aliases: SPRWarning TBRWarning
> ### Keywords: internal
> 
> ### ** Examples
> 
> suppressWarnings(TBRWarning(0, 0, "Message text")) # will trigger warning
[[1]]
[1] 0

[[2]]
[1] 0

> 
> 
> 
> 
> cleanEx()
> nameEx("TaxonInfluence")
> ### * TaxonInfluence
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: TaxonInfluence
> ### Title: Rank taxa by their influence on phylogenetic results
> ### Aliases: TaxonInfluence
> 
> ### ** Examples
> 
> #' # Load data for analysis in R
> library("TreeTools")
Loading required package: ape
> data("congreveLamsdellMatrices", package = "TreeSearch")
> 
> # Small dataset for demonstration purposes
> dataset <- congreveLamsdellMatrices[[42]][1:8, ]
> bestTree <- MaximizeParsimony(dataset, verbosity = 0)[[1]]
> 
> # Calculate tip influence
> influence <- TaxonInfluence(dataset, ratchIt = 0, startIt = 0, verbos = 0)

── BEGIN TREE SEARCH (k = Inf) ─────────────────────────────────────────────────
→ Initial score: 85 

── Sample local optimum ────────────────────────────────────────────────────────
→ TBR depth 2; keeping 14.4 trees; k = Inf
ℹ 2024-04-11 09:22:02: Score: 85
✔ 2024-04-11 09:22:02: Tree search terminated with score 83
> 
> # Colour tip labels according to their influence
> upperBound <- 2 * TreeDist::ClusteringEntropy(
+   PectinateTree(NTip(dataset) - 1))
> nBin <- 128
> bin <- cut(
+   influence["max", ],
+   breaks = seq(0, upperBound, length.out = nBin),
+   include.lowest = TRUE
+ )
> palette <- hcl.colors(nBin, "inferno")
> 
> plot(bestTree, tip.color = palette[bin])
> PlotTools::SpectrumLegend(
+   "bottomleft",
+   palette = palette,
+   title = "Tip influence / bits",
+   legend = signif(seq(upperBound, 0, length.out = 4), 3),
+   bty = "n"
+ )
> 
> 
> 
> cleanEx()

detaching ‘package:TreeTools’, ‘package:ape’

> nameEx("TreeLength")
> ### * TreeLength
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: IWScore
> ### Title: Calculate the parsimony score of a tree given a dataset
> ### Aliases: IWScore TreeLength TreeLength.phylo TreeLength.numeric
> ###   TreeLength.list TreeLength.multiPhylo Fitch
> 
> ### ** Examples
> 
> data("inapplicable.datasets")
> tree <- TreeTools::BalancedTree(inapplicable.phyData[[1]])
> TreeLength(tree, inapplicable.phyData[[1]])
[1] 1117
> TreeLength(tree, inapplicable.phyData[[1]], concavity = 10)
[1] 52.75785
> TreeLength(tree, inapplicable.phyData[[1]], concavity = "profile")
→ Inapplicable tokens treated as ambiguous for profile parsimony
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
Warning in .RemoveExtraTokens(mataset[i, ], ambiguousTokens = qmLevel) :
  Can handle max. 2 informative tokens. Dropping others.
[1] 3941.387
> TreeLength(5, inapplicable.phyData[[1]])
[1] 1920 1950 1924 1950 2046
> 
> 
> 
> cleanEx()
> nameEx("TreeSearch")
> ### * TreeSearch
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: EdgeListSearch
> ### Title: Search for most parsimonious trees
> ### Aliases: EdgeListSearch TreeSearch IWTreeSearch EmptyPhyDat DoNothing
> ### Keywords: internal
> 
> ### ** Examples
> 
> data("Lobo", package="TreeTools")
> njtree <- TreeTools::NJTree(Lobo.phy)
> 
> ## Only run examples in interactive R sessions
> if (interactive()) {
+   TreeSearch(njtree, Lobo.phy, maxIter = 20, EdgeSwapper = NNISwap)
+   TreeSearch(njtree, Lobo.phy, maxIter = 20, EdgeSwapper = RootedSPRSwap)
+   TreeSearch(njtree, Lobo.phy, maxIter = 20, EdgeSwapper = TBRSwap)
+ }
> 
> 
> 
> cleanEx()
> nameEx("WhenFirstHit")
> ### * WhenFirstHit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: WhenFirstHit
> ### Title: When was a tree topology first hit?
> ### Aliases: WhenFirstHit
> 
> ### ** Examples
> 
> library("TreeTools", quietly = TRUE)
> trees <- list(
+    seed_00 = as.phylo(1, 8),
+    ratch1_01 = as.phylo(2, 8),
+    ratch1_02 = as.phylo(3, 8),
+    ratch4_44 = as.phylo(4, 8),
+    final_99 = as.phylo(5, 8)
+ )
> attr(WhenFirstHit(trees), "firstHit")
whenHit
  seed ratch1 ratch4  final 
     1      2      1      1 
> 
> 
> 
> cleanEx()

detaching ‘package:TreeTools’, ‘package:ape’

> nameEx("WithOneExtraStep")
> ### * WithOneExtraStep
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: WithOneExtraStep
> ### Title: Number of trees with one extra step
> ### Aliases: WithOneExtraStep
> 
> ### ** Examples
> 
> WithOneExtraStep(1, 2, 3)
[1] 84
> 
> 
> 
> cleanEx()
> nameEx("cSPR")
> ### * cSPR
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cSPR
> ### Title: 'cSPR()' expects a tree rooted on a single tip.
> ### Aliases: cSPR
> 
> ### ** Examples
> 
> tree <- TreeTools::BalancedTree(8)
> 
> # Tree must be rooted on leaf
> tree <- TreeTools::RootTree(tree, 1)
> 
> # Random rearrangement
> cSPR(tree)

Phylogenetic tree with 8 tips and 7 internal nodes.

Tip labels:
  t1, t2, t3, t4, t5, t6, ...

Rooted; no branch lengths.
> 
> # Specific rearrangement
> cSPR(tree, 9)

Phylogenetic tree with 8 tips and 7 internal nodes.

Tip labels:
  t1, t2, t3, t4, t5, t6, ...

Rooted; no branch lengths.
> 
> 
> 
> cleanEx()
> nameEx("congreveLamsdellMatrices")
> ### * congreveLamsdellMatrices
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: congreveLamsdellMatrices
> ### Title: 100 simulated data matrices
> ### Aliases: congreveLamsdellMatrices
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data("referenceTree")
> data("congreveLamsdellMatrices")
> TreeLength(referenceTree, congreveLamsdellMatrices[[17]], "profile")
[1] 549.6488
> 
> 
> 
> 
> cleanEx()
> nameEx("dot-NonDuplicateRoot")
> ### * dot-NonDuplicateRoot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: .NonDuplicateRoot
> ### Title: Non-duplicate root
> ### Aliases: .NonDuplicateRoot
> ### Keywords: internal
> 
> ### ** Examples
> 
> tree <- TreeTools::Preorder(TreeTools::BalancedTree(8))
> edge <- tree$edge
> parent <- edge[, 1]
> child <- edge[, 2]
> 
> which(!.NonDuplicateRoot(parent, child))
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("inapplicable.datasets")
> ### * inapplicable.datasets
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: inapplicable.datasets
> ### Title: Thirty datasets with inapplicable data
> ### Aliases: inapplicable.datasets inapplicable.phyData inapplicable.trees
> ###   inapplicable.citations
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data("inapplicable.datasets", package = "TreeSearch")
> names(inapplicable.datasets)
 [1] "Agnarsson2004" "Aguado2009"    "Aria2015"      "Asher2005"    
 [5] "Capa2011"      "Conrad2008"    "DeAssis2011"   "Dikow2009"    
 [9] "Eklund2004"    "Geisler2001"   "Giles2015"     "Griswold1999" 
[13] "Liljeblad2008" "Loconte1991"   "Longrich2010"  "OLeary1999"   
[17] "OMeara2014"    "Rougier2012"   "Rousset2004"   "Sano2011"     
[21] "Sansom2010"    "Schulze2007"   "Shultz2007"    "Vinther2008"  
[25] "Wetterer2000"  "Wills2012"     "Wilson2003"    "Wortley2006"  
[29] "Zanol2014"     "Zhu2013"      
> 
> 
> 
> cleanEx()
> nameEx("mpl_new_Morphy")
> ### * mpl_new_Morphy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mpl_new_Morphy
> ### Title: Creates a new instance of a Morphy object
> ### Aliases: mpl_new_Morphy
> ### Keywords: internal
> 
> ### ** Examples
> 
> morphyObj <- mpl_new_Morphy() # Create new object
> ## Do some stuff ... ##
> mpl_delete_Morphy(morphyObj) # Delete when done
[1] 0
> 
> 
> 
> 
> cleanEx()
> nameEx("mpl_translate_error")
> ### * mpl_translate_error
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mpl_translate_error
> ### Title: Converts a numeric error code to human-readable format
> ### Aliases: mpl_translate_error
> ### Keywords: internal
> 
> ### ** Examples
> 
> mpl_translate_error(-1) # "ERR_INVALID_SYMBOL"
[1] "ERR_INVALID_SYMBOL"
> 
> 
> 
> 
> cleanEx()
> nameEx("profiles")
> ### * profiles
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: profiles
> ### Title: Empirically counted profiles for small trees
> ### Aliases: profiles
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(profiles)
> 
> # Load profile for a character of the structure 0 0 0 1 1 1 1 1
> profile3.5 <- profiles[[8]][[2]][[3]]
> 
> # Number of trees with _s_ or fewer steps on that character
> TreeTools::NUnrooted(8) * 2 ^ profile3.5
    1     2     3     4 
  225  2475  8019 10395 
> 
> 
> 
> cleanEx()
> nameEx("referenceTree")
> ### * referenceTree
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: referenceTree
> ### Title: Tree topology for matrix simulation
> ### Aliases: referenceTree
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(referenceTree)
> plot(referenceTree)
> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  35.427 1.239 37.086 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
