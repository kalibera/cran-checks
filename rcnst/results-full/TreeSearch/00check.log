* using log directory ‘/var/scratch2/tomas/cran/rcnst/check/TreeSearch.Rcheck’
* using R Under development (unstable) (2023-12-02 r85657)
* using platform: x86_64-pc-linux-gnu
* R was compiled by
    gcc (GCC) 13.2.1 20231011 (Red Hat 13.2.1-4)
    GNU Fortran (GCC) 13.2.1 20231011 (Red Hat 13.2.1-4)
* running under: Fedora Linux 38 (MATE-Compiz)
* using session charset: UTF-8
* checking for file ‘TreeSearch/DESCRIPTION’ ... OK
* this is package ‘TreeSearch’ version ‘1.4.0’
* package encoding: UTF-8
* checking package namespace information ... OK
* checking package dependencies ... OK
* checking if this is a source package ... OK
* checking if there is a namespace ... OK
* checking for executable files ... OK
* checking for hidden files and directories ... OK
* checking for portable file names ... OK
* checking for sufficient/correct file permissions ... OK
* checking whether package ‘TreeSearch’ can be installed ... OK
* used C compiler: ‘gcc (GCC) 13.2.1 20231011 (Red Hat 13.2.1-4)’
* used C++ compiler: ‘g++ (GCC) 13.2.1 20231011 (Red Hat 13.2.1-4)’
* checking C++ specification ... OK
  Not all R platforms support C++17
* checking package directory ... OK
* checking ‘build’ directory ... OK
* checking DESCRIPTION meta-information ... OK
* checking top-level files ... OK
* checking for left-over files ... OK
* checking index information ... OK
* checking package subdirectories ... OK
* checking R files for non-ASCII characters ... OK
* checking R files for syntax errors ... OK
* checking whether the package can be loaded ... OK
* checking whether the package can be loaded with stated dependencies ... OK
* checking whether the package can be unloaded cleanly ... OK
* checking whether the namespace can be loaded with stated dependencies ... OK
* checking whether the namespace can be unloaded cleanly ... OK
* checking loading without being on the library search path ... OK
* checking dependencies in R code ... OK
* checking S3 generic/method consistency ... OK
* checking replacement functions ... OK
* checking foreign function calls ... OK
* checking R code for possible problems ... OK
* checking Rd files ... OK
* checking Rd metadata ... OK
* checking Rd cross-references ... OK
* checking for missing documentation entries ... OK
* checking for code/documentation mismatches ... OK
* checking Rd \usage sections ... OK
* checking Rd contents ... OK
* checking for unstated dependencies in examples ... OK
* checking contents of ‘data’ directory ... OK
* checking data for non-ASCII characters ... OK
* checking LazyData ... OK
* checking data for ASCII and uncompressed saves ... OK
* checking line endings in C/C++/Fortran sources/headers ... OK
* checking compiled code ... NOTE
Note: information on .o files is not available
* checking installed files from ‘inst/doc’ ... OK
* checking files in ‘vignettes’ ... OK
* checking examples ... OK
* checking for unstated dependencies in ‘tests’ ... OK
* checking tests ... ERROR
  Running ‘spelling.R’
  Running ‘testthat.R’
Running the tests in ‘tests/testthat.R’ failed.
Last 13 lines of output:
      attr(dataset, "levels") <- lvls
      attr(dataset, "allLevels") <- c(lvls, "?")
      attr(dataset, "contrast") <- matrix(c(1, 0, 1, 0, 1, 1), 
          length(lvls) + 1L, length(lvls), dimnames = list(NULL, 
              lvls))
      attr(dataset, "nc") <- length(lvls)
      if (!any(attr(dataset, "bootstrap") == "info.amounts")) {
          attr(dataset, "bootstrap") <- c(attr(dataset, "bootstrap"), 
              "info.amounts")
      }
      dataset
  }
  Function PrepareDataProfile in namespace TreeSearch has this body.
  Fatal error: compiler constants were modified!
  
* checking for unstated dependencies in vignettes ... OK
* checking package vignettes in ‘inst/doc’ ... OK
* checking running R code from vignettes ... NONE
  ‘custom.Rmd’ using ‘UTF-8’... OK
  ‘getting-started.Rmd’ using ‘UTF-8’... OK
  ‘profile-scores.Rmd’ using ‘UTF-8’... OK
  ‘profile.Rmd’ using ‘UTF-8’... OK
  ‘tree-search.Rmd’ using ‘UTF-8’... OK
  ‘tree-space.Rmd’ using ‘UTF-8’... OK
* checking re-building of vignette outputs ... ERROR
Error(s) in re-building vignettes:
--- re-building ‘custom.Rmd’ using rmarkdown
--- finished re-building ‘custom.Rmd’

--- re-building ‘getting-started.Rmd’ using rmarkdown
--- finished re-building ‘getting-started.Rmd’

--- re-building ‘profile-scores.Rmd’ using rmarkdown
--- finished re-building ‘profile-scores.Rmd’

--- re-building ‘profile.Rmd’ using rmarkdown
ERROR: modification of compiler constant of type character, length 2
ERROR: the modified value of the constant is:
[1] "0" "1"
attr(,".match.hash")
<hash table>
ERROR: the original value of the constant is:
[1] "0" "1"
ERROR: the modified constant is at index 285
ERROR: the modified constant is in this function body:
{
    if ("info.amounts" %fin% names(attributes(dataset))) {
        return(dataset)
    }
    at <- attributes(dataset)
    nLevel <- length(at$level)
    cont <- attr(dataset, "contrast")
    nTip <- length(dataset)
    index <- at$index
    allLevels <- as.character(at$allLevels)
    contSums <- rowSums(cont)
    qmLevel <- which(contSums == ncol(cont))
    if (length(qmLevel) == 0) {
        attr(dataset, "contrast") <- rbind(attr(dataset, "contrast"), 
            1)
        attr(dataset, "allLevels") <- c(attr(dataset, "allLevels"), 
            "{?}")
        qmLevel <- length(allLevels) + 1L
    }
    ambigs <- which(contSums > 1L & contSums < ncol(cont))
    inappLevel <- which(colnames(cont) == "-")
    if (length(inappLevel) != 0L) {
        cli_alert("Inapplicable tokens treated as ambiguous for profile parsimony")
        inappLevel <- which(apply(unname(cont), 1, identical, 
            as.double(colnames(cont) == "-")))
        dataset[] <- lapply(dataset, function(i) {
            i[i %fin% inappLevel] <- qmLevel
            i
        })
    }
    if (length(ambigs) != 0L) {
        dataset[] <- lapply(dataset, function(i) {
            i[i %fin% ambigs] <- qmLevel
            i
        })
    }
    mataset <- matrix(unlist(dataset, recursive = FALSE, use.names = FALSE), 
        max(index))
    .RemoveExtraTokens <- function(char, ambiguousTokens) {
        unambig <- char[!char %fin% ambiguousTokens]
        if (length(unambig) == 0) {
            return(matrix(nrow = length(char), ncol = 0))
        }
        split <- table(unambig)
        ranking <- order(order(split, decreasing = TRUE))
        ignored <- ranking > 2L
        if (any(split[ignored] > 1L)) {
            warningMsg <- "Can handle max. 2 informative tokens. Dropping others."
            if (interactive()) {
                cli_alert_warning(warningMsg)
            }
            else {
                warning(warningMsg)
            }
        }
        if (length(ambiguousTokens) == 0) {
            stop("No ambiguous token available for replacement")
        }
        tokens <- names(split)
        most <- tokens[which.min(ranking)]
        vapply(setdiff(names(split)[split > 1], most), function(kept) {
            simplified <- char
            simplified[!simplified %fin% c(most, kept)] <- ambiguousTokens[1]
            simplified
        }, char)
    }
    decomposed <- lapply(seq_along(mataset[, 1]), function(i) .RemoveExtraTokens(mataset[i, 
        ], ambiguousTokens = qmLevel))
    nChar <- vapply(decomposed, dim, c(0, 0))[2, ]
    if (sum(nChar) == 0) {
        cli_alert("No informative characters in `dataset`.")
        attr(dataset, "info.amounts") <- double(0)
        return(dataset[0])
    }
    newIndex <- seq_len(sum(nChar))
    oldIndex <- rep.int(seq_along(nChar), nChar)
    index <- unlist(lapply(index, function(i) {
        newIndex[oldIndex == i]
    }))
    mataset <- unname(do.call(cbind, decomposed))
    NON_AMBIG <- 1:2
    AMBIG <- max(NON_AMBIG) + 1L
    .Recompress <- function(char, ambiguousTokens) {
        tokens <- unique(char)
        nonAmbig <- setdiff(tokens, ambiguousTokens)
        stopifnot(length(nonAmbig) == 2L)
        cipher <- seq_len(max(tokens))
        cipher[nonAmbig] <- NON_AMBIG
        cipher[ambiguousTokens] <- AMBIG
        cipher[char]
    }
    if (length(mataset) == 0) {
        cli_alert("No informative characters in `dataset`.")
        attr(dataset, "info.amounts") <- double(0)
        return(dataset[0])
    }
    mataset <- apply(mataset, 2, .Recompress, qmLevel)
    dupCols <- duplicated(t(mataset))
    kept <- which(!dupCols)
    copies <- lapply(kept, function(i) {
        i + which(apply(mataset[, -seq_len(i), drop = FALSE], 
            2, identical, mataset[, i]))
    })
    firstOccurrence <- seq_len(dim(mataset)[2])
    for (i in seq_along(copies)) {
        firstOccurrence[copies[[i]]] <- kept[i]
    }
    cipher <- seq_len(max(kept))
    cipher[kept] <- order(kept)
    index <- cipher[firstOccurrence][index]
    mataset <- mataset[, !dupCols, drop = FALSE]
    dataset[] <- lapply(seq_len(length(dataset)), function(i) mataset[i, 
        ])
    info <- lapply(seq_along(mataset[1, ]), function(i) StepInformation(mataset[, 
        i], ambiguousTokens = AMBIG))
    maxSteps <- max(vapply(info, function(i) max(as.integer(names(i))), 
        integer(1)))
    info <- vapply(info, function(x) {
        ret <- setNames(double(maxSteps), seq_len(maxSteps))
        x <- x[setdiff(names(x), "0")]
        if (length(x)) {
            ret[names(x)] <- max(x) - x
        }
        ret
    }, double(maxSteps))
    if (is.null(dim(info))) {
        dim(info) <- c(1L, length(info))
    }
    attr(dataset, "index") <- index
    weight <- as.integer(table(index))
    attr(dataset, "weight") <- weight
    attr(dataset, "nr") <- length(weight)
    attr(dataset, "info.amounts") <- info
    attr(dataset, "informative") <- colSums(info) > 0
    lvls <- c("0", "1")
    attr(dataset, "levels") <- lvls
    attr(dataset, "allLevels") <- c(lvls, "?")
    attr(dataset, "contrast") <- matrix(c(1, 0, 1, 0, 1, 1), 
        length(lvls) + 1L, length(lvls), dimnames = list(NULL, 
            lvls))
    attr(dataset, "nc") <- length(lvls)
    if (!any(attr(dataset, "bootstrap") == "info.amounts")) {
        attr(dataset, "bootstrap") <- c(attr(dataset, "bootstrap"), 
            "info.amounts")
    }
    dataset
}
Function PrepareDataProfile in namespace TreeSearch has this body.

Quitting from lines 86-88 [starting-score] (profile.Rmd)
Error: processing vignette 'profile.Rmd' failed with diagnostics:
promise already under evaluation: recursive default argument reference or earlier problems?
--- failed re-building ‘profile.Rmd’

--- re-building ‘tree-search.Rmd’ using rmarkdown
--- finished re-building ‘tree-search.Rmd’

--- re-building ‘tree-space.Rmd’ using rmarkdown
--- finished re-building ‘tree-space.Rmd’

SUMMARY: processing the following file failed:
  ‘profile.Rmd’

Error: Vignette re-building failed.
Execution halted

* checking PDF version of manual ... OK
* DONE
Status: 2 ERRORs, 1 NOTE
