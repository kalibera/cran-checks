
R Under development (unstable) (2019-10-15 r77294) -- "Unsuffered Consequences"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "rstpm2"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('rstpm2')
Loading required package: survival
Loading required package: splines

Attaching package: ‘rstpm2’

The following object is masked from ‘package:survival’:

    colon

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("Rstpm2-package")
> ### * Rstpm2-package
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Rstpm2-package
> ### Title: Flexible parametric survival models.
> ### Aliases: Rstpm2-package Rstpm2
> ### Keywords: package
> 
> ### ** Examples
> 
> data(brcancer)
> summary(fit <- stpm2(Surv(rectime,censrec==1)~hormon,data=brcancer,df=3))
Maximum likelihood estimation

Call:
stpm2(formula = Surv(rectime, censrec == 1) ~ hormon, data = brcancer, 
    df = 3)

Coefficients:
                           Estimate Std. Error  z value     Pr(z)    
(Intercept)                -7.25667    0.67302 -10.7823 < 2.2e-16 ***
hormon                     -0.36140    0.12488  -2.8940  0.003804 ** 
nsx(log(rectime), df = 3)1  4.76097    0.41835  11.3803 < 2.2e-16 ***
nsx(log(rectime), df = 3)2 11.57128    1.30799   8.8466 < 2.2e-16 ***
nsx(log(rectime), df = 3)3  4.56779    0.30890  14.7872 < 2.2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

-2 log L: 5215.915 
> summary(fit.tvc <- stpm2(Surv(rectime,censrec==1)~hormon,data=brcancer,df=3,
+                      tvc=list(hormon=3)))
Maximum likelihood estimation

Call:
stpm2(formula = Surv(rectime, censrec == 1) ~ hormon, data = brcancer, 
    df = 3, tvc = list(hormon = 3))

Coefficients:
                                  Estimate Std. Error z value     Pr(z)    
(Intercept)                       -7.03611    0.75319 -9.3418 < 2.2e-16 ***
hormon                            -1.30948    1.65721 -0.7902    0.4294    
nsx(log(rectime), df = 3)1         4.61696    0.46884  9.8477 < 2.2e-16 ***
nsx(log(rectime), df = 3)2        11.16940    1.46730  7.6122 2.695e-14 ***
nsx(log(rectime), df = 3)3         4.43798    0.34946 12.6994 < 2.2e-16 ***
hormon:nsx(log(rectime), df = 3)1  0.61775    1.03132  0.5990    0.5492    
hormon:nsx(log(rectime), df = 3)2  1.73421    3.22004  0.5386    0.5902    
hormon:nsx(log(rectime), df = 3)3  0.51814    0.75190  0.6891    0.4908    
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

-2 log L: 5215.322 
> anova(fit,fit.tvc)
Likelihood Ratio Tests
Model 1: fit, [negll]: (Intercept)+hormon+nsx(log(rectime), df = 3)1+
          nsx(log(rectime), df = 3)2+nsx(log(rectime), df = 3)3
Model 2: fit.tvc, [negll]: (Intercept)+hormon+nsx(log(rectime), df = 3)1+
          nsx(log(rectime), df = 3)2+nsx(log(rectime), df = 3)3+
          hormon:nsx(log(rectime), df = 3)1+hormon:nsx(log(rectime), df = 3)2+
          hormon:nsx(log(rectime), df = 3)3
  Tot Df Deviance Chisq Df Pr(>Chisq)
1      5   5215.9                    
2      8   5215.3 0.593  3      0.898
> plot(fit.tvc,newdata=data.frame(hormon=0),type="hr",var="hormon")
> 
> 
> 
> cleanEx()
> nameEx("aft-class")
> ### * aft-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aft-class
> ### Title: Class "stpm2" ~~~
> ### Aliases: aft-class plot,aft,missing-method predict,aft-method
> ###   predictnl,aft-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> showClass("aft")
Class "aft" [package "rstpm2"]

Slots:
                                                                            
Name:       args      call call.orig      coef  fullcoef      vcov       min
Class:      list  language  language   numeric   numeric    matrix   numeric
                                                                  
Name:    details minuslogl    method      data   formula optimizer
Class:      list  function character      list character character

Extends: "mle2"
> 
> 
> 
> cleanEx()
> nameEx("aft")
> ### * aft
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aft
> ### Title: Parametric accelerated failure time model with smooth time
> ###   functions
> ### Aliases: aft
> ### Keywords: survival smooth
> 
> ### ** Examples
> 
> summary(aft(Surv(rectime,censrec==1)~hormon,data=brcancer,df=4))
Maximum likelihood estimation

Call:
bbmle::mle2(minuslogl = negll, start = coef, eval.only = TRUE, 
    vecpar = TRUE, gr = gradient, control = control)

Coefficients:
                                      Estimate Std. Error  z value     Pr(z)
hormon                                0.285475   0.094189   3.0309  0.002438
nsx(logtstar, df, intercept = TRUE)1 -0.272990   0.235853  -1.1575  0.247085
nsx(logtstar, df, intercept = TRUE)2  2.045562   0.214611   9.5315 < 2.2e-16
nsx(logtstar, df, intercept = TRUE)3 -7.387207   0.586910 -12.5866 < 2.2e-16
nsx(logtstar, df, intercept = TRUE)4  4.361119   0.346429  12.5888 < 2.2e-16
                                        
hormon                               ** 
nsx(logtstar, df, intercept = TRUE)1    
nsx(logtstar, df, intercept = TRUE)2 ***
nsx(logtstar, df, intercept = TRUE)3 ***
nsx(logtstar, df, intercept = TRUE)4 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

-2 log L: 5215.435 
> 
> 
> 
> cleanEx()
> nameEx("brcancer")
> ### * brcancer
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: brcancer
> ### Title: German breast cancer data from Stata.
> ### Aliases: brcancer
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(brcancer)
> ## maybe str(brcancer) ; plot(brcancer) ...
> 
> 
> 
> cleanEx()
> nameEx("coef")
> ### * coef
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coef<-
> ### Title: Generic method to update the coef in an object.
> ### Aliases: coef<-
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (x, value) 
+ UseMethod("coef<-")
function (x, value) 
UseMethod("coef<-")
> 
> 
> 
> cleanEx()
> nameEx("colon")
> ### * colon
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: colon
> ### Title: Colon cancer.
> ### Aliases: colon
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(colon,package="rstpm2") # avoids name conflict with survival::colon
> ## maybe str(colon) ; ...
> 
> 
> 
> cleanEx()
> nameEx("cox.tvc")
> ### * cox.tvc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cox.tvc
> ### Title: Test for a time-varying effect in the 'coxph' model
> ### Aliases: cox.tvc
> ### Keywords: time-varying Cox
> 
> ### ** Examples
> 
> ## As per the example for cox.zph:
> fit <- coxph(Surv(futime, fustat) ~ age + ecog.ps,  
+              data=ovarian) 
> temp <- rstpm2:::cox.tvc(fit, "age") 
> print(temp)                  # display the results 
Maximum likelihood estimation

Call:
mle2(minuslogl = minuslogl, start = beta, method = "BFGS", gr = gr)

Coefficients:
            Estimate Std. Error z value  Pr(z)
age         0.673108   0.492006  1.3681 0.1713
ecog.ps     0.057562   0.605399  0.0951 0.9243
age:log(t) -0.091582   0.085225 -1.0746 0.2826

-2 log L: 54.31134 
> plot(temp)                   # plot curves 
> 
> 
> 
> cleanEx()
> nameEx("gsm")
> ### * gsm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gsm
> ### Title: Parametric and penalised generalised survival models
> ### Aliases: gsm pstpm2 stpm2
> ### Keywords: survival
> 
> ### ** Examples
> 
> ## Not run: 
> ##D     data(brcancer)
> ##D     summary(fit <- stpm2(Surv(rectime,censrec==1)~hormon,data=brcancer,df=3))
> ##D     
> ##D     ## some predictions
> ##D     head(predict(fit,se.fit=TRUE,type="surv"))
> ##D     head(predict(fit,se.fit=TRUE,type="hazard"))
> ##D     
> ##D     ## some plots
> ##D     plot(fit,newdata=data.frame(hormon=0),type="hazard")
> ##D     plot(fit,newdata=data.frame(hormon=0),type="surv")
> ##D     
> ##D     ## the same model using logH.formula
> ##D     summary(stpm2(Surv(rectime,censrec==1)~hormon,
> ##D                   data=brcancer,logH.formula=~ns(log(rectime),df=3)))
> ##D     
> ##D     
> ##D     ## time-varying coefficient
> ##D     summary(fit.tvc <- stpm2(Surv(rectime,censrec==1)~hormon,data=brcancer,df=3,
> ##D                              tvc=list(hormon=3)))
> ##D     anova(fit,fit.tvc) # compare with and without tvc
> ##D     
> ##D     ## some more plots
> ##D     plot(fit.tvc,newdata=data.frame(hormon=0),type="hr",var="hormon", ylim=c(0,2))
> ##D                                         # no lines method: use add=TRUE
> ##D     plot(fit.tvc,newdata=data.frame(hormon=1),type="hr",var="hormon",
> ##D      add=TRUE,ci=FALSE,line.col=2)
> ##D 
> ##D     plot(fit.tvc,newdata=data.frame(hormon=0),type="sdiff",var="hormon")
> ##D     
> ##D     plot(fit.tvc,newdata=data.frame(hormon=0),type="hdiff",var="hormon")
> ##D     
> ##D     plot(fit.tvc,newdata=data.frame(hormon=0),type="hazard")
> ##D     plot(fit.tvc,newdata=data.frame(hormon=1),type="hazard",line.col=2,ci=FALSE,add=TRUE)
> ##D     
> ##D     ## compare number of knots
> ##D     hormon0 <- data.frame(hormon=0)
> ##D     plot(fit,type="hazard",newdata=hormon0)
> ##D     AIC(fit)
> ##D     for (df in 4:6) {
> ##D         fit.new <- stpm2(Surv(rectime,censrec==1)~hormon,data=brcancer,df=df)
> ##D         plot(fit.new,type="hazard",newdata=hormon0,add=TRUE,ci=FALSE,line.col=df)
> ##D         print(AIC(fit.new))
> ##D     }
> ##D     
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("incrVar")
> ### * incrVar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: incrVar
> ### Title: Utility that returns a function to increment a variable in a
> ###   data-frame.
> ### Aliases: incrVar
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (var, increment = 1) 
+ {
+     n <- length(var)
+     if (n > 1 && length(increment)==1) 
+         increment <- rep(increment, n)
+     function(data) {
+         for (i in 1:n) {
+             data[[var[i]]] <- data[[var[i]]] + increment[i]
+         }
+         data
+     }
+   }
function (var, increment = 1) 
{
    n <- length(var)
    if (n > 1 && length(increment) == 1) 
        increment <- rep(increment, n)
    function(data) {
        for (i in 1:n) {
            data[[var[i]]] <- data[[var[i]]] + increment[i]
        }
        data
    }
}
> 
> 
> 
> cleanEx()
> nameEx("legendre.quadrature.rule.200")
> ### * legendre.quadrature.rule.200
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: legendre.quadrature.rule.200
> ### Title: Legendre quadrature rule for n=200.
> ### Aliases: legendre.quadrature.rule.200
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(legendre.quadrature.rule.200)
> ## maybe str(legendre.quadrature.rule.200) ; ...
> 
> 
> 
> cleanEx()
> nameEx("markov_msm")
> ### * markov_msm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: markov_msm
> ### Title: Predictions for continuous time, nonhomogeneous Markov
> ###   multi-state models using parametric and penalised survival models.
> ### Aliases: markov_msm vcov.markov_msm as.data.frame.markov_msm
> ###   as.data.frame.markov_msm_diff as.data.frame.markov_msm_ratio
> ###   standardise standardise.markov_msm plot.markov_msm subset.markov_msm
> ###   diff diff.markov_msm ratio_markov_msm rbind.markov_msm
> ###   transform.markov_msm collapse_markov_msm zeroModel hrModel aftModel
> ###   addModel hazFun splineFun
> ### Keywords: survival
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## Crowther and Lambert (2019)
> ##D library(readstata13)
> ##D library(mstate)
> ##D library(ggplot2)
> ##D mex.1 <- read.dta13("http://fmwww.bc.edu/repec/bocode/m/multistate_example.dta")
> ##D transmat <- rbind("Post-surgery"=c(NA,1,2), 
> ##D                   "Relapsed"=c(NA,NA,3),
> ##D                   "Died"=c(NA,NA,NA))
> ##D colnames(transmat) <- rownames(transmat)
> ##D mex.2 <- transform(mex.1,osi=(osi=="deceased")+0)
> ##D levels(mex.2$size)[2] <- ">20-50 mm" # fix typo
> ##D mex <- mstate::msprep(time=c(NA,"rf","os"),status=c(NA,"rfi","osi"),
> ##D                       data=mex.2,trans=transmat,id="pid",
> ##D                       keep=c("age","size","nodes","pr_1","hormon"))
> ##D mex <- transform(mex,
> ##D                  size2=(unclass(size)==2)+0, # avoids issues with TRUE/FALSE
> ##D                  size3=(unclass(size)==3)+0,
> ##D                  hormon=(hormon=="yes")+0,
> ##D                  Tstart=Tstart/12,
> ##D                  Tstop=Tstop/12)
> ##D ##
> ##D c.ar <- stpm2(Surv(Tstart,Tstop,status) ~ age + size2 + size3 + nodes + pr_1 + hormon,
> ##D               data = mex, subset=trans==1, df=3, tvc=list(size2=1,size3=1,pr_1=1))
> ##D c.ad <- stpm2(Surv(Tstart, Tstop, status) ~ age + size + nodes + pr_1 + hormon,
> ##D               data = mex, subset=trans==2, df=1)
> ##D c.rd <- stpm2( Surv(Tstart,Tstop,status) ~ age + size + nodes + pr_1 + hormon,
> ##D               data=mex, subset=trans==3, df=3, tvc=list(pr_1=1))
> ##D ##
> ##D nd <- expand.grid(nodes=seq(0,20,10), size=levels(mex$size))
> ##D nd <- transform(nd, age=54, pr_1=3, hormon=0,
> ##D                 size2=(unclass(size)==2)+0,
> ##D                 size3=(unclass(size)==3)+0)
> ##D ## Predictions
> ##D system.time(pred1 <- rstpm2::markov_msm(list(c.ar,c.ad,c.rd), t = seq(0,15,length=301),
> ##D                                         newdata=nd, trans = transmat)) # ~15 seconds
> ##D pred1 <- transform(pred1, Nodes=paste("Nodes =",nodes), Size=paste("Size",size))
> ##D ## Figure 3
> ##D plot(pred1, ggplot=TRUE) + facet_grid(Nodes ~ Size) + xlab("Years since surgery")
> ##D plot(pred1, strata=~nodes+size, xlab="Years since surgery", lattice=TRUE)
> ##D ## Figure 4
> ##D plot(subset(pred1, nodes==0 & size=="<=20 mm"), stacked=FALSE, ggplot=TRUE) +
> ##D     facet_grid(. ~ state) +
> ##D     xlab("Years since surgery")
> ##D ## Figure 5
> ##D a <- diff(subset(pred1,nodes==0 & size=="<=20 mm"),
> ##D           subset(pred1,nodes==0 & size==">20-50 mm"))
> ##D a <- transform(a, label = "Prob(Size<=20 mm)-Prob(20mm<Size<50mm)")
> ##D b <- ratio_markov_msm(subset(pred1,nodes==0 & size=="<=20 mm"),
> ##D                       subset(pred1,nodes==0 & size==">20-50 mm"))
> ##D b <- transform(b,label="Prob(Size<=20 mm)-Prob(20mm<Size<50mm)")
> ##D ##
> ##D c <- diff(subset(pred1,nodes==0 & size=="<=20 mm"),
> ##D           subset(pred1,nodes==0 & size==">50 mm"))
> ##D c <- transform(c, label = "Prob(Size<=20 mm)-Prob(Size>=50mm)")
> ##D d <- ratio_markov_msm(subset(pred1,nodes==0 & size=="<=20 mm"),
> ##D                       subset(pred1,nodes==0 & size==">50 mm"))
> ##D d <- transform(d,label= "Prob(Size<=20 mm)-Prob(Size>=50mm)")
> ##D ##
> ##D e <- diff(subset(pred1,nodes==0 & size==">20-50 mm"),
> ##D           subset(pred1,nodes==0 & size==">50 mm"))
> ##D e <- transform(e,label="Prob(20mm<Size<50 mm)-Prob(Size>=50mm)")
> ##D f <- ratio_markov_msm(subset(pred1,nodes==0 & size==">20-50 mm"),
> ##D                       subset(pred1,nodes==0 & size==">50 mm"))
> ##D f <- transform(f, label = "Prob(20mm<Size<50 mm)-Prob(Size>=50mm)")
> ##D ## combine
> ##D diffs <- rbind(a,c,e)
> ##D ratios <- rbind(b,d,f)
> ##D ## Figure 5
> ##D plot(diffs, stacked=FALSE, ggplot2=TRUE) + xlab("Years since surgery") +
> ##D     ylim(c(-0.4, 0.4)) + facet_grid(label ~ state)
> ##D ##
> ##D plot(ratios, stacked=FALSE, ggplot2=TRUE) + xlab("Years since surgery") +
> ##D     ylim(c(0, 3)) + facet_grid(label ~ state)
> ##D ## Figure 6
> ##D plot(subset(pred1, nodes==0 & size=="<=20 mm"), stacked=FALSE, which="L", ggplot2=TRUE) +
> ##D     facet_grid(. ~ state) + xlab("Years since surgery")
> ##D ## Figure 7
> ##D plot(diffs, stacked=FALSE, which="L", ggplot2=TRUE) + xlab("Years since surgery") +
> ##D     ylim(c(-4, 4)) + facet_grid(label ~ state)
> ##D plot(ratios, stacked=FALSE, which="L", ggplot2=TRUE) + xlab("Years since surgery") +
> ##D     ylim(c(0.1, 10)) + coord_trans(y="log10") + facet_grid(label ~ state)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("nsx")
> ### * nsx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nsx
> ### Title: Generate a Basis Matrix for Natural Cubic Splines (with
> ###   eXtensions)
> ### Aliases: nsx
> ### Keywords: smooth
> 
> ### ** Examples
> 
> require(stats); require(graphics); require(splines)
> nsx(women$height, df = 5)
                 1            2           3          4             5
 [1,] 0.000000e+00 0.000000e+00  0.00000000 0.00000000  0.0000000000
 [2,] 7.592323e-03 0.000000e+00 -0.08670223 0.26010669 -0.1734044626
 [3,] 6.073858e-02 0.000000e+00 -0.15030440 0.45091320 -0.3006088020
 [4,] 2.047498e-01 6.073858e-05 -0.16778345 0.50335034 -0.3355668952
 [5,] 4.334305e-01 1.311953e-02 -0.13244035 0.39732106 -0.2648807067
 [6,] 6.256681e-01 8.084305e-02 -0.07399720 0.22199159 -0.1479943948
 [7,] 6.477162e-01 2.468416e-01 -0.02616007 0.07993794 -0.0532919575
 [8,] 4.791667e-01 4.791667e-01  0.01406302 0.02031093 -0.0135406187
 [9,] 2.468416e-01 6.477162e-01  0.09733619 0.02286023 -0.0152401533
[10,] 8.084305e-02 6.256681e-01  0.27076826 0.06324188 -0.0405213106
[11,] 1.311953e-02 4.334305e-01  0.48059836 0.12526031 -0.0524087186
[12,] 6.073858e-05 2.047498e-01  0.59541597 0.19899261  0.0007809246
[13,] 0.000000e+00 6.073858e-02  0.50097182 0.27551020  0.1627793975
[14,] 0.000000e+00 7.592323e-03  0.22461127 0.35204082  0.4157555879
[15,] 0.000000e+00 0.000000e+00 -0.14285714 0.42857143  0.7142857143
attr(,"degree")
[1] 3
attr(,"knots")
 20%  40%  60%  80% 
60.8 63.6 66.4 69.2 
attr(,"Boundary.knots")
[1] 58 72
attr(,"intercept")
[1] FALSE
attr(,"derivs")
[1] 2 2
attr(,"centre")
[1] FALSE
attr(,"log")
[1] FALSE
attr(,"q.const")
     [,1] [,2]        [,3]      [,4]       [,5]
[1,]    0    0 -0.08451543 0.2535463 -0.1690309
[2,]    0    0 -0.25354628 0.7606388 -0.5070926
[3,]    1    0  0.00000000 0.0000000  0.0000000
[4,]    0    1  0.00000000 0.0000000  0.0000000
[5,]    0    0  0.92857143 0.2142857 -0.1428571
[6,]    0    0  0.21428571 0.3571429  0.4285714
[7,]    0    0 -0.14285714 0.4285714  0.7142857
attr(,"class")
[1] "nsx"    "basis"  "matrix"
> summary(fm1 <- lm(weight ~ ns(height, df = 5), data = women))

Call:
lm(formula = weight ~ ns(height, df = 5), data = women)

Residuals:
     Min       1Q   Median       3Q      Max 
-0.38333 -0.12585  0.07083  0.15401  0.30426 

Coefficients:
                    Estimate Std. Error t value Pr(>|t|)    
(Intercept)         114.7447     0.2338  490.88  < 2e-16 ***
ns(height, df = 5)1  15.9474     0.3699   43.12 9.69e-12 ***
ns(height, df = 5)2  25.1695     0.4323   58.23 6.55e-13 ***
ns(height, df = 5)3  33.2582     0.3541   93.93 8.91e-15 ***
ns(height, df = 5)4  50.7894     0.6062   83.78 2.49e-14 ***
ns(height, df = 5)5  45.0363     0.2784  161.75  < 2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 0.2645 on 9 degrees of freedom
Multiple R-squared:  0.9998,	Adjusted R-squared:  0.9997 
F-statistic:  9609 on 5 and 9 DF,  p-value: < 2.2e-16

> 
> ## example of safe prediction
> plot(women, xlab = "Height (in)", ylab = "Weight (lb)")
> ht <- seq(57, 73, length.out = 200)
> lines(ht, predict(fm1, data.frame(height=ht)))
> 
> 
> 
> 
> cleanEx()
> nameEx("nsxD")
> ### * nsxD
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nsxD
> ### Title: Generate a Basis Matrix for the first derivative of Natural
> ###   Cubic Splines (with eXtensions)
> ### Aliases: nsxD
> ### Keywords: smooth
> 
> ### ** Examples
> 
> require(stats); require(graphics); require(splines)
> nsx(women$height, df = 5)
                 1            2           3          4             5
 [1,] 0.000000e+00 0.000000e+00  0.00000000 0.00000000  0.0000000000
 [2,] 7.592323e-03 0.000000e+00 -0.08670223 0.26010669 -0.1734044626
 [3,] 6.073858e-02 0.000000e+00 -0.15030440 0.45091320 -0.3006088020
 [4,] 2.047498e-01 6.073858e-05 -0.16778345 0.50335034 -0.3355668952
 [5,] 4.334305e-01 1.311953e-02 -0.13244035 0.39732106 -0.2648807067
 [6,] 6.256681e-01 8.084305e-02 -0.07399720 0.22199159 -0.1479943948
 [7,] 6.477162e-01 2.468416e-01 -0.02616007 0.07993794 -0.0532919575
 [8,] 4.791667e-01 4.791667e-01  0.01406302 0.02031093 -0.0135406187
 [9,] 2.468416e-01 6.477162e-01  0.09733619 0.02286023 -0.0152401533
[10,] 8.084305e-02 6.256681e-01  0.27076826 0.06324188 -0.0405213106
[11,] 1.311953e-02 4.334305e-01  0.48059836 0.12526031 -0.0524087186
[12,] 6.073858e-05 2.047498e-01  0.59541597 0.19899261  0.0007809246
[13,] 0.000000e+00 6.073858e-02  0.50097182 0.27551020  0.1627793975
[14,] 0.000000e+00 7.592323e-03  0.22461127 0.35204082  0.4157555879
[15,] 0.000000e+00 0.000000e+00 -0.14285714 0.42857143  0.7142857143
attr(,"degree")
[1] 3
attr(,"knots")
 20%  40%  60%  80% 
60.8 63.6 66.4 69.2 
attr(,"Boundary.knots")
[1] 58 72
attr(,"intercept")
[1] FALSE
attr(,"derivs")
[1] 2 2
attr(,"centre")
[1] FALSE
attr(,"log")
[1] FALSE
attr(,"q.const")
     [,1] [,2]        [,3]      [,4]       [,5]
[1,]    0    0 -0.08451543 0.2535463 -0.1690309
[2,]    0    0 -0.25354628 0.7606388 -0.5070926
[3,]    1    0  0.00000000 0.0000000  0.0000000
[4,]    0    1  0.00000000 0.0000000  0.0000000
[5,]    0    0  0.92857143 0.2142857 -0.1428571
[6,]    0    0  0.21428571 0.3571429  0.4285714
[7,]    0    0 -0.14285714 0.4285714  0.7142857
attr(,"class")
[1] "nsx"    "basis"  "matrix"
> summary(fm1 <- lm(weight ~ ns(height, df = 5), data = women))

Call:
lm(formula = weight ~ ns(height, df = 5), data = women)

Residuals:
     Min       1Q   Median       3Q      Max 
-0.38333 -0.12585  0.07083  0.15401  0.30426 

Coefficients:
                    Estimate Std. Error t value Pr(>|t|)    
(Intercept)         114.7447     0.2338  490.88  < 2e-16 ***
ns(height, df = 5)1  15.9474     0.3699   43.12 9.69e-12 ***
ns(height, df = 5)2  25.1695     0.4323   58.23 6.55e-13 ***
ns(height, df = 5)3  33.2582     0.3541   93.93 8.91e-15 ***
ns(height, df = 5)4  50.7894     0.6062   83.78 2.49e-14 ***
ns(height, df = 5)5  45.0363     0.2784  161.75  < 2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 0.2645 on 9 degrees of freedom
Multiple R-squared:  0.9998,	Adjusted R-squared:  0.9997 
F-statistic:  9609 on 5 and 9 DF,  p-value: < 2.2e-16

> 
> ## example of safe prediction
> plot(women, xlab = "Height (in)", ylab = "Weight (lb)")
> ht <- seq(57, 73, length.out = 200)
> lines(ht, predict(fm1, data.frame(height=ht)))
> 
> 
> 
> 
> cleanEx()
> nameEx("numDeltaMethod")
> ### * numDeltaMethod
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: numDeltaMethod
> ### Title: Calculate numerical delta method for non-linear predictions.
> ### Aliases: numDeltaMethod
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (object, fun, ...) 
+ {
+     coef <- coef(object)
+     est <- fun(coef, ...)
+     Sigma <- vcov(object)
+     gd <- grad(fun, coef, ...)
+     se.est <- as.vector(sqrt(colSums(gd * (Sigma %*% gd))))
+     data.frame(Estimate = est, SE = se.est)
+   }
function (object, fun, ...) 
{
    coef <- coef(object)
    est <- fun(coef, ...)
    Sigma <- vcov(object)
    gd <- grad(fun, coef, ...)
    se.est <- as.vector(sqrt(colSums(gd * (Sigma %*% gd))))
    data.frame(Estimate = est, SE = se.est)
}
> 
> 
> 
> cleanEx()
> nameEx("popmort")
> ### * popmort
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: popmort
> ### Title: Background mortality rates for the colon dataset.
> ### Aliases: popmort
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(popmort)
> ## maybe str(popmort) ; ...
> 
> 
> 
> cleanEx()
> nameEx("predict.nsx")
> ### * predict.nsx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predict.nsx
> ### Title: Evaluate a Spline Basis
> ### Aliases: predict.nsx
> ### Keywords: smooth
> 
> ### ** Examples
> 
> basis <- nsx(women$height, df = 5)
> newX <- seq(58, 72, length.out = 51)
> # evaluate the basis at the new data
> predict(basis, newX)
                 1            2            3          4            5
 [1,] 0.0000000000 0.0000000000  0.000000000 0.00000000  0.000000000
 [2,] 0.0001666667 0.0000000000 -0.025270112 0.07581034 -0.050540224
 [3,] 0.0013333333 0.0000000000 -0.050033132 0.15009940 -0.100066264
 [4,] 0.0045000000 0.0000000000 -0.073781966 0.22134590 -0.147563933
 [5,] 0.0106666667 0.0000000000 -0.096009523 0.28802857 -0.192019047
 [6,] 0.0208333333 0.0000000000 -0.116208710 0.34862613 -0.232417420
 [7,] 0.0360000000 0.0000000000 -0.133872434 0.40161730 -0.267744868
 [8,] 0.0571666667 0.0000000000 -0.148493603 0.44548081 -0.296987205
 [9,] 0.0853333333 0.0000000000 -0.159565123 0.47869537 -0.319130247
[10,] 0.1215000000 0.0000000000 -0.166579904 0.49973971 -0.333159807
[11,] 0.1666666667 0.0000000000 -0.169030851 0.50709255 -0.338061702
[12,] 0.2211666667 0.0001666667 -0.166622161 0.49986648 -0.333244323
[13,] 0.2826666667 0.0013333333 -0.159903185 0.47970955 -0.319806370
[14,] 0.3481666667 0.0045000000 -0.149634561 0.44890368 -0.299269122
[15,] 0.4146666667 0.0106666667 -0.136576928 0.40973078 -0.273153855
[16,] 0.4791666667 0.0208333333 -0.121490924 0.36447277 -0.242981848
[17,] 0.5386666667 0.0360000000 -0.105137189 0.31541157 -0.210274379
[18,] 0.5901666667 0.0571666667 -0.088276362 0.26482909 -0.176552724
[19,] 0.6306666667 0.0853333333 -0.071669081 0.21500724 -0.143338162
[20,] 0.6571666667 0.1215000000 -0.056075985 0.16822795 -0.112151970
[21,] 0.6666666667 0.1666666667 -0.042257713 0.12677314 -0.084515425
[22,] 0.6571666667 0.2211666667 -0.030651111 0.09245333 -0.061635555
[23,] 0.6306666667 0.2826666667 -0.020397854 0.06519356 -0.043462374
[24,] 0.5901666667 0.3481666667 -0.010315824 0.04444747 -0.029631648
[25,] 0.5386666667 0.4146666667  0.000777096 0.02966871 -0.019779141
[26,] 0.4791666667 0.4791666667  0.014063024 0.02031093 -0.013540619
[27,] 0.4146666667 0.5386666667  0.030724078 0.01582777 -0.010551844
[28,] 0.3481666667 0.5901666667  0.051942375 0.01567287 -0.010448583
[29,] 0.2826666667 0.6306666667  0.078900034 0.01929990 -0.012866600
[30,] 0.2211666667 0.6571666667  0.112779171 0.02616249 -0.017441658
[31,] 0.1666666667 0.6666666667  0.154761905 0.03571429 -0.023809524
[32,] 0.1215000000 0.6571666667  0.205345238 0.04746429 -0.031476190
[33,] 0.0853333333 0.6306666667  0.262285714 0.06114286 -0.039428571
[34,] 0.0571666667 0.5901666667  0.322654762 0.07653571 -0.046523810
[35,] 0.0360000000 0.5386666667  0.383523810 0.09342857 -0.051619048
[36,] 0.0208333333 0.4791666667  0.441964286 0.11160714 -0.053571429
[37,] 0.0106666667 0.4146666667  0.495047619 0.13085714 -0.051238095
[38,] 0.0045000000 0.3481666667  0.539845238 0.15096429 -0.043476190
[39,] 0.0013333333 0.2826666667  0.573428571 0.17171429 -0.029142857
[40,] 0.0001666667 0.2211666667  0.592869048 0.19289286 -0.007095238
[41,] 0.0000000000 0.1666666667  0.595238095 0.21428571  0.023809524
[42,] 0.0000000000 0.1215000000  0.578428571 0.23571429  0.064357143
[43,] 0.0000000000 0.0853333333  0.543619048 0.25714286  0.113904762
[44,] 0.0000000000 0.0571666667  0.492809524 0.27857143  0.171452381
[45,] 0.0000000000 0.0360000000  0.428000000 0.30000000  0.236000000
[46,] 0.0000000000 0.0208333333  0.351190476 0.32142857  0.306547619
[47,] 0.0000000000 0.0106666667  0.264380952 0.34285714  0.382095238
[48,] 0.0000000000 0.0045000000  0.169571429 0.36428571  0.461642857
[49,] 0.0000000000 0.0013333333  0.068761905 0.38571429  0.544190476
[50,] 0.0000000000 0.0001666667 -0.036047619 0.40714286  0.628738095
[51,] 0.0000000000 0.0000000000 -0.142857143 0.42857143  0.714285714
attr(,"degree")
[1] 3
attr(,"knots")
 20%  40%  60%  80% 
60.8 63.6 66.4 69.2 
attr(,"Boundary.knots")
[1] 58 72
attr(,"intercept")
[1] FALSE
attr(,"derivs")
[1] 2 2
attr(,"centre")
[1] FALSE
attr(,"log")
[1] FALSE
attr(,"q.const")
     [,1] [,2]        [,3]      [,4]       [,5]
[1,]    0    0 -0.08451543 0.2535463 -0.1690309
[2,]    0    0 -0.25354628 0.7606388 -0.5070926
[3,]    1    0  0.00000000 0.0000000  0.0000000
[4,]    0    1  0.00000000 0.0000000  0.0000000
[5,]    0    0  0.92857143 0.2142857 -0.1428571
[6,]    0    0  0.21428571 0.3571429  0.4285714
[7,]    0    0 -0.14285714 0.4285714  0.7142857
attr(,"class")
[1] "nsx"    "basis"  "matrix"
> 
> 
> 
> cleanEx()
> nameEx("predictnl")
> ### * predictnl
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predictnl
> ### Title: Estimation of standard errors using the numerical delta method.
> ### Aliases: predictnl predictnl.default predictnl.lm predict.formula
> ###   print.predictnl confint.predictnl
> 
> ### ** Examples
> 
> 
> df <- data.frame(x=0:1, y=c(10, 20))
> fit <- glm(y ~ x, df, family=poisson)
> 
> predictnl(fit,
+           function(obj,newdata)
+           diff(predict(obj,newdata,type="response")))
  fit   se.fit
1  10 5.477226
> 
> 
> 
> 
> cleanEx()
> nameEx("pstpm2-class")
> ### * pstpm2-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pstpm2-class
> ### Title: Class "pstpm2"
> ### Aliases: pstpm2-class plot,pstpm2,missing-method lines,pstpm2-method
> ###   predictnl,pstpm2-method AIC,pstpm2-method AICc,pstpm2-method
> ###   BIC,pstpm2-method anova,pstpm2-method qAICc,pstpm2-method
> ###   summary,pstpm2-method eform,pstpm2-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> showClass("pstpm2")
Class "pstpm2" [package "rstpm2"]

Slots:
                                                                          
Name:           xlevels        contrasts            terms            logli
Class:             list       listOrNULL            terms         function
                                                                          
Name:               gam          timeVar         time0Var         timeExpr
Class:              gam        character        character       nameOrcall
                                                                          
Name:         time0Expr             like      model.frame          delayed
Class: nameOrcallOrNULL         function             list          logical
                                                                          
Name:           frailty                x               xd           termsd
Class:          logical           matrix           matrix            terms
                                                                          
Name:              Call                y               sp           nevent
Class:             call             Surv          numeric          numeric
                                                                          
Name:              link              edf          edf_var               df
Class:             list          numeric          numeric          numeric
                                                                          
Name:              args             call        call.orig             coef
Class:             list         language         language          numeric
                                                                          
Name:          fullcoef             vcov              min          details
Class:          numeric           matrix          numeric             list
                                                                          
Name:         minuslogl           method             data          formula
Class:         function        character             list        character
                       
Name:         optimizer
Class:        character

Extends: "mle2"
> 
> 
> 
> cleanEx()
> nameEx("stpm2-class")
> ### * stpm2-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stpm2-class
> ### Title: Class "stpm2" ~~~
> ### Aliases: stpm2-class plot,stpm2,missing-method lines,stpm2-method
> ###   predictnl,stpm2-method summary,stpm2-method eform,stpm2-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> showClass("stpm2")
Class "stpm2" [package "rstpm2"]

Slots:
                                                                          
Name:           xlevels        contrasts            terms            logli
Class:             list       listOrNULL            terms         function
                                                                          
Name:                lm          timeVar         time0Var         timeExpr
Class:               lm        character        character       nameOrcall
                                                                          
Name:         time0Expr          delayed         interval          frailty
Class: nameOrcallOrNULL          logical          logical          logical
                                                                          
Name:       model.frame     call.formula                x               xd
Class:             list          formula           matrix           matrix
                                                                          
Name:            termsd             Call                y             link
Class:            terms             call             Surv             list
                                                                          
Name:              args             call        call.orig             coef
Class:             list         language         language          numeric
                                                                          
Name:          fullcoef             vcov              min          details
Class:          numeric           matrix          numeric             list
                                                                          
Name:         minuslogl           method             data          formula
Class:         function        character             list        character
                       
Name:         optimizer
Class:        character

Extends: "mle2"
> 
> 
> 
> cleanEx()
> nameEx("tvcCoxph-class")
> ### * tvcCoxph-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tvcCoxph-class
> ### Title: Class '"tvcCoxph"'
> ### Aliases: tvcCoxph-class plot,tvcCoxph,missing-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> showClass("tvcCoxph")
Class "tvcCoxph" [package "rstpm2"]

Slots:
                                                                            
Name:       call call.orig      coef  fullcoef      vcov       min   details
Class:  language  language   numeric   numeric    matrix   numeric      list
                                                        
Name:  minuslogl    method      data   formula optimizer
Class:  function character      list character character

Extends: "mle2"
> 
> 
> 
> cleanEx()
> nameEx("vuniroot")
> ### * vuniroot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vuniroot
> ### Title: Vectorised One Dimensional Root (Zero) Finding
> ### Aliases: vuniroot
> ### Keywords: optimize
> 
> ### ** Examples
> 
> ##--- vuniroot() with new interval extension + checking features: --------------
> 
> f1 <- function(x) (121 - x^2)/(x^2+1)
> f2 <- function(x) exp(-x)*(x - 12)
> 
> tools::assertCondition(vuniroot(f1, cbind(0,10)),
+                        "error", verbose=TRUE)
assertCondition: caught “error”
> tools::assertCondition(vuniroot(f2, cbind(0, 2)),
+                        "error", verbose=TRUE)
assertCondition: caught “error”
> ##--> error: f() .. end points not of opposite sign
> 
> ## where as  'extendInt="yes"'  simply first enlarges the search interval:
> u1 <- vuniroot(f1, cbind(0,10),extendInt="yes", trace=1)
search in [0,10] ... extended to [-1.5e-05, 11.5] in 4 steps
> u2 <- vuniroot(f2, cbind(0,2), extendInt="yes", trace=2)
search in [0,2]
 .. modified lower,upper: (         -1e-06,           2.02)
 .. modified lower,upper: (         -3e-06,           2.06)
 .. modified lower,upper: (         -7e-06,           2.14)
 .. modified lower,upper: (       -1.5e-05,            2.3)
 .. modified lower,upper: (       -3.1e-05,           2.62)
 .. modified lower,upper: (       -6.3e-05,           3.26)
 .. modified lower,upper: (      -0.000127,           4.54)
 .. modified lower,upper: (      -0.000255,            7.1)
 .. modified lower,upper: (      -0.000511,          12.22)
> stopifnot(all.equal(u1$root, 11, tolerance = 1e-5),
+           all.equal(u2$root, 12, tolerance = 6e-6))
> 
> ## The *danger* of interval extension:
> ## No way to find a zero of a positive function, but
> ## numerically, f(-|M|) becomes zero :
> tools::assertCondition(u3 <- vuniroot(exp, cbind(0,2), extendInt="yes", trace=TRUE),
+                        "error", verbose=TRUE)
search in [0,2] ... extended to [-1073.74, 2.14748e+07] in 30 steps
assertCondition: caught “error”
> 
> ## Nonsense example (must give an error):
> tools::assertCondition( vuniroot(function(x) 1, cbind(0,1), extendInt="yes"),
+                        "error", verbose=TRUE)
assertCondition: caught “error”
> 
> ## Convergence checking :
> sinc <- function(x) ifelse(x == 0, 1, sin(x)/x)
> curve(sinc, -6,18); abline(h=0,v=0, lty=3, col=adjustcolor("gray", 0.8))
> ## Don't show: 
> tools::assertWarning(
+ ## End(Don't show)
+ vuniroot(sinc, cbind(0,5), extendInt="yes", maxiter=4) #-> "just" a warning
+ ## Don't show: 
+  , verbose=TRUE)
ERROR: modification of compiler constant of type language, length 4
ERROR: the modified constant is function body:
ifelse(x == 0, -0.0986659612490242, sin(x)/x)
ERROR: the body was originally:
ifelse(x == 0, 1, sin(x)/x)
ERROR: modification of compiler constant of type double, length 1
ERROR: the modified value of the constant is:
[1] -0.09866596
ERROR: the original value of the constant is:
[1] 1
ERROR: the modified constant is at index 3
ERROR: the modified constant is in this function body:
ifelse(x == 0, -0.0986659612490242, sin(x)/x)
ERROR: detected compiler constant(s) modification after .Call invocation of function vunirootRcpp from library rstpm2 (/var/scratch2/tomas/cran/rcnst/lib/rstpm2/libs/rstpm2.so).
NOTE: .Call function vunirootRcpp modified its argument (number 4, type double, length 1)
Fatal error: compiler constants were modified (in .Call?)!

ERROR: modification of compiler constant of type language, length 4
ERROR: the modified constant is function body:
ifelse(x == 0, -0.0986659612490242, sin(x)/x)
ERROR: the body was originally:
ifelse(x == 0, 1, sin(x)/x)
ERROR: modification of compiler constant of type double, length 1
ERROR: the modified value of the constant is:
[1] -0.09866596
ERROR: the original value of the constant is:
[1] 1
ERROR: the modified constant is at index 3
ERROR: the modified constant is in this function body:
ifelse(x == 0, -0.0986659612490242, sin(x)/x)
Fatal error: compiler constants were modified!

