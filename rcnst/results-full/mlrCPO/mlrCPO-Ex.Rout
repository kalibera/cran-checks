
R Under development (unstable) (2025-12-24 r89227) -- "Unsuffered Consequences"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "mlrCPO"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('mlrCPO')
Loading required package: ParamHelpers
Loading required package: mlr
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("CPO")
> ### * CPO
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CPO
> ### Title: Composable Preprocessing Operators
> ### Aliases: CPO
> 
> ### ** Examples
> 
> class(cpoPca())  # c("CPOPrimitive", "CPO")
[1] "CPOPrimitive" "CPO"         
> class(cpoPca() %>>% cpoScale())  # c("CPOPipeline", "CPO")
[1] "CPOPipeline" "CPO"        
> print(cpoPca() %>>% cpoScale(), verbose = TRUE)
Trafo chain of 2 cpos:
pca(center = TRUE, scale = FALSE)[not exp'd: tol = <NULL>, rank = <NULL>]
Operating: feature
ParamSet:
              Type len   Def Constr Req Tunable Trafo
pca.center logical   -  TRUE      -   -    TRUE     -
pca.scale  logical   - FALSE      -   -    TRUE     -
  ====>
scale(center = TRUE, scale = TRUE)
Operating: feature
ParamSet:
                Type len  Def Constr Req Tunable Trafo
scale.center logical   - TRUE      -   -    TRUE     -
scale.scale  logical   - TRUE      -   -    TRUE     -
> 
> getHyperPars(cpoScale(center = FALSE))
$scale.center
[1] FALSE

$scale.scale
[1] TRUE

> 
> head(getTaskData(iris.task %>>% cpoScale()))
  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1   -0.8976739  1.01560199    -1.335752   -1.311052  setosa
2   -1.1392005 -0.13153881    -1.335752   -1.311052  setosa
3   -1.3807271  0.32731751    -1.392399   -1.311052  setosa
4   -1.5014904  0.09788935    -1.279104   -1.311052  setosa
5   -1.0184372  1.24503015    -1.335752   -1.311052  setosa
6   -0.5353840  1.93331463    -1.165809   -1.048667  setosa
> 
> 
> 
> cleanEx()
> nameEx("CPOConstructor")
> ### * CPOConstructor
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CPOConstructor
> ### Title: Constructor for CPO Objects
> ### Aliases: CPOConstructor
> 
> ### ** Examples
> 
> class(cpoPca)  # c("CPOConstructor", "function")
[1] "CPOConstructor" "function"      
> print(cpoPca)  # default printer
<<CPO pca(center = TRUE, scale = FALSE, tol = <NULL>, rank = <NULL>)>>
> print(cpoPca, verbose = TRUE)  # shows the trafo / retrafo functions
<<CPO pca(center = TRUE, scale = FALSE, tol = <NULL>, rank = <NULL>)>>

cpo.trafo:
function (center = TRUE, scale = FALSE, tol = NULL, rank = NULL, 
    data, target) 
{
    if (!ncol(data)) {
        emat = matrix(data = numeric(0), nrow = 0, ncol = 0)
        control = list(rotation = emat, scale = numeric(0), center = numeric(0))
        return(data)
    }
    pcr = prcomp(as.matrix(data), center = center, scale. = scale, 
        tol = tol, rank. = rank)
    control = pcr[c("rotation", "scale", "center")]
    pcr$x
}
<environment: namespace:mlrCPO>

cpo.retrafo:
function (center = TRUE, scale = FALSE, tol = NULL, rank = NULL, 
    data, control) 
{
    scale(as.matrix(data), center = control$center, scale = control$scale) %*% 
        control$rotation
}
<environment: namespace:mlrCPO>
> 
> cpoPca()  # creating a CPO
pca(center = TRUE, scale = FALSE)[not exp'd: tol = <NULL>, rank = <NULL>]
> class(cpoPca())  # c("CPOPrimitive", "CPO")
[1] "CPOPrimitive" "CPO"         
> 
> 
> 
> 
> cleanEx()
> nameEx("CPOLearner")
> ### * CPOLearner
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CPOLearner
> ### Title: CPO Learner Object
> ### Aliases: CPOLearner
> 
> ### ** Examples
> 
> lrn = makeLearner("classif.logreg")
> cpolrn = cpoScale() %>>% lrn
> print(cpolrn)
Learner classif.logreg.scale from package stats
Type: classif
Name: ; Short name: 
Class: CPOLearner
Properties: numerics,factors,twoclass,prob
Predict-Type: response
Hyperparameters: model=FALSE

> 
> getLearnerBare(cpolrn)  # classif.logreg Learner
Learner classif.logreg from package stats
Type: classif
Name: Logistic Regression; Short name: logreg
Class: classif.logreg
Properties: twoclass,numerics,factors,prob,weights
Predict-Type: response
Hyperparameters: model=FALSE

> getLearnerCPO(cpolrn)  # cpoScale() CPO
scale(center = TRUE, scale = TRUE)
> 
> getParamSet(cpolrn)  # includes cpoScale hyperparameters
                Type len  Def Constr Req Tunable Trafo
scale.center logical   - TRUE      -   -    TRUE     -
scale.scale  logical   - TRUE      -   -    TRUE     -
model        logical   - TRUE      -   -   FALSE     -
> 
> model = train(cpolrn, pid.task)  # behaves like a learner
> retrafo(model)  # the CPORetrafo that was trained
CPO Retrafo chain
[RETRAFO scale(center = TRUE, scale = TRUE)]
> 
> predict(model, pid.task)  # otherwise behaves like an mlr model
Prediction: 768 observations
predict.type: response
threshold: 
time: 0.03
  id truth response
1  1   pos      pos
2  2   neg      neg
3  3   pos      pos
4  4   neg      neg
5  5   pos      pos
6  6   neg      neg
... (#rows: 768, #cols: 3)
> 
> 
> 
> 
> cleanEx()
> nameEx("CPOTrained")
> ### * CPOTrained
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CPOTrained
> ### Title: Get the Retransformation or Inversion Function from a Resulting
> ###   Object
> ### Aliases: CPOTrained CPORetrafo CPOInverter retrafo inverter retrafo<-
> ###   inverter<-
> 
> ### ** Examples
> 
> traindat = subsetTask(pid.task, 1:400)
> preddat = subsetTask(pid.task, 401:768)
> 
> trained = traindat %>>% cpoPca()
> reFun = retrafo(trained)
> predicted = preddat %>>% reFun
> head(getTaskData(predicted))
    diabetes        PC1        PC2        PC3        PC4        PC5        PC6
401      pos -84.533128 -16.377902  -5.953769  15.471857 -2.5141001 -6.1500829
402      neg -80.383496  27.275779  -9.607740  17.130030 15.8863960  5.2785909
403      pos   9.548944  13.030095  17.953331 -17.919489  2.2009380  4.1929553
404      neg -85.240015 -39.456703  15.756013   0.639444  9.4488413  0.4820485
405      pos -77.210758  56.209452 -10.437033   7.524593  0.1793082 -2.0727927
406      neg  83.877962  -9.720671 -19.047282 -13.157908  0.8537302 -9.1316199
           PC7        PC8
401  0.5578393 0.20910205
402 -1.8236278 0.31616133
403  0.4826818 0.25252337
404  4.1093591 0.07530882
405 -0.4976554 0.34331083
406 -0.9156816 0.07432789
> 
> # chaining works
> trained = traindat %>>% cpoPca() %>>% cpoScale()
> reFun = retrafo(trained)
> predicted = preddat %>>% reFun
> head(getTaskData(predicted))
    diabetes        PC1        PC2        PC3         PC4         PC5
401      pos -0.6907341 -0.5287483 -0.3071310  1.11929566 -0.24772162
402      neg -0.6568268  0.8805780 -0.4956246  1.23925448  1.56533296
403      pos  0.0780260  0.4206668  0.9261401 -1.29636705  0.21686484
404      neg -0.6965102 -1.2738300  0.8127893  0.04625992  0.93102191
405      pos -0.6309018  1.8146799 -0.5384045  0.54435893  0.01766776
406      neg  0.6853806 -0.3138246 -0.9825726 -0.95189535  0.08412053
            PC6        PC7       PC8
401 -0.86367029  0.2031152 0.6241936
402  0.74128466 -0.6640023 0.9437779
403  0.58882636  0.1757496 0.7538113
404  0.06769518  1.4962614 0.2248055
405 -0.29108705 -0.1812016 1.0248223
406 -1.28237437 -0.3334094 0.2218773
> 
> # reset the retrafo when doing other steps!
> 
> trained.tmp = traindat %>>% cpoPca()
> reFun1 = retrafo(trained.tmp)
> 
> imp = impute(trained.tmp)
> trained.tmp = imp$task  # nonsensical example
> retrafo(trained.tmp) = NULL  # NECESSARY HERE
> 
> trained = trained.tmp %>>% cpoScale()
> 
> reFun2 = retrafo(trained)
> predicted = getTaskData(reimpute(preddat %>>% reFun1, imp$desc),
+   target.extra = TRUE)$data %>>% reFun2
> 
> 
> 
> cleanEx()
> nameEx("clearRI")
> ### * clearRI
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: clearRI
> ### Title: Clear Retrafo and Inverter Attributes
> ### Aliases: clearRI
> 
> ### ** Examples
> 
> # without clearRI
> transformed = iris.task %>>% cpoPca()
> transformed2 = transformed %>>% cpoScale()
> retrafo(transformed2)  # [RETRAFO pca]=>[RETRAFO scale]
CPO Retrafo chain
[RETRAFO pca(center = TRUE, scale = FALSE)] =>
[RETRAFO scale(center = TRUE, scale = TRUE)]
> 
> transformed = iris.task %>>% cpoPca()
> transformed2 = clearRI(transformed) %>>% cpoScale()
> retrafo(transformed2)  # [RETRAFO scale]
CPO Retrafo chain
[RETRAFO scale(center = TRUE, scale = TRUE)]
> 
> 
> 
> 
> cleanEx()
> nameEx("cpoMakeCols")
> ### * cpoMakeCols
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cpoMakeCols
> ### Title: Create Columns from Expressions
> ### Aliases: cpoMakeCols cpoAddCols
> 
> ### ** Examples
> 
> res = pid.task %>>% cpoAddCols(gpi = glucose * pressure * insulin, pm = pregnant * mass)
> head(getTaskData(res))
  pregnant glucose pressure triceps insulin mass pedigree age    gpi    pm
1        6     148       72      35       0 33.6    0.627  50      0 201.6
2        1      85       66      29       0 26.6    0.351  31      0  26.6
3        8     183       64       0       0 23.3    0.672  32      0 186.4
4        1      89       66      23      94 28.1    0.167  21 552156  28.1
5        0     137       40      35     168 43.1    2.288  33 920640   0.0
6        5     116       74       0       0 25.6    0.201  30      0 128.0
  diabetes
1      pos
2      neg
3      pos
4      neg
5      pos
6      neg
> 
> 
> 
> cleanEx()
> nameEx("grapes-greater-than-greater-than-grapes")
> ### * grapes-greater-than-greater-than-grapes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: %>>%
> ### Title: CPO Composition / Attachment / Application Operator
> ### Aliases: %>>% %<<% %<>>% %<<<% %>|% %|<%
> 
> ### ** Examples
> 
> # PCA-rotate pid.task
> rotated.pid.task = pid.task %>>% cpoScale() %>>% cpoPca()
> 
> # Centering / Scaling *after* PCA
> newPCA = cpoPca() %>>% cpoScale()
> 
> # Attach the above to learner
> pcaLogreg = newPCA %>>% makeLearner("classif.logreg")
> 
> # append cpoAsNumeric to newPCA
> newPCA %<>>% cpoAsNumeric()
> print(newPCA)
(pca >> scale >> as.numeric)(pca.center = TRUE, pca.scale = FALSE, scale.center = TRUE, scale.scale = TRUE)
> 
> # prepend cpoAsNumeric to pcaLogreg
> pcaLogreg %<<<% cpoAsNumeric()
> 
> 
> 
> 
> cleanEx()
> nameEx("makeCPO")
> ### * makeCPO
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: makeCPO
> ### Title: Create a Custom CPO Constructor
> ### Aliases: makeCPO makeCPOExtendedTrafo makeCPORetrafoless
> ###   makeCPOTargetOp makeCPOExtendedTargetOp
> 
> ### ** Examples
> 
> # an example constant feature remover CPO
> constFeatRem = makeCPO("constFeatRem",
+  dataformat = "df.features",
+  cpo.train = function(data, target) {
+    names(Filter(function(x) {  # names of columns to keep
+        length(unique(x)) > 1
+      }, data))
+    }, cpo.retrafo = function(data, control) {
+    data[control]
+  })
> # alternatively:
> constFeatRem = makeCPO("constFeatRem",
+   dataformat = "df.features",
+   cpo.train = function(data, target) {
+     cols.keep = names(Filter(function(x) {
+         length(unique(x)) > 1
+       }, data))
+     # the following function will do both the trafo and retrafo
+     result = function(data) {
+       data[cols.keep]
+     }
+     result
+   }, cpo.retrafo = NULL)
> 
> 
> 
> cleanEx()
> nameEx("pSS")
> ### * pSS
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pSS
> ### Title: Turn the argument list into a 'ParamSet'
> ### Aliases: pSS pSSLrn
> 
> ### ** Examples
> 
> pSSLrn(a = NA: integer [~0, ]^2 [[requires = expression(b != 0)]],
+        b = -10: numeric [~., 0],
+        c: discrete [x, y, 1],
+        d: logical,
+        e: integer)
           Type len Def      Constr Req Tunable Trafo
a integervector   2   -    1 to Inf   Y    TRUE     -
b       numeric   - -10   -Inf to 0   -    TRUE     -
c      discrete   -   -       x,y,1   -    TRUE     -
d       logical   -   -           -   -    TRUE     -
e       integer   -   - -Inf to Inf   -    TRUE     -
> 
> # is equivalent to
> 
> makeParamSet(
+     makeIntegerVectorLearnerParam("a", len = 2, lower = 1,  # note exclusive bound
+          upper = Inf, requires = expression(b != 0)),
+     makeNumericLearnerParam("b", lower = -Inf, upper = 0,
+          allow.inf = FALSE, default = -10),  # note infinite value is prohibited.
+     makeDiscreteLearnerParam("c", values = list(x = "x", y = "y", `1` = 1)),
+     makeLogicalLearnerParam("d"),
+     makeIntegerLearnerParam("e"))
           Type len Def      Constr Req Tunable Trafo
a integervector   2   -    1 to Inf   Y    TRUE     -
b       numeric   - -10   -Inf to 0   -    TRUE     -
c      discrete   -   -       x,y,1   -    TRUE     -
d       logical   -   -           -   -    TRUE     -
e       integer   -   - -Inf to Inf   -    TRUE     -
> 
> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  20.123 1.014 21.495 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
