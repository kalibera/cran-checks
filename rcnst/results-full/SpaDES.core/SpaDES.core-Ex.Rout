
R Under development (unstable) (2021-09-28 r80976) -- "Unsuffered Consequences"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "SpaDES.core"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('SpaDES.core')
Loading required package: quickPlot
Loading required package: reproducible

Attaching package: ‘SpaDES.core’

The following objects are masked from ‘package:stats’:

    end, start

The following object is masked from ‘package:utils’:

    citation

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("Plots")
> ### * Plots
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Plots
> ### Title: 'Plot' wrapper intended for use in a SpaDES module
> ### Aliases: Plots
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D # Note: if this is used inside a SpaDES module, do not define this
> ##D #  function inside another function. Put it outside in a normal
> ##D #  module script. It will cause a memory leak, otherwise.
> ##D if (!require("ggplot2")) stop("please install ggplot2")
> ##D fn <- function(d)
> ##D   ggplot(d, aes(a)) +
> ##D   geom_histogram()
> ##D sim <- simInit()
> ##D sim$something <- data.frame(a = sample(1:10, replace = TRUE))
> ##D 
> ##D Plots(data = sim$something, fn = fn,
> ##D       types = c("png"),
> ##D       path = file.path("figures"),
> ##D       filename = tempfile(),
> ##D       .plotInitialTime = 1
> ##D       )
> ##D 
> ##D # plot to active device and to png
> ##D Plots(data = sim$something, fn = fn,
> ##D       types = c("png", "screen"),
> ##D       path = file.path("figures"),
> ##D       filename = tempfile(),
> ##D       .plotInitialTime = 1
> ##D       )
> ##D 
> ##D # Can also be used like quickPlot::Plot, but with control over output type
> ##D r <- raster::raster(extent(0,10,0,10), vals = sample(1:3, size = 100, replace = TRUE))
> ##D Plots(r, types = c("screen", "png"), deviceArgs = list(width = 700, height = 500))
> ##D 
> ## End(Not run) # end of dontrun
> 
> 
> 
> cleanEx()
> nameEx("append_attr")
> ### * append_attr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: append_attr
> ### Title: Add a module to a 'moduleList'
> ### Aliases: append_attr append_attr,list,list-method
> 
> ### ** Examples
> 
> library(igraph) # igraph exports magrittr's pipe operator

Attaching package: ‘igraph’

The following objects are masked from ‘package:stats’:

    decompose, spectrum

The following object is masked from ‘package:base’:

    union

> tmp1 <- list("apple", "banana") %>% lapply(., `attributes<-`, list(type = "fruit"))
> tmp2 <- list("carrot") %>% lapply(., `attributes<-`, list(type = "vegetable"))
> append_attr(tmp1, tmp2)
[[1]]
[1] "apple"
attr(,"type")
[1] "fruit"

[[2]]
[1] "banana"
attr(,"type")
[1] "fruit"

[[3]]
[1] "carrot"
attr(,"type")
[1] "vegetable"

> rm(tmp1, tmp2)
> 
> 
> 
> cleanEx()

detaching ‘package:igraph’

> nameEx("classFilter")
> ### * classFilter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: classFilter
> ### Title: Filter objects by class
> ### Aliases: classFilter
> ###   classFilter,character,character,character,environment-method
> ###   classFilter,character,character,character,missing-method
> ###   classFilter,character,character,missing,environment-method
> ###   classFilter,character,character,missing,missing-method
> 
> ### ** Examples
> 
> ## Not run: 
> ##D   ## from global environment
> ##D   a <- list(1:10)     # class `list`
> ##D   b <- letters        # class `character`
> ##D   d <- stats::runif(10)      # class `numeric`
> ##D   f <- sample(1L:10L) # class `numeric`, `integer`
> ##D   g <- lm( jitter(d) ~ d ) # class `lm`
> ##D   h <- glm( jitter(d) ~ d ) # class `lm`, `glm`
> ##D   classFilter(ls(), include=c("character", "list"))
> ##D   classFilter(ls(), include = "numeric")
> ##D   classFilter(ls(), include = "numeric", exclude = "integer")
> ##D   classFilter(ls(), include = "lm")
> ##D   classFilter(ls(), include = "lm", exclude = "glm")
> ##D   rm(a, b, d, f, g, h)
> ## End(Not run)
> 
> ## from local (e.g., function) environment
> local({
+   e <- environment()
+   a <- list(1:10)     # class `list`
+   b <- letters        # class `character`
+   d <- stats::runif(10)      # class `numeric`
+   f <- sample(1L:10L) # class `numeric`, `integer`
+   g <- lm( jitter(d) ~ d ) # class `lm`
+   h <- glm( jitter(d) ~ d ) # class `lm`, `glm`
+   classFilter(ls(), include=c("character", "list"), envir = e)
+   classFilter(ls(), include = "numeric", envir = e)
+   classFilter(ls(), include = "numeric", exclude = "integer", envir = e)
+   classFilter(ls(), include = "lm", envir = e)
+   classFilter(ls(), include = "lm", exclude = "glm", envir = e)
+   rm(a, b, d, e, f, g, h)
+ })
> 
> ## from another environment
> e = new.env(parent = emptyenv())
> e$a <- list(1:10)     # class `list`
> e$b <- letters        # class `character`
> e$d <- stats::runif(10)      # class `numeric`
> e$f <- sample(1L:10L) # class `numeric`, `integer`
> e$g <- lm( jitter(e$d) ~ e$d ) # class `lm`
> e$h <- glm( jitter(e$d) ~ e$d ) # class `lm`, `glm`
> classFilter(ls(e), include=c("character", "list"), envir = e)
[1] "a" "b"
> classFilter(ls(e), include = "numeric", envir = e)
[1] "d" "f"
> classFilter(ls(e), include = "numeric", exclude = "integer", envir = e)
[1] "d"
> classFilter(ls(e), include = "lm", envir = e)
[1] "g" "h"
> classFilter(ls(e), include = "lm", exclude = "glm", envir = e)
[1] "g"
> rm(a, b, d, f, g, h, envir = e)
> rm(e)
> 
> 
> 
> 
> cleanEx()
> nameEx("copyModule")
> ### * copyModule
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: copyModule
> ### Title: Create a copy of an existing module
> ### Aliases: copyModule copyModule,character,character,character-method
> ###   copyModule,character,character,missing-method
> 
> ### ** Examples
> 
> ## Not run: copyModule(from, to)
> 
> 
> 
> 
> cleanEx()
> nameEx("createsOutput")
> ### * createsOutput
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: createsOutput
> ### Title: Define an output object of a module
> ### Aliases: createsOutput createsOutput,ANY,ANY,ANY-method
> ###   createsOutput,character,character,character-method
> 
> ### ** Examples
> 
> outputObjects <- bindrows(
+   createsOutput(objectName = "outputObject1", objectClass = "character",
+                 desc = "this is for example"),
+   createsOutput(objectName = "outputObject2", objectClass = "numeric",
+                 desc = "this is for example",
+                 otherInformation = "I am the second output object")
+ )
> 
> 
> 
> 
> cleanEx()
> nameEx("defineModule")
> ### * defineModule
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: defineModule
> ### Title: Define a new module.
> ### Aliases: defineModule defineModule,simList,list-method
> 
> ### ** Examples
> 
> ## Not run: 
> ##D   ## a default version of the defineModule is created with a call to newModule
> ##D   newModule("test", path = tempdir(), open = FALSE)
> ##D 
> ##D   ## view the resulting module file
> ##D   if (interactive()) file.edit(file.path(tempdir(), "test", "test.R"))
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("defineParameter")
> ### * defineParameter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: defineParameter
> ### Title: Define a parameter used in a module
> ### Aliases: defineParameter
> ###   defineParameter,character,character,ANY,ANY,ANY,character-method
> ###   defineParameter,character,character,ANY,missing,missing,character-method
> ###   defineParameter,missing,missing,missing,missing,missing,missing-method
> 
> ### ** Examples
> 
> parameters = rbind(
+   defineParameter("lambda", "numeric", 1.23, desc = "intrinsic rate of increase"),
+   defineParameter("P", "numeric", 0.2, 0, 1, "probability of attack")
+ )
> 
> ## Not run: 
> ##D # Create a new module, then access parameters using \code{P}
> ##D tmpdir <- file.path(tempdir(), "test")
> ##D checkPath(tmpdir, create = TRUE)
> ##D 
> ##D # creates a  new, "empty" module -- it has defaults for everything that is required
> ##D newModule("testModule", tmpdir, open = FALSE)
> ##D 
> ##D # Look at new module code -- see defineParameter
> ##D if (interactive()) file.edit(file.path(tmpdir, "testModule", "testModule.R"))
> ##D 
> ##D # initialize the simList
> ##D mySim <- simInit(modules = "testModule",
> ##D                  paths = list(modulePath = tmpdir))
> ##D 
> ##D # Access one of the parameters -- because this line is not inside a module
> ##D #  function, we must specify the module name. If used within a module,
> ##D #  we can omit the module name
> ##D P(mySim, "testModule")$.useCache
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("downloadData")
> ### * downloadData
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: downloadData
> ### Title: Download module data
> ### Aliases: downloadData downloadData,character,character,logical-method
> ###   downloadData,character,missing,missing-method
> ###   downloadData,character,missing,logical-method
> ###   downloadData,character,character,missing-method
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # For a Google Drive example
> ##D # In metadata:
> ##D expectsInputs("theFilename.zip", "NA", "NA",
> ##D   sourceURL = "https://drive.google.com/open?id=1Ngb-jIRCSs1G6zcuaaCEFUwldbkI_K8Ez")
> ##D # create the checksums file
> ##D checksums("thisModule", "there", write = TRUE)
> ##D downloadData("thisModule", "there", files = "theFilename.zip")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("expectsInput")
> ### * expectsInput
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expectsInput
> ### Title: Define an input object that the module expects.
> ### Aliases: expectsInput expectsInput,ANY,ANY,ANY,ANY-method
> ###   expectsInput,character,character,character,character-method
> ###   expectsInput,character,character,character,missing-method
> 
> ### ** Examples
> 
> inputObjects <- bindrows(
+   expectsInput(objectName = "inputObject1", objectClass = "character",
+                desc = "this is for example", sourceURL = "not available"),
+   expectsInput(objectName = "inputObject2", objectClass = "numeric",
+                desc = "this is for example", sourceURL = "not available",
+                otherInformation = "I am the second input object")
+ )
> 
> 
> 
> 
> cleanEx()
> nameEx("loadFiles")
> ### * loadFiles
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: .fileExtensions
> ### Title: File extensions map
> ### Aliases: .fileExtensions loadFiles loadFiles,simList,missing-method
> ###   loadFiles,missing,ANY-method loadFiles,missing,missing-method
> ###   .saveFileExtensions
> 
> ### ** Examples
> 
> ## Not run: 
> ##D 
> ##D # Load random maps included with package
> ##D filelist <- data.frame(
> ##D     files = dir(system.file("maps", package = "quickPlot"),
> ##D             full.names = TRUE, pattern = "tif"),
> ##D     functions = "rasterToMemory", package = "quickPlot"
> ##D )
> ##D sim1 <- loadFiles(filelist = filelist)
> ##D clearPlot()
> ##D if (interactive()) Plot(sim1$DEM)
> ##D 
> ##D # Second, more sophisticated. All maps loaded at time = 0, and the last one is reloaded
> ##D #  at time = 10 and 20 (via "intervals").
> ##D # Also, pass the single argument as a list to all functions...
> ##D #  specifically, when add "native = TRUE" as an argument to the raster function
> ##D files = dir(system.file("maps", package = "quickPlot"),
> ##D             full.names = TRUE, pattern = "tif")
> ##D arguments = I(rep(list(native = TRUE), length(files)))
> ##D filelist = data.frame(
> ##D    files = files,
> ##D    functions = "raster::raster",
> ##D    objectName = NA,
> ##D    arguments = arguments,
> ##D    loadTime = 0,
> ##D    intervals = c(rep(NA, length(files)-1), 10)
> ##D )
> ##D 
> ##D sim2 <- loadFiles(filelist = filelist)
> ##D 
> ##D # if we extend the end time and continue running, it will load an object scheduled
> ##D #  at time = 10, and it will also schedule a new object loading at 20 because
> ##D #  interval = 10
> ##D end(sim2) <- 20
> ##D sim2 <- spades(sim2) # loads the percentPine map 2 more times, once at 10, once at 20
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("loadPackages")
> ### * loadPackages
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: loadPackages
> ### Title: Load packages.
> ### Aliases: loadPackages loadPackages,character-method
> ###   loadPackages,list-method loadPackages,NULL-method
> 
> ### ** Examples
> 
> ## Not run: 
> ##D   pkgs <- list("raster", "lme4")
> ##D   loadPackages(pkgs) # loads packages if installed
> ##D   loadPackages(pkgs, install = TRUE) # loads packages after installation (if needed)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("moduleCoverage")
> ### * moduleCoverage
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: moduleCoverage
> ### Title: Calculate module coverage of unit tests
> ### Aliases: moduleCoverage moduleCoverage,character,character-method
> ###   moduleCoverage,character,missing-method
> 
> ### ** Examples
> 
> ## Not run: 
> ##D  library(igraph) # for %>%
> ##D  library(SpaDES.core)
> ##D  tmpdir <- file.path(tempdir(), "coverage")
> ##D  modulePath <- file.path(tmpdir, "Modules") %>% checkPath(create = TRUE)
> ##D  moduleName <- "forestAge" # sample module to test
> ##D  downloadModule(name = moduleName, path = modulePath) # download sample module
> ##D  testResults <- moduleCoverage(name = moduleName, path = modulePath)
> ##D  report(testResults$moduleCoverage)
> ##D  report(testResults$functionCoverage)
> ##D  unlink(tmpdir, recursive = TRUE)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("moduleDiagram")
> ### * moduleDiagram
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: moduleDiagram
> ### Title: Simulation module dependency diagram
> ### Aliases: moduleDiagram moduleDiagram,simList,character,logical-method
> ###   moduleDiagram,simList,missing,ANY-method
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Will use quickPlot::Plot
> ##D moduleDiagram(sim)
> ##D # Can also use default base::plot
> ##D modDia <- depsGraph(sim, plot = TRUE)
> ##D # See ?plot.igraph
> ##D plot(modDia, layout = layout_as_star)
> ##D 
> ##D # Or for more control - here, change the label "_INPUT_" to "DATA"
> ##D edgeList <- depsEdgeList(sim)
> ##D edgeList <- edgeList[, list(from, to)]
> ##D edgeList[from == "_INPUT_", from := "Data"]
> ##D edgeList[to == "_INPUT_", to := "Data"]
> ##D edgeList <- unique(edgeList)
> ##D edge
> ##D ig <- igraph::graph_from_data_frame(edgeList[, list(from, to)])
> ##D plot(ig)
> ##D 
> ##D # Or use qgraph package
> ##D # library(qgraph)
> ##D # qgraph(edgeList, shape = "rectangle", vsize = 12, vsize2 = 2
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("moduleMetadata")
> ### * moduleMetadata
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: moduleMetadata
> ### Title: Parse and extract module metadata
> ### Aliases: moduleMetadata
> ###   moduleMetadata,missing,character,character-method
> ###   moduleMetadata,missing,character,missing-method
> ###   moduleMetadata,ANY,ANY,ANY-method
> 
> ### ** Examples
> 
> path <- system.file("sampleModules", package = "SpaDES.core")
> sampleModules <- dir(path)
> # turn off code checking -- don't need it here
> opts <- options("spades.moduleCodeChecks" = FALSE,
+                 "spades.useRequire" = FALSE)
> 
> x <- moduleMetadata(sampleModules[3], path = path)
Assuming sim is a module name
> 
> # using simList
> mySim <- simInit(
+    times = list(start = 2000.0, end = 2001.0, timeunit = "year"),
+    params = list(
+      .globals = list(stackName = "landscape")
+    ),
+    modules = list("caribouMovement"),
+    paths = list(modulePath = system.file("sampleModules", package = "SpaDES.core"))
+ )
Setting:
  options(
    spades.modulePath = '/var/scratch2/tomas/cran/rcnst/lib/SpaDES.core/sampleModules'
  )
Paths set to:
  options(
    rasterTmpDir = '/var/scratch2/tomas/tmp/RtmpO8pILv/raster'
    reproducible.cachePath = '/var/scratch2/tomas/tmp/RtmpO8pILv/Require/cache'
    spades.inputPath = '/var/scratch2/tomas/tmp/RtmpkJeDrg/SpaDES/inputs'
    spades.outputPath = '/var/scratch2/tomas/tmp/RtmpkJeDrg/SpaDES/outputs'
    spades.modulePath = '/var/scratch2/tomas/cran/rcnst/lib/SpaDES.core/sampleModules'
  )
Loading required package: SpaDES.tools
Loading required package: grid

Attaching package: ‘grid’

The following object is masked from ‘package:quickPlot’:

    gpar

Loading required package: raster
Loading required package: sp
> moduleMetadata(sim = mySim)
$name
[1] "caribouMovement"

$description
[1] "Simulate caribou movement via correlated random walk."

$keywords
[1] "caribou"                         "individual based movement model"
[3] "correlated random walk"         

$childModules
character(0)

$authors
[1] "Eliot J B McIntire <eliot.mcintire@canada.ca> [aut, cre]"

$version
[1] ‘1.6.0’

$spatialExtent
class      : Extent 
xmin       : NA 
xmax       : NA 
ymin       : NA 
ymax       : NA 

$timeframe
[1] NA NA

$timeunit
[1] "month"

$citation
list()

$documentation
list()

$reqdPkgs
$reqdPkgs[[1]]
[1] "grid"

$reqdPkgs[[2]]
[1] "raster"

$reqdPkgs[[3]]
[1] "sp"

$reqdPkgs[[4]]
[1] "stats"

$reqdPkgs[[5]]
[1] "SpaDES.tools"


$parameters
          paramName paramClass   default   min  max
1         stackName  character landscape    NA   NA
2   moveInitialTime    numeric      2001  2001 2001
3      moveInterval    numeric         1     1    1
4                 N    numeric       100    10 1000
5             torus    logical     FALSE FALSE TRUE
6  .plotInitialTime    numeric      2000  -Inf  Inf
7     .plotInterval    numeric         1  -Inf  Inf
8  .saveInitialTime    numeric        NA  -Inf  Inf
9     .saveInterval    numeric        NA  -Inf  Inf
10            .seed       list              NA   NA
                                                                                                                       paramDesc
1                                                                                                        name of the RasterStack
2                                                                                          time to schedule first movement event
3                                                                                          time interval between movoment events
4                                                                                                      initial number of caribou
5                                                                                       should the map wrap around like a torus?
6                                                                                              time to schedule first plot event
7                                                                                              time interval between plot events
8                                                                                              time to schedule first save event
9                                                                                              time interval between save events
10 Named list of seeds to use for each event (names). E.g., `list('init' = 123)` will `set.seed(123)` for the `init` event only.

$inputObjects
  objectName            objectClass                             desc sourceURL
1  landscape            RasterStack     layername = "habitatQuality"      <NA>
2    caribou SpatialPointsDataFrame Object holding caribou locations      <NA>

$outputObjects
  objectName            objectClass desc
1    caribou SpatialPointsDataFrame <NA>

> 
> # turn code checking back on -- don't need it here
> options(opts)
> 
> 
> 
> cleanEx()

detaching ‘package:raster’, ‘package:sp’, ‘package:grid’,
  ‘package:SpaDES.tools’

> nameEx("moduleParamsInputsOuputs")
> ### * moduleParamsInputsOuputs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: moduleParams
> ### Title: Extract a module's parameters, inputs, or outputs
> ### Aliases: moduleParams moduleParams,character,character-method
> ###   moduleInputs moduleInputs,character,character-method moduleOutputs
> ###   moduleOutputs,character,character-method
> 
> ### ** Examples
> 
> path <- system.file("sampleModules", package = "SpaDES.core")
> sampleModules <- dir(path)
> 
> p <- moduleParams(sampleModules[3], path = path)
> i <- moduleInputs(sampleModules[3], path = path)
> o <- moduleOutputs(sampleModules[3], path = path)
> 
> #' \dontrun{
> ## easily include these tables in Rmd files using knitr
> knitr::kable(p)


|paramName        |paramClass |default      |min        |max          |paramDesc                                                                                                                     |
|:----------------|:----------|:------------|:----------|:------------|:-----------------------------------------------------------------------------------------------------------------------------|
|stackName        |character  |landscape    |NA         |NA           |name of the RasterStack                                                                                                       |
|nFires           |numeric    |10           |1          |100          |number of fires to initiate                                                                                                   |
|its              |numeric    |1e+06        |1e+06      |1e+06        |number of iterations for fire spread                                                                                          |
|persistprob      |numeric    |0            |0          |1            |probability of fire persisting in a pixel                                                                                     |
|returnInterval   |numeric    |1            |1          |1            |fire return interval                                                                                                          |
|spreadprob       |numeric    |0.225        |0.05       |0.5          |probability of fire spreading into a pixel                                                                                    |
|startTime        |numeric    |start(si.... |0          |end(sim)     |time of initial fire ignition                                                                                                 |
|.plotInitialTime |numeric    |start(sim)   |start(sim) |end(sim) + 1 |time to schedule first plot event                                                                                             |
|.plotInterval    |numeric    |1            |1          |1            |time interval between plot events                                                                                             |
|.saveInitialTime |numeric    |NA           |NA         |NA           |time to schedule first save event                                                                                             |
|.saveInterval    |numeric    |NA           |NA         |NA           |time interval between save events                                                                                             |
|.seed            |list       |             |NA         |NA           |Named list of seeds to use for each event (names). E.g., `list('init' = 123)` will `set.seed(123)` for the `init` event only. |
> knitr::kable(i)


|objectName                                  |objectClass |desc |sourceURL |
|:-------------------------------------------|:-----------|:----|:---------|
|SpaDES.core::P(sim, "fireSpread")$stackName |RasterStack |NA   |NA        |
|SpaDES.core::globals(sim)$burnStats         |numeric     |NA   |NA        |
> knitr::kable(o)


|objectName                                  |objectClass |desc |other |
|:-------------------------------------------|:-----------|:----|:-----|
|SpaDES.core::P(sim, "fireSpread")$stackName |RasterStack |NA   |NA    |
|SpaDES.core::globals(sim)$burnStats         |numeric     |NA   |NA    |
> #' }
> 
> 
> 
> cleanEx()
> nameEx("moduleVersion")
> ### * moduleVersion
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: moduleVersion
> ### Title: Parse and extract a module's version
> ### Aliases: moduleVersion moduleVersion,character,character,missing-method
> ###   moduleVersion,character,missing,missing-method
> ###   moduleVersion,character,missing,simList-method
> 
> ### ** Examples
> 
> # using filepath
> path <- system.file("sampleModules", package = "SpaDES.core")
> moduleVersion("caribouMovement", path)
[1] ‘1.6.0’
> 
> # using simList
> options("spades.useRequire" = FALSE)
> mySim <- simInit(
+    times = list(start = 2000.0, end = 2002.0, timeunit = "year"),
+    params = list(
+      .globals = list(stackName = "landscape", burnStats = "nPixelsBurned")
+    ),
+    modules = list("caribouMovement"),
+    paths = list(modulePath = path)
+ )
Setting:
  options(
    spades.modulePath = '/var/scratch2/tomas/cran/rcnst/lib/SpaDES.core/sampleModules'
  )
Paths set to:
  options(
    rasterTmpDir = '/var/scratch2/tomas/tmp/RtmpO8pILv/raster'
    reproducible.cachePath = '/var/scratch2/tomas/tmp/RtmpO8pILv/Require/cache'
    spades.inputPath = '/var/scratch2/tomas/tmp/RtmpkJeDrg/SpaDES/inputs'
    spades.outputPath = '/var/scratch2/tomas/tmp/RtmpkJeDrg/SpaDES/outputs'
    spades.modulePath = '/var/scratch2/tomas/cran/rcnst/lib/SpaDES.core/sampleModules'
  )
Loading required package: SpaDES.tools
Loading required package: grid

Attaching package: ‘grid’

The following object is masked from ‘package:quickPlot’:

    gpar

Loading required package: raster
Loading required package: sp
###### Module Code Checking - Still experimental - please report problems ######## 
/var/scratch2/tomas/cran/rcnst/lib/SpaDES.core/sampleModules/caribouMovement/caribouMovement.R
caribouMovement: module code: landscape, caribou are declared in metadata inputObjects, but no default(s) are provided in .inputObjects
caribouMovement: inputObjects: habitatQuality is used from sim inside Move, but is not declared in metadata inputObjects
###### Module Code Checking ########
Sep28 14:29:41 simInit:       Global parameter(s) not used in any module: burnStats.
> moduleVersion("caribouMovement", sim = mySim)
[1] ‘1.6.0’
> 
> 
> 
> cleanEx()

detaching ‘package:raster’, ‘package:sp’, ‘package:grid’,
  ‘package:SpaDES.tools’

> nameEx("newModule")
> ### * newModule
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: newModule
> ### Title: Create new module from template
> ### Aliases: newModule newModule,character,character-method
> ###   newModule,character,missing-method
> 
> ### ** Examples
> 
> ## Not run: 
> ##D   ## create a "myModule" module in the "modules" subdirectory.
> ##D   newModule("myModule", "modules")
> ##D 
> ##D   ## create a new parent module in the "modules" subdirectory.
> ##D   newModule("myParentModule", "modules", type = "parent", children = c("child1", "child2"))
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("newProject")
> ### * newProject
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: newProject
> ### Title: Create new SpaDES project
> ### Aliases: newProject newProject,character,character,logical-method
> ###   newProject,character,character,missing-method
> 
> ### ** Examples
> 
> myProjDir <- newProject("myProject", tempdir())
Setting:
  options(
    reproducible.cachePath = '/var/scratch2/tomas/tmp/RtmpO8pILv/myProject/cache'
    spades.inputPath = '/var/scratch2/tomas/tmp/RtmpO8pILv/myProject/inputs'
    spades.outputPath = '/var/scratch2/tomas/tmp/RtmpO8pILv/myProject/outputs'
    spades.modulePath = '/var/scratch2/tomas/tmp/RtmpO8pILv/myProject/modules'
  )
Paths set to:
  options(
    rasterTmpDir = '/var/scratch2/tomas/tmp/RtmpO8pILv/raster'
    reproducible.cachePath = '/var/scratch2/tomas/tmp/RtmpO8pILv/myProject/cache'
    spades.inputPath = '/var/scratch2/tomas/tmp/RtmpO8pILv/myProject/inputs'
    spades.outputPath = '/var/scratch2/tomas/tmp/RtmpO8pILv/myProject/outputs'
    spades.modulePath = '/var/scratch2/tomas/tmp/RtmpO8pILv/myProject/modules'
  )
> 
> dir.exists(file.path(myProjDir, "cache"))
[1] TRUE
> dir.exists(file.path(myProjDir, "inputs"))
[1] TRUE
> dir.exists(file.path(myProjDir, "modules"))
[1] TRUE
> dir.exists(file.path(myProjDir, "outputs"))
[1] TRUE
> unlink(myProjDir, recursive = TRUE) ## cleanup
> 
> 
> 
> cleanEx()
> nameEx("objSize.simList")
> ### * objSize.simList
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: objSize.simList
> ### Title: Object size for 'simList'
> ### Aliases: objSize.simList
> 
> ### ** Examples
> 
> a <- simInit(objects = list(d = 1:10, b = 2:20))
Setting:
  options(
    rasterTmpDir = '/var/scratch2/tomas/tmp/RtmpO8pILv/raster'
    reproducible.cachePath = '/var/scratch2/tomas/tmp/RtmpO8pILv/myProject/cache'
    spades.inputPath = '/var/scratch2/tomas/tmp/RtmpO8pILv/myProject/inputs'
    spades.outputPath = '/var/scratch2/tomas/tmp/RtmpO8pILv/myProject/outputs'
    spades.modulePath = '/var/scratch2/tomas/tmp/RtmpO8pILv/myProject/modules'
  )
Error in .isFALSE(keep) : could not find function ".isFALSE"
Calls: simInit ... objs<- -> objs<- -> inputs<- -> inputs<- -> isAbsolutePath
Execution halted
