
R Under development (unstable) (2024-12-21 r87453) -- "Unsuffered Consequences"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "rstpm2"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('rstpm2')
Loading required package: survival
Loading required package: splines

Attaching package: ‘rstpm2’

The following object is masked from ‘package:survival’:

    colon

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("aft-class")
> ### * aft-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aft-class
> ### Title: Class "stpm2" ~~~
> ### Aliases: aft-class plot,aft,missing-method lines,aft-method
> ###   predict,aft-method predictnl,aft-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> showClass("aft")
Class "aft" [package "rstpm2"]

Slots:
                                                                            
Name:       args      call call.orig      coef  fullcoef      vcov       min
Class:      list  language  language   numeric   numeric    matrix   numeric
                                                                  
Name:    details minuslogl    method      data   formula optimizer
Class:      list  function character      list character character

Extends: "mle2"
> 
> 
> 
> cleanEx()
> nameEx("aft")
> ### * aft
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aft
> ### Title: Parametric accelerated failure time model with smooth time
> ###   functions
> ### Aliases: aft
> ### Keywords: survival smooth
> 
> ### ** Examples
> 
> summary(aft(Surv(rectime,censrec==1)~hormon,data=brcancer,df=4))
Maximum likelihood estimation

Call:
bbmle::mle2(minuslogl = negll, start = coef, eval.only = TRUE, 
    vecpar = TRUE, gr = gradient, control = control)

Coefficients:
                                      Estimate Std. Error  z value     Pr(z)
hormon                                0.285471   0.094189   3.0308  0.002439
nsx(logtstar, df, intercept = TRUE)1 -0.273013   0.235850  -1.1576  0.247038
nsx(logtstar, df, intercept = TRUE)2  2.045508   0.214606   9.5315 < 2.2e-16
nsx(logtstar, df, intercept = TRUE)3 -7.387086   0.586894 -12.5868 < 2.2e-16
nsx(logtstar, df, intercept = TRUE)4  4.361046   0.346420  12.5889 < 2.2e-16
                                        
hormon                               ** 
nsx(logtstar, df, intercept = TRUE)1    
nsx(logtstar, df, intercept = TRUE)2 ***
nsx(logtstar, df, intercept = TRUE)3 ***
nsx(logtstar, df, intercept = TRUE)4 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

-2 log L: 5215.435 
> 
> 
> 
> cleanEx()
> nameEx("brcancer")
> ### * brcancer
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: brcancer
> ### Title: German breast cancer data from Stata.
> ### Aliases: brcancer
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(brcancer)
> ## maybe str(brcancer) ; plot(brcancer) ...
> 
> 
> 
> cleanEx()
> nameEx("coef")
> ### * coef
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coef<-
> ### Title: Generic method to update the coef in an object.
> ### Aliases: coef<-
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (x, value) 
+ UseMethod("coef<-")
function (x, value) 
UseMethod("coef<-")
> 
> 
> 
> cleanEx()
> nameEx("colon")
> ### * colon
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: colon
> ### Title: Colon cancer.
> ### Aliases: colon
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(colon,package="rstpm2") # avoids name conflict with survival::colon
> ## maybe str(colon) ; ...
> 
> 
> 
> cleanEx()
> nameEx("cox.tvc")
> ### * cox.tvc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cox.tvc
> ### Title: Test for a time-varying effect in the 'coxph' model
> ### Aliases: cox.tvc
> ### Keywords: time-varying Cox
> 
> ### ** Examples
> 
> ## As per the example for cox.zph:
> fit <- coxph(Surv(futime, fustat) ~ age + ecog.ps,  
+              data=ovarian) 
> temp <- rstpm2:::cox.tvc(fit, "age") 
> print(temp)                  # display the results 
Maximum likelihood estimation

Call:
mle2(minuslogl = minuslogl, start = beta, method = "BFGS", gr = gr)

Coefficients:
            Estimate Std. Error z value  Pr(z)
age         0.673108   0.492006  1.3681 0.1713
ecog.ps     0.057562   0.605399  0.0951 0.9243
age:log(t) -0.091582   0.085225 -1.0746 0.2826

-2 log L: 54.31134 
> plot(temp)                   # plot curves 
> 
> 
> 
> cleanEx()
> nameEx("gsm")
> ### * gsm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gsm
> ### Title: Parametric and penalised generalised survival models
> ### Aliases: gsm pstpm2 stpm2
> ### Keywords: survival
> 
> ### ** Examples
> 
> ## Not run: 
> ##D     data(brcancer)
> ##D     summary(fit <- stpm2(Surv(rectime,censrec==1)~hormon,data=brcancer,df=3))
> ##D     
> ##D     ## some predictions
> ##D     head(predict(fit,se.fit=TRUE,type="surv"))
> ##D     head(predict(fit,se.fit=TRUE,type="hazard"))
> ##D     
> ##D     ## some plots
> ##D     plot(fit,newdata=data.frame(hormon=0),type="hazard")
> ##D     plot(fit,newdata=data.frame(hormon=0),type="surv")
> ##D 
> ##D     ## time-varying coefficient
> ##D     summary(fit.tvc <- stpm2(Surv(rectime,censrec==1)~hormon,data=brcancer,df=3,
> ##D                              tvc=list(hormon=3)))
> ##D     anova(fit,fit.tvc) # compare with and without tvc
> ##D     
> ##D     ## some more plots
> ##D     plot(fit.tvc,newdata=data.frame(hormon=0),type="hr",var="hormon", ylim=c(0,2))
> ##D     lines(fit.tvc,newdata=data.frame(hormon=1),type="hr",var="hormon",
> ##D           col=2)
> ##D 
> ##D     plot(fit.tvc,newdata=data.frame(hormon=0),type="sdiff",var="hormon")
> ##D     
> ##D     plot(fit.tvc,newdata=data.frame(hormon=0),type="hdiff",var="hormon")
> ##D 
> ##D     library(scales)
> ##D     cols <- c(alpha("red",alpha=0.2), alpha("blue",alpha=0.2))
> ##D     plot(fit.tvc,newdata=data.frame(hormon=0),type="hazard",ci.col=cols[1])
> ##D     lines(fit.tvc,newdata=data.frame(hormon=1),type="hazard",lty=2,ci.col=cols[2],
> ##D           ci=TRUE)
> ##D     legend("topright",legend=c("No hormonal treatment", "(95##D 
> ##D            lty=c(1,1,2,1), lwd=c(1,10,1,10), col=c("black",cols[1],"black",cols[2]), bty="n")
> ##D 
> ##D     
> ##D     ## compare number of knots
> ##D     hormon0 <- data.frame(hormon=0)
> ##D     plot(fit,type="hazard",newdata=hormon0)
> ##D     AIC(fit)
> ##D     for (df in 4:6) {
> ##D         fit.new <- stpm2(Surv(rectime,censrec==1)~hormon,data=brcancer,df=df)
> ##D         plot(fit.new,type="hazard",newdata=hormon0,add=TRUE,ci=FALSE,line.col=df)
> ##D         print(AIC(fit.new))
> ##D     }
> ##D 
> ##D     ## compatibility with Stata's stpm2 using the smooth.formula argument (see Details)
> ##D     summary(stpm2(Surv(rectime,censrec==1)~hormon,data=brcancer,
> ##D                   smooth.formula=~nsx(log(rectime),df=3,stata.stpm2.compatible=TRUE)))
> ##D     summary(stpm2(Surv(rectime,censrec==1)~hormon,data=brcancer,
> ##D                   smooth.formula=~nsx(log(rectime),df=3,stata=TRUE)+
> ##D                   hormon:nsx(log(rectime),df=3,stata=TRUE)))
> ##D 
> ##D     
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("incrVar")
> ### * incrVar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: incrVar
> ### Title: Utility that returns a function to increment a variable in a
> ###   data-frame.
> ### Aliases: incrVar
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (var, increment = 1) 
+ {
+     n <- length(var)
+     if (n > 1 && length(increment)==1) 
+         increment <- rep(increment, n)
+     function(data) {
+         for (i in 1:n) {
+             data[[var[i]]] <- data[[var[i]]] + increment[i]
+         }
+         data
+     }
+   }
function (var, increment = 1) 
{
    n <- length(var)
    if (n > 1 && length(increment) == 1) 
        increment <- rep(increment, n)
    function(data) {
        for (i in 1:n) {
            data[[var[i]]] <- data[[var[i]]] + increment[i]
        }
        data
    }
}
> 
> 
> 
> cleanEx()
> nameEx("legendre.quadrature.rule.200")
> ### * legendre.quadrature.rule.200
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: legendre.quadrature.rule.200
> ### Title: Legendre quadrature rule for n=200.
> ### Aliases: legendre.quadrature.rule.200
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(legendre.quadrature.rule.200)
> ## maybe str(legendre.quadrature.rule.200) ; ...
> 
> 
> 
> cleanEx()
> nameEx("markov_msm")
> ### * markov_msm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: markov_msm
> ### Title: Predictions for continuous time, nonhomogeneous Markov
> ###   multi-state models using parametric and penalised survival models.
> ### Aliases: markov_msm vcov.markov_msm as.data.frame.markov_msm
> ###   as.data.frame.markov_msm_diff as.data.frame.markov_msm_ratio
> ###   standardise standardise.markov_msm plot.markov_msm subset.markov_msm
> ###   diff diff.markov_msm ratio_markov_msm rbind.markov_msm
> ###   transform.markov_msm collapse_markov_msm zeroModel hrModel aftModel
> ###   addModel hazFun splineFun
> ### Keywords: survival
> 
> ### ** Examples
> 
> ## Not run: 
> ##D if (requireNamespace("deSolve")) {
> ##D     library(readstata13)
> ##D     library(mstate)
> ##D     library(ggplot2)
> ##D     library(survival)
> ##D     ## Two states: Initial -> Final
> ##D     ## Note: this shows how to use markov_msm to estimate survival and risk probabilities based on
> ##D     ## smooth hazard models.
> ##D     two_states <- function(model, ...) {
> ##D         transmat = matrix(c(NA,1,NA,NA),2,2,byrow=TRUE)
> ##D         rownames(transmat) <- colnames(transmat) <- c("Initial","Final")
> ##D         rstpm2::markov_msm(list(model), ..., trans = transmat)
> ##D     }
> ##D     ## Note: the first argument is the hazard model. The other arguments are arguments to the
> ##D     ## markov_msm function, except for the transition matrix, which is defined by the new function.
> ##D     death = gsm(Surv(time,status)~factor(rx), data=survival::colon, subset=(etype==2), df=3)
> ##D     cr = two_states(death, newdata=data.frame(rx="Obs"), t = seq(0,2500, length=301))
> ##D     plot(cr,ggplot=TRUE)
> ##D 
> ##D     ## Competing risks
> ##D     ## Note: this shows how to adapt the markov_msm model for competing risks.
> ##D     competing_risks <- function(listOfModels, ...) {
> ##D         nRisks = length(listOfModels)
> ##D         transmat = matrix(NA,nRisks+1,nRisks+1)
> ##D         transmat[1,1+(1:nRisks)] = 1:nRisks
> ##D         rownames(transmat) <- colnames(transmat) <- c("Initial",names(listOfModels))
> ##D         rstpm2::markov_msm(listOfModels, ..., trans = transmat)
> ##D     }
> ##D     ## Note: The first argument for competing_risks is a list of models. Names from that list are
> ##D     ## used for labelling the states. The other arguments are as per the markov_msm function,
> ##D     ## except for the transition matrix, which is defined by the competing_risks function.
> ##D     recurrence = gsm(Surv(time,status)~factor(rx), data=survival::colon, subset=(etype==1), df=3)
> ##D     death = gsm(Surv(time,status)~factor(rx), data=survival::colon, subset=(etype==2), df=3)
> ##D     cr = competing_risks(list(Recurrence=recurrence,Death=death),
> ##D                          newdata=data.frame(rx=levels(survival::colon$rx)),
> ##D                          t = seq(0,2500, length=301))
> ##D     ## Plot the probabilities for each state for three different treatment arms
> ##D     plot(cr, ggplot=TRUE) + facet_grid(~ rx)
> ##D     ## And: differences in probabilities
> ##D     cr_diff = diff(subset(cr,rx=="Lev+5FU"),subset(cr,rx=="Obs"))
> ##D     plot(cr_diff, ggplot=TRUE, stacked=FALSE)
> ##D     
> ##D     ## Extended example: Crowther and Lambert (2017)
> ##D     ## library(rstpm2); library(readstata13); library(ggplot2)
> ##D     mex.1 <- read.dta13("http://fmwww.bc.edu/repec/bocode/m/multistate_example.dta")
> ##D     transmat <- rbind("Post-surgery"=c(NA,1,2), 
> ##D                       "Relapsed"=c(NA,NA,3),
> ##D                       "Died"=c(NA,NA,NA))
> ##D     colnames(transmat) <- rownames(transmat)
> ##D     mex.2 <- transform(mex.1,osi=(osi=="deceased")+0)
> ##D     levels(mex.2$size)[2] <- ">20-50 mm" # fix typo
> ##D     mex <- mstate::msprep(time=c(NA,"rf","os"),status=c(NA,"rfi","osi"),
> ##D                           data=mex.2,trans=transmat,id="pid",
> ##D                           keep=c("age","size","nodes","pr_1","hormon"))
> ##D     mex <- transform(mex,
> ##D                      size2=(unclass(size)==2)+0, # avoids issues with TRUE/FALSE
> ##D                      size3=(unclass(size)==3)+0,
> ##D                      hormon=(hormon=="yes")+0,
> ##D                      Tstart=Tstart/12,
> ##D                      Tstop=Tstop/12)
> ##D     ##
> ##D     c.ar <- stpm2(Surv(Tstart,Tstop,status) ~ age + size2 + size3 + nodes + pr_1 + hormon,
> ##D                   data = mex, subset=trans==1, df=3, tvc=list(size2=1,size3=1,pr_1=1))
> ##D     c.ad <- stpm2(Surv(Tstart, Tstop, status) ~ age + size + nodes + pr_1 + hormon,
> ##D                   data = mex, subset=trans==2, df=1)
> ##D     c.rd <- stpm2( Surv(Tstart,Tstop,status) ~ age + size + nodes + pr_1 + hormon,
> ##D                   data=mex, subset=trans==3, df=3, tvc=list(pr_1=1))
> ##D     ##
> ##D     nd <- expand.grid(nodes=seq(0,20,10), size=levels(mex$size))
> ##D     nd <- transform(nd, age=54, pr_1=3, hormon=0,
> ##D                     size2=(unclass(size)==2)+0,
> ##D                     size3=(unclass(size)==3)+0)
> ##D     ## Predictions
> ##D     system.time(pred1 <- rstpm2::markov_msm(list(c.ar,c.ad,c.rd), t = seq(0,15,length=301),
> ##D                                             newdata=nd, trans = transmat)) # ~2 seconds
> ##D     pred1 <- transform(pred1, Nodes=paste("Nodes =",nodes), Size=paste("Size",size))
> ##D     ## Figure 3
> ##D     plot(pred1, ggplot=TRUE) + facet_grid(Nodes ~ Size) + xlab("Years since surgery")
> ##D     plot(pred1, ggplot=TRUE, flipped=TRUE) +
> ##D         facet_grid(Nodes ~ Size) + xlab("Years since surgery")
> ##D     plot(pred1, strata=~nodes+size, xlab="Years since surgery", lattice=TRUE)
> ##D     ## Figure 4
> ##D     plot(subset(pred1, nodes==0 & size=="<=20 mm"), stacked=FALSE, ggplot=TRUE) +
> ##D         facet_grid(. ~ state) +
> ##D         xlab("Years since surgery")
> ##D     ## Figure 5
> ##D     a <- diff(subset(pred1,nodes==0 & size=="<=20 mm"),
> ##D               subset(pred1,nodes==0 & size==">20-50 mm"))
> ##D     a <- transform(a, label = "Prob(Size<=20 mm)-Prob(20mm<Size<50mm)")
> ##D     b <- ratio_markov_msm(subset(pred1,nodes==0 & size=="<=20 mm"),
> ##D                           subset(pred1,nodes==0 & size==">20-50 mm"))
> ##D     b <- transform(b,label="Prob(Size<=20 mm)-Prob(20mm<Size<50mm)")
> ##D     ##
> ##D     c <- diff(subset(pred1,nodes==0 & size=="<=20 mm"),
> ##D               subset(pred1,nodes==0 & size==">50 mm"))
> ##D     c <- transform(c, label = "Prob(Size<=20 mm)-Prob(Size>=50mm)")
> ##D     d <- ratio_markov_msm(subset(pred1,nodes==0 & size=="<=20 mm"),
> ##D                           subset(pred1,nodes==0 & size==">50 mm"))
> ##D     d <- transform(d,label= "Prob(Size<=20 mm)-Prob(Size>=50mm)")
> ##D     ##
> ##D     e <- diff(subset(pred1,nodes==0 & size==">20-50 mm"),
> ##D               subset(pred1,nodes==0 & size==">50 mm"))
> ##D     e <- transform(e,label="Prob(20mm<Size<50 mm)-Prob(Size>=50mm)")
> ##D     f <- ratio_markov_msm(subset(pred1,nodes==0 & size==">20-50 mm"),
> ##D                           subset(pred1,nodes==0 & size==">50 mm"))
> ##D     f <- transform(f, label = "Prob(20mm<Size<50 mm)-Prob(Size>=50mm)")
> ##D     ## combine
> ##D     diffs <- rbind(a,c,e)
> ##D     ratios <- rbind(b,d,f)
> ##D     ## Figure 5
> ##D     plot(diffs, stacked=FALSE, ggplot2=TRUE) + xlab("Years since surgery") +
> ##D         ylim(c(-0.4, 0.4)) + facet_grid(label ~ state)
> ##D     ##
> ##D     plot(ratios, stacked=FALSE, ggplot2=TRUE) + xlab("Years since surgery") +
> ##D         ylim(c(0, 3)) + facet_grid(label ~ state)
> ##D     ## Figure 6
> ##D     plot(subset(pred1, nodes==0 & size=="<=20 mm"), stacked=FALSE, which="L", ggplot2=TRUE) +
> ##D         facet_grid(. ~ state) + xlab("Years since surgery")
> ##D     ## Figure 7
> ##D     plot(diffs, stacked=FALSE, which="L", ggplot2=TRUE) + xlab("Years since surgery") +
> ##D         ylim(c(-4, 4)) + facet_grid(label ~ state)
> ##D     plot(ratios, stacked=FALSE, which="L", ggplot2=TRUE) + xlab("Years since surgery") +
> ##D         ylim(c(0.1, 10)) + coord_trans(y="log10") + facet_grid(label ~ state)
> ##D }
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("nsx")
> ### * nsx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nsx
> ### Title: Generate a Basis Matrix for Natural Cubic Splines (with
> ###   eXtensions)
> ### Aliases: nsx
> ### Keywords: smooth
> 
> ### ** Examples
> 
> require(stats); require(graphics); require(splines)
> nsx(women$height, df = 5)
                 1            2           3          4             5
 [1,] 0.000000e+00 0.000000e+00  0.00000000 0.00000000  0.0000000000
 [2,] 7.592323e-03 0.000000e+00 -0.08670223 0.26010669 -0.1734044626
 [3,] 6.073858e-02 0.000000e+00 -0.15030440 0.45091320 -0.3006088020
 [4,] 2.047498e-01 6.073858e-05 -0.16778345 0.50335034 -0.3355668952
 [5,] 4.334305e-01 1.311953e-02 -0.13244035 0.39732106 -0.2648807067
 [6,] 6.256681e-01 8.084305e-02 -0.07399720 0.22199159 -0.1479943948
 [7,] 6.477162e-01 2.468416e-01 -0.02616007 0.07993794 -0.0532919575
 [8,] 4.791667e-01 4.791667e-01  0.01406302 0.02031093 -0.0135406187
 [9,] 2.468416e-01 6.477162e-01  0.09733619 0.02286023 -0.0152401533
[10,] 8.084305e-02 6.256681e-01  0.27076826 0.06324188 -0.0405213106
[11,] 1.311953e-02 4.334305e-01  0.48059836 0.12526031 -0.0524087186
[12,] 6.073858e-05 2.047498e-01  0.59541597 0.19899261  0.0007809246
[13,] 0.000000e+00 6.073858e-02  0.50097182 0.27551020  0.1627793975
[14,] 0.000000e+00 7.592323e-03  0.22461127 0.35204082  0.4157555879
[15,] 0.000000e+00 0.000000e+00 -0.14285714 0.42857143  0.7142857143
attr(,"degree")
[1] 3
attr(,"knots")
 20%  40%  60%  80% 
60.8 63.6 66.4 69.2 
attr(,"Boundary.knots")
[1] 58 72
attr(,"intercept")
[1] FALSE
attr(,"derivs")
[1] 2 2
attr(,"centre")
[1] FALSE
attr(,"log")
[1] FALSE
attr(,"q.const")
     [,1] [,2]        [,3]      [,4]       [,5]
[1,]    0    0 -0.08451543 0.2535463 -0.1690309
[2,]    0    0 -0.25354628 0.7606388 -0.5070926
[3,]    1    0  0.00000000 0.0000000  0.0000000
[4,]    0    1  0.00000000 0.0000000  0.0000000
[5,]    0    0  0.92857143 0.2142857 -0.1428571
[6,]    0    0  0.21428571 0.3571429  0.4285714
[7,]    0    0 -0.14285714 0.4285714  0.7142857
attr(,"class")
[1] "nsx"    "basis"  "matrix"
> summary(fm1 <- lm(weight ~ ns(height, df = 5), data = women))

Call:
lm(formula = weight ~ ns(height, df = 5), data = women)

Residuals:
     Min       1Q   Median       3Q      Max 
-0.38333 -0.12585  0.07083  0.15401  0.30426 

Coefficients:
                    Estimate Std. Error t value Pr(>|t|)    
(Intercept)         114.7447     0.2338  490.88  < 2e-16 ***
ns(height, df = 5)1  15.9474     0.3699   43.12 9.69e-12 ***
ns(height, df = 5)2  25.1695     0.4323   58.23 6.55e-13 ***
ns(height, df = 5)3  33.2582     0.3541   93.93 8.91e-15 ***
ns(height, df = 5)4  50.7894     0.6062   83.78 2.49e-14 ***
ns(height, df = 5)5  45.0363     0.2784  161.75  < 2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 0.2645 on 9 degrees of freedom
Multiple R-squared:  0.9998,	Adjusted R-squared:  0.9997 
F-statistic:  9609 on 5 and 9 DF,  p-value: < 2.2e-16

> 
> ## example of safe prediction
> plot(women, xlab = "Height (in)", ylab = "Weight (lb)")
> ht <- seq(57, 73, length.out = 200)
> lines(ht, predict(fm1, data.frame(height=ht)))
> 
> 
> 
> 
> cleanEx()
> nameEx("nsxD")
> ### * nsxD
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nsxD
> ### Title: Generate a Basis Matrix for the first derivative of Natural
> ###   Cubic Splines (with eXtensions)
> ### Aliases: nsxD
> ### Keywords: smooth
> 
> ### ** Examples
> 
> require(stats); require(graphics); require(splines)
> nsx(women$height, df = 5)
                 1            2           3          4             5
 [1,] 0.000000e+00 0.000000e+00  0.00000000 0.00000000  0.0000000000
 [2,] 7.592323e-03 0.000000e+00 -0.08670223 0.26010669 -0.1734044626
 [3,] 6.073858e-02 0.000000e+00 -0.15030440 0.45091320 -0.3006088020
 [4,] 2.047498e-01 6.073858e-05 -0.16778345 0.50335034 -0.3355668952
 [5,] 4.334305e-01 1.311953e-02 -0.13244035 0.39732106 -0.2648807067
 [6,] 6.256681e-01 8.084305e-02 -0.07399720 0.22199159 -0.1479943948
 [7,] 6.477162e-01 2.468416e-01 -0.02616007 0.07993794 -0.0532919575
 [8,] 4.791667e-01 4.791667e-01  0.01406302 0.02031093 -0.0135406187
 [9,] 2.468416e-01 6.477162e-01  0.09733619 0.02286023 -0.0152401533
[10,] 8.084305e-02 6.256681e-01  0.27076826 0.06324188 -0.0405213106
[11,] 1.311953e-02 4.334305e-01  0.48059836 0.12526031 -0.0524087186
[12,] 6.073858e-05 2.047498e-01  0.59541597 0.19899261  0.0007809246
[13,] 0.000000e+00 6.073858e-02  0.50097182 0.27551020  0.1627793975
[14,] 0.000000e+00 7.592323e-03  0.22461127 0.35204082  0.4157555879
[15,] 0.000000e+00 0.000000e+00 -0.14285714 0.42857143  0.7142857143
attr(,"degree")
[1] 3
attr(,"knots")
 20%  40%  60%  80% 
60.8 63.6 66.4 69.2 
attr(,"Boundary.knots")
[1] 58 72
attr(,"intercept")
[1] FALSE
attr(,"derivs")
[1] 2 2
attr(,"centre")
[1] FALSE
attr(,"log")
[1] FALSE
attr(,"q.const")
     [,1] [,2]        [,3]      [,4]       [,5]
[1,]    0    0 -0.08451543 0.2535463 -0.1690309
[2,]    0    0 -0.25354628 0.7606388 -0.5070926
[3,]    1    0  0.00000000 0.0000000  0.0000000
[4,]    0    1  0.00000000 0.0000000  0.0000000
[5,]    0    0  0.92857143 0.2142857 -0.1428571
[6,]    0    0  0.21428571 0.3571429  0.4285714
[7,]    0    0 -0.14285714 0.4285714  0.7142857
attr(,"class")
[1] "nsx"    "basis"  "matrix"
> summary(fm1 <- lm(weight ~ ns(height, df = 5), data = women))

Call:
lm(formula = weight ~ ns(height, df = 5), data = women)

Residuals:
     Min       1Q   Median       3Q      Max 
-0.38333 -0.12585  0.07083  0.15401  0.30426 

Coefficients:
                    Estimate Std. Error t value Pr(>|t|)    
(Intercept)         114.7447     0.2338  490.88  < 2e-16 ***
ns(height, df = 5)1  15.9474     0.3699   43.12 9.69e-12 ***
ns(height, df = 5)2  25.1695     0.4323   58.23 6.55e-13 ***
ns(height, df = 5)3  33.2582     0.3541   93.93 8.91e-15 ***
ns(height, df = 5)4  50.7894     0.6062   83.78 2.49e-14 ***
ns(height, df = 5)5  45.0363     0.2784  161.75  < 2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 0.2645 on 9 degrees of freedom
Multiple R-squared:  0.9998,	Adjusted R-squared:  0.9997 
F-statistic:  9609 on 5 and 9 DF,  p-value: < 2.2e-16

> 
> ## example of safe prediction
> plot(women, xlab = "Height (in)", ylab = "Weight (lb)")
> ht <- seq(57, 73, length.out = 200)
> lines(ht, predict(fm1, data.frame(height=ht)))
> 
> 
> 
> 
> cleanEx()
> nameEx("numDeltaMethod")
> ### * numDeltaMethod
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: numDeltaMethod
> ### Title: Calculate numerical delta method for non-linear predictions.
> ### Aliases: numDeltaMethod
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (object, fun, ...) 
+ {
+     coef <- coef(object)
+     est <- fun(coef, ...)
+     Sigma <- vcov(object)
+     gd <- grad(fun, coef, ...)
+     se.est <- as.vector(sqrt(colSums(gd * (Sigma %*% gd))))
+     data.frame(Estimate = est, SE = se.est)
+   }
function (object, fun, ...) 
{
    coef <- coef(object)
    est <- fun(coef, ...)
    Sigma <- vcov(object)
    gd <- grad(fun, coef, ...)
    se.est <- as.vector(sqrt(colSums(gd * (Sigma %*% gd))))
    data.frame(Estimate = est, SE = se.est)
}
> 
> 
> 
> cleanEx()
> nameEx("popmort")
> ### * popmort
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: popmort
> ### Title: Background mortality rates for the colon dataset.
> ### Aliases: popmort
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(popmort)
> ## maybe str(popmort) ; ...
> 
> 
> 
> cleanEx()
> nameEx("predict.nsx")
> ### * predict.nsx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predict.nsx
> ### Title: Evaluate a Spline Basis
> ### Aliases: predict.nsx
> ### Keywords: smooth
> 
> ### ** Examples
> 
> basis <- nsx(women$height, df = 5)
> newX <- seq(58, 72, length.out = 51)
> # evaluate the basis at the new data
> predict(basis, newX)
                 1            2            3          4            5
 [1,] 0.0000000000 0.0000000000  0.000000000 0.00000000  0.000000000
 [2,] 0.0001666667 0.0000000000 -0.025270112 0.07581034 -0.050540224
 [3,] 0.0013333333 0.0000000000 -0.050033132 0.15009940 -0.100066264
 [4,] 0.0045000000 0.0000000000 -0.073781966 0.22134590 -0.147563933
 [5,] 0.0106666667 0.0000000000 -0.096009523 0.28802857 -0.192019047
 [6,] 0.0208333333 0.0000000000 -0.116208710 0.34862613 -0.232417420
 [7,] 0.0360000000 0.0000000000 -0.133872434 0.40161730 -0.267744868
 [8,] 0.0571666667 0.0000000000 -0.148493603 0.44548081 -0.296987205
 [9,] 0.0853333333 0.0000000000 -0.159565123 0.47869537 -0.319130247
[10,] 0.1215000000 0.0000000000 -0.166579904 0.49973971 -0.333159807
[11,] 0.1666666667 0.0000000000 -0.169030851 0.50709255 -0.338061702
[12,] 0.2211666667 0.0001666667 -0.166622161 0.49986648 -0.333244323
[13,] 0.2826666667 0.0013333333 -0.159903185 0.47970955 -0.319806370
[14,] 0.3481666667 0.0045000000 -0.149634561 0.44890368 -0.299269122
[15,] 0.4146666667 0.0106666667 -0.136576928 0.40973078 -0.273153855
[16,] 0.4791666667 0.0208333333 -0.121490924 0.36447277 -0.242981848
[17,] 0.5386666667 0.0360000000 -0.105137189 0.31541157 -0.210274379
[18,] 0.5901666667 0.0571666667 -0.088276362 0.26482909 -0.176552724
[19,] 0.6306666667 0.0853333333 -0.071669081 0.21500724 -0.143338162
[20,] 0.6571666667 0.1215000000 -0.056075985 0.16822795 -0.112151970
[21,] 0.6666666667 0.1666666667 -0.042257713 0.12677314 -0.084515425
[22,] 0.6571666667 0.2211666667 -0.030651111 0.09245333 -0.061635555
[23,] 0.6306666667 0.2826666667 -0.020397854 0.06519356 -0.043462374
[24,] 0.5901666667 0.3481666667 -0.010315824 0.04444747 -0.029631648
[25,] 0.5386666667 0.4146666667  0.000777096 0.02966871 -0.019779141
[26,] 0.4791666667 0.4791666667  0.014063024 0.02031093 -0.013540619
[27,] 0.4146666667 0.5386666667  0.030724078 0.01582777 -0.010551844
[28,] 0.3481666667 0.5901666667  0.051942375 0.01567287 -0.010448583
[29,] 0.2826666667 0.6306666667  0.078900034 0.01929990 -0.012866600
[30,] 0.2211666667 0.6571666667  0.112779171 0.02616249 -0.017441658
[31,] 0.1666666667 0.6666666667  0.154761905 0.03571429 -0.023809524
[32,] 0.1215000000 0.6571666667  0.205345238 0.04746429 -0.031476190
[33,] 0.0853333333 0.6306666667  0.262285714 0.06114286 -0.039428571
[34,] 0.0571666667 0.5901666667  0.322654762 0.07653571 -0.046523810
[35,] 0.0360000000 0.5386666667  0.383523810 0.09342857 -0.051619048
[36,] 0.0208333333 0.4791666667  0.441964286 0.11160714 -0.053571429
[37,] 0.0106666667 0.4146666667  0.495047619 0.13085714 -0.051238095
[38,] 0.0045000000 0.3481666667  0.539845238 0.15096429 -0.043476190
[39,] 0.0013333333 0.2826666667  0.573428571 0.17171429 -0.029142857
[40,] 0.0001666667 0.2211666667  0.592869048 0.19289286 -0.007095238
[41,] 0.0000000000 0.1666666667  0.595238095 0.21428571  0.023809524
[42,] 0.0000000000 0.1215000000  0.578428571 0.23571429  0.064357143
[43,] 0.0000000000 0.0853333333  0.543619048 0.25714286  0.113904762
[44,] 0.0000000000 0.0571666667  0.492809524 0.27857143  0.171452381
[45,] 0.0000000000 0.0360000000  0.428000000 0.30000000  0.236000000
[46,] 0.0000000000 0.0208333333  0.351190476 0.32142857  0.306547619
[47,] 0.0000000000 0.0106666667  0.264380952 0.34285714  0.382095238
[48,] 0.0000000000 0.0045000000  0.169571429 0.36428571  0.461642857
[49,] 0.0000000000 0.0013333333  0.068761905 0.38571429  0.544190476
[50,] 0.0000000000 0.0001666667 -0.036047619 0.40714286  0.628738095
[51,] 0.0000000000 0.0000000000 -0.142857143 0.42857143  0.714285714
attr(,"degree")
[1] 3
attr(,"knots")
 20%  40%  60%  80% 
60.8 63.6 66.4 69.2 
attr(,"Boundary.knots")
[1] 58 72
attr(,"intercept")
[1] FALSE
attr(,"derivs")
[1] 2 2
attr(,"centre")
[1] FALSE
attr(,"log")
[1] FALSE
attr(,"q.const")
     [,1] [,2]        [,3]      [,4]       [,5]
[1,]    0    0 -0.08451543 0.2535463 -0.1690309
[2,]    0    0 -0.25354628 0.7606388 -0.5070926
[3,]    1    0  0.00000000 0.0000000  0.0000000
[4,]    0    1  0.00000000 0.0000000  0.0000000
[5,]    0    0  0.92857143 0.2142857 -0.1428571
[6,]    0    0  0.21428571 0.3571429  0.4285714
[7,]    0    0 -0.14285714 0.4285714  0.7142857
attr(,"class")
[1] "nsx"    "basis"  "matrix"
> 
> 
> 
> cleanEx()
> nameEx("predictnl")
> ### * predictnl
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predictnl
> ### Title: Estimation of standard errors using the numerical delta method.
> ### Aliases: predictnl predictnl.default predictnl.lm predict.formula
> ###   confint.predictnl
> 
> ### ** Examples
> 
> 
> df <- data.frame(x=0:1, y=c(10, 20))
> fit <- glm(y ~ x, df, family=poisson)
> 
> predictnl(fit,
+           function(obj,newdata)
+           diff(predict(obj,newdata,type="response")))
  fit   se.fit Estimate       SE
2  10 5.477226       10 5.477226
> 
> 
> 
> 
> cleanEx()
> nameEx("pstpm2-class")
> ### * pstpm2-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pstpm2-class
> ### Title: Class "pstpm2"
> ### Aliases: pstpm2-class plot,pstpm2,missing-method lines,pstpm2-method
> ###   predictnl,pstpm2-method AIC,pstpm2-method AICc,pstpm2-method
> ###   BIC,pstpm2-method anova,pstpm2-method qAICc,pstpm2-method
> ###   summary,pstpm2-method eform,pstpm2-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> showClass("pstpm2")
Class "pstpm2" [package "rstpm2"]

Slots:
                                                                          
Name:           xlevels        contrasts            terms            logli
Class:             list       listOrNULL            terms         function
                                                                          
Name:               gam          timeVar         time0Var         timeExpr
Class:              gam        character        character       nameOrcall
                                                                          
Name:         time0Expr             like      model.frame          delayed
Class: nameOrcallOrNULL         function             list          logical
                                                                          
Name:           frailty                x               xd           termsd
Class:          logical           matrix           matrix            terms
                                                                          
Name:              Call                y               sp           nevent
Class:             call             Surv          numeric          numeric
                                                                          
Name:              link              edf          edf_var               df
Class:             list          numeric          numeric          numeric
                                                                          
Name:              args             call        call.orig             coef
Class:             list         language         language          numeric
                                                                          
Name:          fullcoef             vcov              min          details
Class:          numeric           matrix          numeric             list
                                                                          
Name:         minuslogl           method             data          formula
Class:         function        character             list        character
                       
Name:         optimizer
Class:        character

Extends: "mle2"
> 
> 
> 
> cleanEx()
> nameEx("simulate-methods")
> ### * simulate-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simulate-methods
> ### Title: Simulate values from an stpm2 or pstpm2 fit
> ### Aliases: simulate-methods simulate,stpm2-method simulate,pstpm2-method
> ### Keywords: methods
> 
> ### ** Examples
> 
> set.seed(1002)
> fit1 <- gsm(Surv(rectime,censrec==1)~hormon,data=brcancer,df=3)
> simulate(fit1, nsim=10, newdata=data.frame(hormon=1))
 [1] 2703.0859  748.6945 1539.6721 5389.3433 3378.1634 1054.2523  254.0221
 [8] 1380.9117 3550.0766  460.6406
> simulate(fit1, newdata=data.frame(hormon=0:1))
[1] 1043.4459  488.9217
> 
> 
> 
> 
> cleanEx()
> nameEx("smoothpwc")
> ### * smoothpwc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: smoothpwc
> ### Title: Utility to use a smooth function in markov_msm based on
> ###   piece-wise constant values
> ### Aliases: smoothpwc
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (midts, rates, tmvar = "t", offsetvar = "", ...) 
+ {
+     log.smoother <- splinefunx(midts, log(rates), constant.right = TRUE)
+     haz <- function(newdata) {
+         t <- newdata[[tmvar]] + (if (offsetvar != "") 
+             newdata[[offsetvar]]
+         else 0)
+         exp(log.smoother(t))
+     }
+     structure(list(haz = haz), class = "smoothpwc")
+   }
function (midts, rates, tmvar = "t", offsetvar = "", ...) 
{
    log.smoother <- splinefunx(midts, log(rates), constant.right = TRUE)
    haz <- function(newdata) {
        t <- newdata[[tmvar]] + (if (offsetvar != "") 
            newdata[[offsetvar]]
        else 0)
        exp(log.smoother(t))
    }
    structure(list(haz = haz), class = "smoothpwc")
}
> 
> 
> 
> cleanEx()
> nameEx("stpm2-class")
> ### * stpm2-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stpm2-class
> ### Title: Class "stpm2" ~~~
> ### Aliases: stpm2-class plot,stpm2,missing-method lines,stpm2-method
> ###   predictnl,stpm2-method summary,stpm2-method eform,stpm2-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> showClass("stpm2")
Class "stpm2" [package "rstpm2"]

Slots:
                                                                          
Name:           xlevels        contrasts            terms            logli
Class:             list       listOrNULL            terms         function
                                                                          
Name:                lm          timeVar         time0Var         timeExpr
Class:               lm        character        character       nameOrcall
                                                                          
Name:         time0Expr          delayed         interval          frailty
Class: nameOrcallOrNULL          logical          logical          logical
                                                                          
Name:       model.frame     call.formula                x               xd
Class:             list          formula           matrix           matrix
                                                                          
Name:            termsd             Call                y             link
Class:            terms             call             Surv             list
                                                                          
Name:              args             call        call.orig             coef
Class:             list         language         language          numeric
                                                                          
Name:          fullcoef             vcov              min          details
Class:          numeric           matrix          numeric             list
                                                                          
Name:         minuslogl           method             data          formula
Class:         function        character             list        character
                       
Name:         optimizer
Class:        character

Extends: "mle2"
> 
> 
> 
> cleanEx()
> nameEx("tvcCoxph-class")
> ### * tvcCoxph-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tvcCoxph-class
> ### Title: Class '"tvcCoxph"'
> ### Aliases: tvcCoxph-class plot,tvcCoxph,missing-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> showClass("tvcCoxph")
Class "tvcCoxph" [package "rstpm2"]

Slots:
                                                                            
Name:       call call.orig      coef  fullcoef      vcov       min   details
Class:  language  language   numeric   numeric    matrix   numeric      list
                                                        
Name:  minuslogl    method      data   formula optimizer
Class:  function character      list character character

Extends: "mle2"
> 
> 
> 
> cleanEx()
> nameEx("voptimize")
> ### * voptimize
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: voptimize
> ### Title: Vectorised One Dimensional Optimization
> ### Aliases: voptimize voptimise
> ### Keywords: optimize
> 
> ### ** Examples
> 
> library(graphics)
> 
> f <- function (x, a) (x - a)^2
> xmin <- voptimize(f, lower=c(0, 0), upper=c(1,1), tol = 0.0001, a = c(1/3,2/3))
> xmin
$minimum
[1] 0.3333333 0.6666667

$objective
[1] 0 0

> 
> ## See where the function is evaluated:
> voptimize(function(x) x^2*(print(x)-1), lower = c(0,0), upper = c(10,10))
[1] 3.81966 3.81966
[1] 6.18034 6.18034
[1] 2.36068 2.36068
[1] 2.077939 2.077939
[1] 1.505823 1.505823
[1] 0.9306496 0.9306496
[1] 0.9196752 0.9196752
[1] 0.772905 0.772905
[1] 0.4776816 0.4776816
[1] 0.6491436 0.6491436
[1] 0.656315 0.656315
[1] 0.6653777 0.6653777
[1] 0.6667786 0.6667786
[1] 0.6666728 0.6666728
[1] 0.6666321 0.6666321
[1] 0.6667135 0.6667135
[1] 0.6666728 0.6666728
$minimum
[1] 0.6666728 0.6666728

$objective
[1] -0.1481481 -0.1481481

> 
> ## "wrong" solution with unlucky interval and piecewise constant f():
> f  <- function(x) ifelse(x > -1, ifelse(x < 4, exp(-1/abs(x - 1)), 10), 10)
> fp <- function(x) { print(x); f(x) }
> 
> plot(f, -2,5, ylim = 0:1, col = 2)
> voptimize(fp, cbind(-4, 20))   # doesn't see the minimum
[1] 5.167184
[1] 10.83282
[1] 14.33437
[1] 16.49845
[1] 17.83592
[1] 18.66253
[1] 19.1734
[1] 19.48913
[1] 19.68427
[1] 19.80487
[1] 19.8794
[1] 19.92547
[1] 19.95393
[1] 19.97153
[1] 19.9824
[1] 19.98913
[1] 19.99328
[1] 19.99585
[1] 19.99743
[1] 19.99841
[1] 19.99902
[1] 19.99939
[1] 19.99963
[1] 19.99977
[1] 19.99986
[1] 19.99991
[1] 19.99995
[1] 19.99995
$minimum
[1] 19.99995

$objective
[1] 10

> voptimize(fp, cbind(-7, 20))   # ok
[1] 3.313082
[1] 9.686918
[1] -0.6261646
[1] 1.244956
[1] 1.250965
[1] 0.771827
[1] 0.2378417
[1] 1.000451
[1] 0.9906964
[1] 0.9955736
[1] 0.9980122
[1] 0.9992315
[1] 0.9998411
[1] 0.9996083
[1] 0.9994644
[1] 0.9993754
[1] 0.9993204
[1] 0.9992797
[1] 0.9992797
$minimum
[1] 0.9992797

$objective
[1] 0

> 
> 
> 
> 
> cleanEx()
> nameEx("vuniroot")
> ### * vuniroot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vuniroot
> ### Title: Vectorised One Dimensional Root (Zero) Finding
> ### Aliases: vuniroot
> ### Keywords: optimize
> 
> ### ** Examples
> 
> ##--- vuniroot() with new interval extension + checking features: --------------
> 
> f1 <- function(x) (121 - x^2)/(x^2+1)
> f2 <- function(x) exp(-x)*(x - 12)
> 
> tools::assertCondition(vuniroot(f1, cbind(0,10)),
+                        "error", verbose=TRUE)
assertCondition: caught “error”
> tools::assertCondition(vuniroot(f2, cbind(0, 2)),
+                        "error", verbose=TRUE)
assertCondition: caught “error”
> ##--> error: f() .. end points not of opposite sign
> 
> ## where as  'extendInt="yes"'  simply first enlarges the search interval:
> u1 <- vuniroot(f1, cbind(0,10),extendInt="yes", trace=1)
search in [0,10] ... extended to [-1.5e-05, 11.5] in 4 steps
> u2 <- vuniroot(f2, cbind(0,2), extendInt="yes", trace=2)
search in [0,2]
 .. modified lower,upper: (         -1e-06,           2.02)
 .. modified lower,upper: (         -3e-06,           2.06)
 .. modified lower,upper: (         -7e-06,           2.14)
 .. modified lower,upper: (       -1.5e-05,            2.3)
 .. modified lower,upper: (       -3.1e-05,           2.62)
 .. modified lower,upper: (       -6.3e-05,           3.26)
 .. modified lower,upper: (      -0.000127,           4.54)
 .. modified lower,upper: (      -0.000255,            7.1)
 .. modified lower,upper: (      -0.000511,          12.22)
> stopifnot(all.equal(u1$root, 11, tolerance = 1e-5),
+           all.equal(u2$root, 12, tolerance = 6e-6))
> 
> ## The *danger* of interval extension:
> ## No way to find a zero of a positive function, but
> ## numerically, f(-|M|) becomes zero :
> tools::assertCondition(u3 <- vuniroot(exp, cbind(0,2), extendInt="yes", trace=TRUE),
+                        "error", verbose=TRUE)
search in [0,2] ... extended to [-1073.74, 2.14748e+07] in 30 steps
assertCondition: caught “error”
> 
> ## Nonsense example (must give an error):
> tools::assertCondition( vuniroot(function(x) 1, cbind(0,1), extendInt="yes"),
+                        "error", verbose=TRUE)
assertCondition: caught “error”
> 
> ## Convergence checking :
> sinc_ <- function(x) ifelse(x == 0, 1, sin(x)/x)
> curve(sinc_, -6,18); abline(h=0,v=0, lty=3, col=adjustcolor("gray", 0.8))
> ## Don't show: 
> tools::assertWarning(
+ ## End(Don't show)
+ vuniroot(sinc_, cbind(0,5), extendInt="yes", maxiter=4) #-> "just" a warning
+ ## Don't show: 
+  , verbose=TRUE)
Asserted warning: _NOT_ converged in 4 iterations
> ## End(Don't show)
> 
> ## now with  check.conv=TRUE, must signal a convergence error :
> ## Don't show: 
> tools::assertError(
+ ## End(Don't show)
+ vuniroot(sinc_, cbind(0,5), extendInt="yes", maxiter=4, check.conv=TRUE)
+ ## Don't show: 
+  , verbose=TRUE)
Asserted error: _NOT_ converged in 4 iterations
> ## End(Don't show)
> 
> ### Weibull cumulative hazard (example origin, Ravi Varadhan):
> cumhaz <- function(t, a, b) b * (t/b)^a
> froot <- function(x, u, a, b) cumhaz(x, a, b) - u
> 
> n <- 10
> u <- -log(runif(n))
> a <- 1/2
> b <- 1
> ## Find failure times
> ru <- vuniroot(froot, u=u, a=a, b=b, interval= cbind(rep(1.e-14,n), rep(1e4,n)),
+                extendInt="yes")$root
> ru2 <- vuniroot(froot, u=u, a=a, b=b, interval= cbind(rep(0.01,n), rep(10,n)),
+                 extendInt="yes")$root
> stopifnot(all.equal(ru, ru2, tolerance = 6e-6))
> 
> r1 <- vuniroot(froot, u= 0.99, a=a, b=b, interval= cbind(0.01, 10),
+              extendInt="up")
> stopifnot(all.equal(0.99, cumhaz(r1$root, a=a, b=b)))
> 
> ## An error if 'extendInt' assumes "wrong zero-crossing direction":
> ## Don't show: 
> tools::assertError(
+ ## End(Don't show)
+ vuniroot(froot, u= 0.99, a=a, b=b, interval= cbind(0.1, 10), extendInt="down")
+ ## Don't show: 
+  , verbose=TRUE)
Asserted error: no sign change found in 1000 iterations
> ## End(Don't show)
> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  17.894 0.402 19.181 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
ERROR: modification of compiler constant of type language, length 4
ERROR: the modified constant is function body:
ifelse(x == 0, -0.0986659612490242, sin(x)/x)
ERROR: the body was originally:
ifelse(x == 0, 1, sin(x)/x)
ERROR: modification of compiler constant of type double, length 1
ERROR: the modified value of the constant is:
[1] -0.09866596
ERROR: the original value of the constant is:
[1] 1
ERROR: the modified constant is at index 3
ERROR: the modified constant is in this function body:
ifelse(x == 0, -0.0986659612490242, sin(x)/x)
Fatal error: compiler constants were modified!

