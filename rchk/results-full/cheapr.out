Package cheapr version 1.5.0
Package built using 89288/R 4.6.0; x86_64-pc-linux-gnu; 2026-01-10 10:49:04 UTC; unix   
Checked with rchk version 35618ebbccf3cd0b45a3530e6303970a22a9056b LLVM version 14.0.6
More information at https://github.com/kalibera/cran-checks/blob/master/rchk/PROTECT.md
For rchk in docker image see https://github.com/kalibera/rchk/blob/master/doc/DOCKER.md


Function SEXPREC* lag(SEXPREC*, long, SEXPREC*, bool)::$_0::operator()<SEXPREC* const*>(SEXPREC* const*) const
  [PB] has possible protection stack imbalance cheapr/src/lag.cpp:105

Function SEXPREC* lag(SEXPREC*, long, SEXPREC*, bool)::$_0::operator()<cheapr::r_bool_t const*>(cheapr::r_bool_t const*) const
  [PB] has possible protection stack imbalance cheapr/src/lag.cpp:54

Function SEXPREC* lag(SEXPREC*, long, SEXPREC*, bool)::$_0::operator()<cheapr::r_byte_t const*>(cheapr::r_byte_t const*) const
  [PB] has possible protection stack imbalance cheapr/src/lag.cpp:54

Function SEXPREC* lag(SEXPREC*, long, SEXPREC*, bool)::$_0::operator()<cheapr::r_complex_t const*>(cheapr::r_complex_t const*) const
  [PB] has possible protection stack imbalance cheapr/src/lag.cpp:54

Function SEXPREC* lag(SEXPREC*, long, SEXPREC*, bool)::$_0::operator()<cheapr::r_string_t const*>(cheapr::r_string_t const*) const
  [PB] has possible protection stack imbalance cheapr/src/lag.cpp:105

Function SEXPREC* lag(SEXPREC*, long, SEXPREC*, bool)::$_0::operator()<double const*>(double const*) const
  [PB] has possible protection stack imbalance cheapr/src/lag.cpp:54

Function SEXPREC* lag(SEXPREC*, long, SEXPREC*, bool)::$_0::operator()<int const*>(int const*) const
  [PB] has possible protection stack imbalance cheapr/src/lag.cpp:54

Function SEXPREC* lag(SEXPREC*, long, SEXPREC*, bool)::$_0::operator()<long const*>(long const*) const
  [PB] has possible protection stack imbalance cheapr/src/lag.cpp:54

Function _cheapr_cheapr_do_memory_leak_test
  [UP] ignoring variable <unnamed var:   %4 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_abs
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_add
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_address
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_as_df
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_bin
  [UP] ignoring variable <unnamed var:   %16 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_c
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_cast
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_cast_common
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_ceiling
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_col_all_na
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_col_any_na
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_col_na_counts
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_common_template
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_count_val
  [UP] ignoring variable <unnamed var:   %10 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_df_assign_cols
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_df_col_c
  [UP] ignoring variable <unnamed var:   %10 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_df_col_na_counts
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_df_row_na_counts
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_df_select
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_df_slice
  [UP] ignoring variable <unnamed var:   %10 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_df_subset
  [UP] ignoring variable <unnamed var:   %12 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_divide
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_drop_null
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_exp
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_fixed_width_breaks
  [UP] ignoring variable <unnamed var:   %16 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_floor
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_format_numeric_as_int64
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_gcd
  [UP] ignoring variable <unnamed var:   %14 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_gcd2_vectorised
  [UP] ignoring variable <unnamed var:   %12 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_group_starts
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_growth_rate
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_if_else
  [UP] ignoring variable <unnamed var:   %12 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_int64_to_double
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_int64_to_int
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_int64_to_numeric
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_int_sign
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_intersect
  [UP] ignoring variable <unnamed var:   %10 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_is_na
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_is_whole_number
  [UP] ignoring variable <unnamed var:   %10 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_lag
  [UP] ignoring variable <unnamed var:   %14 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_lag2
  [UP] ignoring variable <unnamed var:   %16 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_lag_sequence
  [UP] ignoring variable <unnamed var:   %10 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_lcm
  [UP] ignoring variable <unnamed var:   %10 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_lcm2_vectorised
  [UP] ignoring variable <unnamed var:   %12 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_lead_sequence
  [UP] ignoring variable <unnamed var:   %10 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_lengths
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_lgl_count
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_lgl_locs
  [UP] ignoring variable <unnamed var:   %16 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_list_args
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_list_as_df
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_list_assign
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_list_c
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_log
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_matrix_col_na_counts
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_matrix_row_na_counts
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_multiply
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_na_init
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_name_repair
  [UP] ignoring variable <unnamed var:   %10 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_negate
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_new_df
  [UP] ignoring variable <unnamed var:   %12 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_new_list
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_num_na
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_numeric_to_int64
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_paste
  [UP] ignoring variable <unnamed var:   %10 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_pow
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_rebuild
  [UP] ignoring variable <unnamed var:   %14 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_recycle
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_rep
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_rep_each
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_rep_len
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_replace
  [UP] ignoring variable <unnamed var:   %14 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_rev
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_round
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_row_na_counts
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_semi_copy
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_sequence
  [UP] ignoring variable <unnamed var:   %14 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_sequence_id
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_set_abs
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_set_add
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_set_add_attr
  [UP] ignoring variable <unnamed var:   %10 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_set_add_attributes
  [UP] ignoring variable <unnamed var:   %10 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_set_ceiling
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_set_change_sign
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_set_divide
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_set_exp
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_set_floor
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_set_log
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_set_multiply
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_set_or
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_set_pow
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_set_rm_attr
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_set_rm_attributes
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_set_round
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_set_sqrt
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_set_subtract
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_set_trunc
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_setdiff
  [UP] ignoring variable <unnamed var:   %10 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_shallow_copy
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_signif
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_sqrt
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_sset
  [UP] ignoring variable <unnamed var:   %10 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_sset2
  [UP] ignoring variable <unnamed var:   %14 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_sset_int64
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_str_coalesce
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_subtract
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_tabulate
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_trunc
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_type
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_unnested_length
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_val_remove
  [UP] ignoring variable <unnamed var:   %10 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_val_replace
  [UP] ignoring variable <unnamed var:   %12 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_vector_length
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_which_
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_which_na
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_which_not_na
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_which_val
  [UP] ignoring variable <unnamed var:   %10 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_cpp_window_sequence
  [UP] ignoring variable <unnamed var:   %12 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_foo3
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _cheapr_r_copy
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function cheapr::internal::add_attrs(SEXPREC*, SEXPREC*)
  [UP] protect stack is too deep, unprotecting all variables, results will be incomplete
  [UP] unsupported form of unprotect, unprotecting all variables, results will be incomplete cheapr/src/../inst/include/cheapr/internal/c_core.h:2227

Function cheapr_do_memory_leak_test()
  [UP] ignoring variable r_ints as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %17 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %26 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable repl as it has address taken, results will be incomplete 
  [UP] ignoring variable seq as it has address taken, results will be incomplete 

Function cpp_col_all_na(SEXPREC*, bool)
  [UP] protect stack is too deep, unprotecting all variables, results will be incomplete
  [UP] unsupported form of unprotect, unprotecting all variables, results will be incomplete cheapr/src/nas.cpp:550

Function cpp_col_any_na(SEXPREC*, bool)
  [UP] protect stack is too deep, unprotecting all variables, results will be incomplete
  [UP] unsupported form of unprotect, unprotecting all variables, results will be incomplete cheapr/src/nas.cpp:493

Function cpp_df_col_na_counts(SEXPREC*)
  [UP] protect stack is too deep, unprotecting all variables, results will be incomplete
  [UP] unsupported form of unprotect, unprotecting all variables, results will be incomplete cheapr/src/nas.cpp:436

Function cpp_df_row_na_counts(SEXPREC*)
  [UP] protect stack is too deep, unprotecting all variables, results will be incomplete
  [UP] unsupported form of unprotect, unprotecting all variables, results will be incomplete cheapr/src/nas.cpp:391

Function cpp_rep_len(SEXPREC*, long)
  [PB] has negative depth cheapr/src/combine.cpp:290
  [UP] attempt to unprotect more items (1) than protected (0), results will be incomplete cheapr/src/combine.cpp:290
  [PB] has possible protection stack imbalance cheapr/src/combine.cpp:299

Function cpp_set_add_attr(SEXPREC*, SEXPREC*, SEXPREC*)
  [PB] has negative depth cheapr/src/attrs.cpp:38
  [UP] attempt to unprotect more items (2) than protected (1), results will be incomplete cheapr/src/attrs.cpp:38
  [PB] has possible protection stack imbalance cheapr/src/attrs.cpp:39

Function cpp_val_replace(SEXPREC*, SEXPREC*, SEXPREC*, bool)
  [UP] protect stack is too deep, unprotecting all variables, results will be incomplete
  [UP] unsupported form of unprotect, unprotecting all variables, results will be incomplete cheapr/src/scalars.cpp:273

Function decltype (Rf_protect(((std::forward<decltype ({parm#1})>)({parm#1}))...)) cheapr_do_memory_leak_test()::$_0::operator()<SEXPREC*>(SEXPREC*&&) const
  [PB] has possible protection stack imbalance cheapr/src/utils.cpp:780

Function decltype (Rf_protect(((std::forward<decltype ({parm#1})>)({parm#1}))...)) cheapr_do_memory_leak_test()::$_2::operator()<SEXPREC*>(SEXPREC*&&) const
  [PB] has possible protection stack imbalance cheapr/src/utils.cpp:781

Function decltype (Rf_protect(((std::forward<decltype ({parm#1})>)({parm#1}))...)) cheapr_do_memory_leak_test()::$_4::operator()<SEXPREC*>(SEXPREC*&&) const
  [PB] has possible protection stack imbalance cheapr/src/utils.cpp:782

Function decltype (Rf_unprotect(((std::forward<decltype ({parm#1})>)({parm#1}))...)) cheapr_do_memory_leak_test()::$_7::operator()<int>(int&&) const
  [PB] has an unsupported form of unprotect (not constant, not variable), results will be incomplete cheapr/src/utils.cpp:784
  [UP] unsupported form of unprotect, unprotecting all variables, results will be incomplete cheapr/src/utils.cpp:784

Function factor_as_character(SEXPREC*)
  [UP] calling allocating function sset_vec(SEXPREC*, SEXPREC*, bool) with argument allocated using cheapr::attr::get_attr(SEXPREC*, cheapr::r_symbol_t) cheapr/src/combine.cpp:607

Function lag(SEXPREC*, long, SEXPREC*, bool)
  [PB] has an unsupported form of unprotect with a variable results will be incomplete cheapr/src/lag.cpp:108
  [UP] unsupported form of unprotect, unprotecting all variables, results will be incomplete cheapr/src/lag.cpp:108

Function na_count(SEXPREC*, bool)
  [PB] has an unsupported form of unprotect with a variable results will be incomplete cheapr/src/nas.cpp:106
  [UP] unsupported form of unprotect, unprotecting all variables, results will be incomplete cheapr/src/nas.cpp:106

Function na_count(SEXPREC*, bool)::$_0::operator()<SEXPREC* const*>(SEXPREC* const*) const::{lambda()#1}::operator()() const
  [PB] has possible protection stack imbalance cheapr/src/nas.cpp:79

Function na_count(SEXPREC*, bool)::$_0::operator()<decltype(nullptr)>(decltype(nullptr)) const::{lambda()#1}::operator()() const
  [PB] has possible protection stack imbalance cheapr/src/nas.cpp:79
